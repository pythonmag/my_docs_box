<!DOCTYPE html> - //* так указывается html 5

<title> Закоголовок вкладки </title>

<body> </body> - не отображается но сюда пишутся всякие мета ссылки

<h1> Заголовок первого уровня </h1> -------->>>>> вообще от <h1>  до <h6>

<p> Границы Абзаца </p>

	<ul>
            <li>html</li>
            <li>head</li>
            <li>body</li>
        </ul>
        --------------->>>> так создается маркированный список <ul> </ul> - маркеры кружки
				а <li> </li> обозначается элемент списка

	<ol start=1>
            <li>h1</li>
            <li>h2</li>
            <li>h3</li>
            <li>я</li>
            <li>он</li>
            <li>она</li>
        </ol> ----------------->>> так задается нумерованный список <ol> </ol>
					<ol start=x> задает число начала нумерации



<!-- --> - комментарий

<pre> блок монохромного текста, как пишется так и видется, предформатированный текст </pre> 
<pre>
	 -                -----  
	 -----           |-----
	||----|          ----||  
	||-----         -----||  
	||-----|       |-----||
	|| -----       ------||
	||- ----|     |------||
	||---||--     -------||
	||--|| --|   |-------||
	|| -|| |--   --- - --||
	|| -||  --|-|--| - ---|
	|---||  |-----| |-----|
	|---||   |----  |-----| 
	|----|    ---   |-----|
	|-----          ------| 
 </pre>

<pre>
 /\ \  __/\ \        /\ \        
  \ \ \/\ \ \ \     __\ \ \____   
   \ \ \ \ \ \ \  /'__`\ \ '__`\  
    \ \ \_/ \_\ \/\  __/\ \ \_\ \ 
     \ `\___x___/\ \____\\ \_,__/ 
      \ /__//__/  \/____/ \/___/ 
</pre>

<code> </code> - удобно отображать программный код по тексту или ссылки например


<em> текст в курсиве без интонации </em>
<i> текс в курсиве с интонацией (симантика) </i>


<strong> жирный текст с особой важностью (симантика) </strong>
<b> жирный текст без акцента на важность </b>


<blockquote> Дриная Цитата, дает выделение, отсупы сверху снизу </blockquote>
<q> короткая цитата в тексте. дает выделение кавычками </q>
<cite> выделение источника или автора цитаты </cite>


<sub></sub> - нижний индекс для символов (от субтитры?)
<sup></sup> - верхний индеск для символов (от саппарт?)
например, H <sub>2</sub> SO <sub>4</sub>  ---------->> нижний индекс
	sin<sup>2</sup>x + cos<sup>2</sup>x =1 -------->> верхний индекс

пометки изменений:
<del datetime="10.10.2012"> Текст на удаление </del> - так помечается текст на удаление и дата такий действий
<ins datetime="10.12.2014"> Текс на добавление </ins> - так помечается текст на добавление с датой изменений 



<mark> Маркирует выделенный текст (делает желтую заливку) </mark>




<img src="/assets/course4/img1.jpg"/> - одинарный тег ссылки на картинку, два элемента: img и src !!

<img width="200" height="200" src="/assets/course4/img1.jpg" />  ------>>> параметр width задает ширину рисунка или в % или в пикселях
									параметр height задает высоту рисунка (только в пикселях)
Когда задается ширина рисунка в %, то и высота автоматически корректируется, а когда высота и ширина задаются в пикселях то габариты рисунка могут исказиться.
<img src="/assets/course4/img1.jpg" width="250" alt="Рыжий кот"/>  --------->> новый элемент alt="xxx" выдает альтернативную надпись, если у пользователя по какой то причине картинка не подгрузилась, т.е. alt лучше делать всегда где описать например картинку.

<a href="/assets/course4/img1.jpg">
            <img src="/assets/course4/img1_small.jpg" />
        </a>     ---------->>> вот это очень интересно, ссылка делается в виде кликабельной картинки, то есть нажимаете на картинку и переходите по указанной ссылке :)



<hr/> - одинарный тег разделитиля в виде горизонтальной полосы (горизонт)

<br/> - одинарный тег переноса внутри абзаца, например


<имя-тега   атрибут1="значение1"   атрибут2="значение2" ...> - так пишется тег с атрибутами и значениями
<img src="/assets/course1/keks.jpg" class='photocard'>  - пример отсылки на картинку с атрибутами

&lt; текст &gt; - эти 2 символа отображаю значки тега в тексе "<>"


    <head>
        <meta charset="utf-8"> ----------->>>  //* таким образом указывается кодировка текста utf-8
    </head> 


    <head>
        <meta name="keywords" content="php, js">  //* таким образом указывается с помощью мета-тега
							ключевые слова для поисковой системы
    </head>


    <head>
        <meta name="description" content="изучаем мета-тэги"> //* тагим тегом задается краткое описание страницы
    </head>

<!-- <p> Первый абзац. </p> --> //* не удалять код а коммитить его вот таким образом


<dl>   ----------------->> dl - задает список определений, dt - задает термини определений, dd - описание самого определения термина
    <dt>Термин</dt>
    <dd>Определение</dd>
</dl>


<a href="..."> </a> - тэг ссылки, где href ее атрибут, который задает адрес ссылки
<a href="http://htmlacademy.ru/courses/40/run/3"> </a> 
	где: http:// - вид протокола связи и передачи данных в сети
		htmlacademy.ru - имя сервера
		/courses/40/run/3 - путь к информации на сервере
<a href="/assets/course4/file.rtf"> ------->> если в конце ссылки имя и тип файла то браузер предложить или скачать или открыть данный файл


ссылки с якорями - очень интересно, вот пример
<h2 id="contents"> Оглавление </h2>  ---------->>>> задали так називаемый идентификатор id (привязан к этой строке)
 	<ol>
             <li><a href="#history">История</a></li>   ---------->> задается отсылка с помощью якоря на идентификатор (все 3 вниз)
             <li><a href="#structure">Структура URL</a></li>
             <li><a href="#encoding">Кодирование URL</a></li>
        </ol>
<h2 id="history"> История </h2>    ---------->>>> еще один идентификатор на который перекидывает ссылка с якорем
<a href="#contents"> К оглавлению </a>     ----------------->>> еще одна ссылка с якорем но ведет на верх
<h2 id="structure"> Структура URL </h2>        ----------------- и так далее :)
<a href="#contents"> К оглавлению </a>
<h2 id="encoding"> Кодирование URL </h2>
<a href="#contents"> К оглавлению </a>


<a title="xxx" href="/assets/course4/file.rtf">   -------------->>> элемент title="xxx" задает всплявающую посказку с надписью xxx если подержать несколько секунд мышку на ссылке, т.е. напишет подсказку по ссылке


ТАБЛИЦЫ

Заголовок таблицы 
<table> 
        <caption> Заголовок таблицы </caption>
 </table>

в css:
caption{
    caption-side: bottom; ------------->> указывает на расположение заголовка по отношения к таблице (top/bottom)
    text-align: left;     ------------->> указывает выравнивание текста (left/right/center)
}



<body>
        <p> <strong>Распределение браузеров</strong> </p>
        
        <table border="1">       ------------------>>> так задается таблица
            <tr>
                <td>Браузер</td>  ------------------>> так описывается строка таблицы из двух столбцов; <tr> - строка таблицы, <td> - ячейка 								внутри строки 
                <td>Посещения</td>
            </tr>
 	</table>


table{                         ------------------>>>> задаются стили для таблиц
    border:3px solid black;     --------------->>> так здается параметр внешней рамки
}

table {
    border-collapse: collapse;  ---------------->>> так схлопываются (склеиваются) рамки таблицы и внешние рамки ячеек
}

td{
    border:1px solid #ccc;  ------------------>>> параметры рамки ячейки
}


border-top:1px solid #ccc;        ------------------->>> так задаются параметры отдельних сторон рамки верх/низ/левый/правый
border-bottom: ...
border-left: ...
border-right: ...


td{
    border:1px solid #ccc;
    padding:5px;          ----------->> <padding> -задает отступы для ячеек (во все стороны)
    padding-right:30px;   ----------->>   - а это именно отступ справа в пикселях, так же можно top/bottom/left/right
}
или тегом <table cellpadding="5"> - тегом в заглавии табл задается размер всех отступов в пикселях, это вместо css.



table{
    border-collapse:separate;  ------------->> выключаем опцию склеивания внешних рамок ячеек (collapse/separate)
    border:2px solid black;
    border-spacing:5px;  ---------------->> так задаются отступы между ячейками
}
...
или тегом <table cellspacing="5"> - тегом в заглавии табл задается отступы между ячейками



table{                 -------------------->> типичное оформление таблици и ячеек
    border-collapse:collapse;    ------  склеивание границ таблицы и ячеек
    border:2px solid black;      ------  размер границ таблицы
}
td{
    padding:5px;                ------- отступы в ячейке во все стороны
    padding-right:30px;         ------- отдельно отступ в ячейке вправо
    border:1px solid #ccc;      ------- размер границы я чейки и цвет
}


<table>
          <tr>
             <th>Браузер</th>  ------------------>> <th> - заголовочные ячейки таблицы (в заголовочной строке) вместо <td>
             <th>Посещения</th>
          </tr>
 </table>



Объединение ячеек в таблицах.
 <tr>
                <th>Браузер</th>
                <th colspan="2"> Посещения </th> ----------->> атрибут colspan="2..." ставится внутри тегов <td> и <th> и растягивает        ячейку  вправо на столько ячеек, сколько указано цифрой

                <th rowspan="2">Браузер</th>   ------------>> атрибут rowspan="2..." растягивает ячейку вниз, на указанное количестов ячеек, причем нижестоящие ячейки сдвигаются на их же строка вправо (опять) и их потом надо вырезать
            </tr>



ФОРМЫ
Формы нужны для того, чтобы отправлять данные с веб-страницы на веб-сервер, который сможет эти данные обработать: зарегистрировать пользователя, создать сообщение на форуме, отправить письмо и так далее. В общем, формы в вебе просто необходимы.

Форма создается с помощью парного тэга <form>, внутри которого размещаются поля формы.

У формы есть два важных атрибута:

    action задаёт адрес (url) отправки формы;
    method задаёт метод отправки формы. (post/get)

Для отправки формы обычно используют методы get или post. Метод get посылает данные формы в строке запроса (т.е. они видны в адресной строке браузера), а post посылает данные в теле http-запроса. Метод post используют, когда нужно отправить много данных.

<form method="post" action="/echo"> ...... </form> ----->> отправляет данные по адресу /echo  методом post

Большинство полей форм создаётся с помощью одиночного тэга input. У этого тэга два обязательных атрибута:

    type задаёт тип поля;
    name задаёт имя поля.

Тип поля влияет на то, как оно будет отображаться и вести себя. Самый распространенный тип — это text, который обозначает текстовое поле.

Имя поля нужно, чтобы правильно обработать данные на сервере. Обычно, имя поля должно быть уникальным в пределах формы (хотя есть и исключения). Для задания имени поля обычно используются латинские буквы и цифры.

<body>
        <h1>Форма входа</h1>
        <form action="/echo" method="post">
            <input type="text" name="login">  -------------->> выдает на экран пустую таблицу для ввода пароля
        </form>
    </body>

Атрибут id поля ввода обозначает идентификатор. Он должен быть уникальным в пределах формы.

Идентификатор в отличие от имени поля не передается на сервер. Он используется для связывания полей и подписей к ним, а также в скриптах. Можно использовать одинаковые значения для имени и идентификатора поля, а можно и разные.

Атрибут value задает значение поля ввода по умолчанию. Например, в форме оплаты интернет-магазина в поле Сумма обычно подставляют стоимость заказа.

<body>
        <h1>Форма оплаты</h1>
        
        <form action="/echo" method="post"> ------------>> передает нижеуказанные данные формы на сервер
            Сумма оплаты: <input type="text" name="total" id="total-field" value="100"> руб. 
		------------->> id - идентификатор, привязывает значение, value задает значение в форму по умолчанию (до ввода оператором)
        </form>
        
    </body>


Подпись для поля ввода создаётся с помощью парного тэга <label> (лейба).

Если щелкнуть по подписи мышкой, то курсор переместится в соответствующее поле.

Создавать подписи к полям с помощью <label> — хороший приём. Используйте его.

<form action="/echo" method="post">
            <label>           ----------------------------------------->> если мышкой надать на "Ваш логин" то перекинет в форму
            Ваш логин <input type="text" name="login" id="login-field">
            </label>
        </form>


Связываем подпись и поле по id [5/18]

Иногда обернуть поле в тэг <label> нельзя. Например, когда подпись и поле размещены в разных ячейках таблицы.

В этом случае можно связать подпись с полем с помощью атрибута id. Задаём полю какой-нибудь идентификатор и этот же идентификатор записываем в атрибут for тэга <label>. Например:

<body>
        <h1>Форма входа</h1>
        
        <form action="/echo" method="post">
        
            <table>   --------------------------->> задана таблица из двух ячеек
            <tr>
                <td>   --------------------->> первая ячейка обернута в подпись и привязана к другой ячейке через id="login-field" через FOR
                    <!-- подпись внутрь этой ячейки -->
                    <label for="login-field"> Ваш логин </label>
                </td>
                <td> <input type="text" name="login" id="login-field"> </td>
            </tr>
            </table>
            
        </form>
        
    </body>


<body>
        <h1> Форма входа </h1>
        <form action="/echo" method="post">
        
            <label for="login-field"> Ваш логин </label> --------------->> одно поле для ввода с приклейкой по id
            <input type="text" name="login" id="login-field"><br>
            
            <label for="password-field"> Ваш пароль </label> ----------->> второе поле для ввода с приклейкой по id
            <!-- подпись с этим текстом -->
            <!-- добавьте поле сюда -->
            <input type="text" name="password" id="password-field"><br>   ------>> если type="password" то ввод текста защищается звездочками
         </form>
</body>



<body>
        <h1>Форма входа</h1>
        <form action="/echo" method="post">
            <label for="login-field">Ваш логин</label>
            <input type="text" name="login" id="login-field">
            <br>
            <label for="password-field">Ваш пароль</label>
            <input type="password" name="password" id="password-field">  
            <br> 
            <!-- добавьте кнопку сюда -->
            <input type="submit" value="Войти"> -------------->> так создается кнопка для отправки данных на сервер, и называется например 									ВОЙТИ
        </form>
 </body>

<body>
        <h1>Комментарии</h1>
        <form action="/echo" method="post">
            <p>Список комментариев, а внизу поле для вашего комментария:</p>
            <textarea name="comment" id="comment-field" rows="10" cols="40"> ------------>> так задаутся ячейка много строчного комментария, где <rows> -задает количесво строк ввысоту, <cols> - задает ширину поля в колонках
            Текст комментария
            </textarea>
            <!-- добавьте поле сюда --->
            <input type="submit" value="Отправить">
        </form>
    </body>


<form action="/echo" method="post">
            <p>Множество полей и как всегда в конце формы регистрации вопрос:</p>
            <input type="checkbox" checked name="subscribe" id="subscribe-field"> ---------->> тегом чек добавляется галочка да/нет, если написано чекид то галочка ставится по умолчанию
            <label for="subscribe-field">Подписать вас на рассылку?</label>  ----------->> идет увязка по айди
            <input type="submit" value="Отправить">
        </form>


Контрольная
<body>
        <h1>Регистрация</h1>
        
        <form action="/echo" method="post">
            <label for "login-field"> Ваш логин (email): </label> <br>   -------->> форма логина
            <input type="text" name="login" id="login-field"> <br>
            
            <label for "password-field"> Пароль: </label> <br>     -------------->> форма пароля
            <input type="password" name="password" id="password-field"> <br>
            
            <label for "comment-field"> Информация о себе: <br>  --------------->> форма комментария
            <textarea name="comment" id="comment-field" rows="3">
            </textarea> <br>
            
            <input type="checkbox" checked name="subscribe" id="subscribe-field"> ------->> форма птички
            <label for="subscribe-field"> Подписать вас на рассылку </label> <br>
            
            <input type="submit" value=" Зарегистрироваться"> <br>  -------------->> кнопка отправки данных
            
     	</form>
        
</body>



ПЕРЕКЛЮЧАТЕЛИ
Переключатель или «радиобаттон»
Поле-переключатель — это тэг <input> с типом <type="radio">.
Обычно переключатели размещают группами по несколько штук. Причем у переключателей из одной группы должно быть одинаковое имя и разные значения, которые задаются c помощью value.

Таким образом, атрибут value является для переключателей обязательным. Браузер отправляет на сервер значение value выбранного переключателя.
<label> <input type="radio" name="question1" value="p">
 тэг &lt; p &gt;</label> 


 <form action="/echo" method="post">
            <p>В тестах часто встречают задания типа «выберите один из предложенных вариантов».</p>
            <p><em>Какой тэг обозначает «абзац»?</em></p>
            
            <label><input type="radio" name="question1" value="p"> тэг &lt; p &gt;</label><br>  ------>> 2 переключателя как варианты ответа
            
            <label><input type="radio" name="question1" value="b" checked> тэг &lt; b &gt;</label> ---->> 2-й ответ задан по умолчанию чеком
            
            <input type="submit" value="Отправить">
        </form>



ВЫПАДАЙКИ

Выпадающий список или «селект» [14/18]

Выпадающий список так же, как и переключатель, позволяет выбрать один вариант ответа из нескольких.

Выпадающий список создается с помощью парного тэга <select>, у которого есть знакомые атрибуты name и id.

Варианты ответов задаются с помощью парных тэгов <option>, которые должны располагаться внутри тэга <select>. Например:

<select name="some-name">
    <option>1</option>
    <option>2</option>
    ...
</select>

Внутри тэга <option> располагается подпись варианта ответа . Также тэгу <option> можно задать атрибут value, который содержит значение варианта ответа. <value="2000">

Если при отправке формы у выбранного варианта задан value, то на сервер отправится значение этого атрибута. В противном случае будет отправлен текст подписи.
<body>
        <h1>Анкета</h1>
        
        <form action="/echo" method="post">
        
            <p>Часто выпадающие списки используют для ввода дат.</p>
            <p><em>Ваш год рождения</em></p>
            <select name="year">
            <option value="2000"> 2000 год </option>
            <option value="2001"> 2001 год </option>
            </select>

           <input type="submit" value="Отправить">
        </form>
        
    </body>



«Мультиселект» [15/18]
Выпадающий список можно превратить в так называемый «мультиселект», т.е. список, в котором можно выбрать не один, а несколько вариантов.

Чтобы сделать это, нужно добавить к тэгу <select> атрибут multiple, а также дописать символы [] к имени списка, например name="some-name[]". Это нужно для того, чтобы браузер отправлял все выбранные значения в виде массива.

Выбрать несколько вариантов можно, зажав клавишу CTRL и щелкая по ним мышкой.

Высоту мультиселекта можно изменять с помощью атрибута size тэга <select>.

Чтобы отметить как выбранные по умолчанию одно или несколько значений, нужно к соответствующим тэгам <option> добавить атрибут selected.
<form action="/echo" method="post">
            <p>В мультиселекте можно выбрать несколько вариантов, щелкая по ним, зажав клавишу Ctrl.</p>
            <p><em>Любимые дни недели</em></p>
            
            <select multiple name="days []" size="7"> -------->> добавлен атрибут <multiple> и размер выпадайки установлен в 7 срок
                <option selected> Понедельник</option> ------->> ячейка установлена по умолчанию
                <option> Вторник</option>
                <option> Среда</option>
                <option> Четверг</option>
                <option selected> Пятница</option>
                <option> Суббота</option>
                <option> Воскресенье</option>
            </select>
            
     <input type="submit" value="Отправить">
</form>



Поле для загрузки файлов [16/18]
Поле для загрузки файлов — это тэг <input> с типом file. Для этого поля обязательным атрибутом является имя. Если его не задать, то на сервере вы не сможете найти загруженный файл.

Чтобы поле заработало и браузер смог передать выбранный файл на сервер, необходимо добавить форме атрибут enctype со значением multipart/form-data.
<body>
        <h1>Профиль</h1>
        
        <form action="/echo" method="post" enctype="multipart/form-data"> ----->> добавлен в фрму атрибут для загрузки файлов
            <p>Выберите изображение для своего аватара:</p>
            <input type="file" name="avatar">         ------------->> тайп файл для загрузки файлов и обязельно назначение имени   
            <input type="submit" value="Загрузить">
        </form>
</body>



Скрытое поле [17/18]

И ещё одно невидимое и очень полезное поле. Это скрытое поле. Его используют, когда в форме нужно отправить какие-то дополнительные служебные данные, которые не вводятся пользователем.

Например, это могут быть реквизиты заказа или номер пользователя в форме оплаты.

Скрытое поле — это тэг <input> с типом hidden. --------->> можно задать имя(name) и значение(value), что и уйдет на сервер
<form action="/echo" method="post">
            <p><label>
		Сумма платежа: <input type="text" name="amount" value="500"> руб.
		</label></p>
            <input type="hidden" name="account_number" value="225">            
            <input type="submit" value="Оплатить">
</form>




Блочные элементы [1/23]

Элементы HTML страницы обычно делятся на блочные и строчные.

Блочные элементы можно представлять как прямоугольные области на странице. Они имеют следующие особенности:

    До и после блочного элемента существует перенос строки.
    Блочным элементам можно задавать ширину, высоту, внутренние и внешние отступы.
    Занимают всё доступное пространство по горизонтали.

К блочным элементам относятся такие тэги как: <p>, <h1>, <h2>, <ul> и так далее.

Еще один важный блочный тэг — это тэг <div>, который обозначает просто «блок» или «прямоугольный контейнер». Этот тэг чаще всего используется для создания сеток.

Существуют и более сложные типы элементов, им будет посвящена вторая часть курса.


Строчные элементы [2/23]

Строчные элементы располагаются друг за другом в одной строке, при необходимости строка переносится. Особенности строчных элементов:

    До и после строчного элемента отсутствуют переносы строки.
    Ширина и высота строчного элемента зависит только от его содержания, задать размеры с помощью CSS нельзя.
    Можно задавать только горизонтальные отступы.

К строчным элементам относятся такие тэги как: <a>, <strong>, <em>, <span> и так далее.

Строчные элементы предназначены для оформления текста на уровне небольших фраз и отдельных слов. Блочные же элементы предназначены для разметки крупных блоков текста (заголовки, абзацы, списки) и создания сетки.

Пример:
<!DOCTYPE html>
<html>

    <head>
       <title>Строчные элементы</title>
       <meta charset="utf-8">
       <link rel="stylesheet" href="/assets/course9/style1.css" />
    </head>
    
    <body>
    
        <h1>Строчные элементы</h1>
        
        <p><em>Строчные элементы</em> <strong>не создают переносов</strong> <span>строки</span> до и после себя. 
        Такие элементы располагаются в строке слева направо. 
        Если <em>строчный элемент</em> <span>не помещается в родительский контейнер</span>, то он переносится на следующую строку.
        <em>Очень интересно.</em>
        <span> Вот так вот </span> </br>	------------------ для каждого тега в css можно задать соответствующие параметры.
        <span> И вот так вот </span>
            
        </p>
    </body>
    
</html>





Ширина и высота [3/23]

Ширина и высота элементов задаются с помощью свойств width и height соответственно.

По умолчанию блочные элементы занимают всю доступную ширину, которая равна ширине родительского контейнера или окна браузера.

Высота по умолчанию блочных элементов зависит от их содержимого. Если задать блочному элементу ширину и высоту так, что содержимое элемента не будет в него помещаться, то оно как бы «выпадет» из него.

Строчные элементы не реагируют на задание ширины и высоты в CSS.

Задать ширину блоку можно, например, так:

.selector{
    width: 100px;
    height: 100px;
}

Вернуть значения по умолчанию можно с помощью специального значения auto:

.selector{
    width: auto;
    height: auto;
}




Внутренние отступы, свойство padding [4/23]

Свойство padding задает внутренние отступы элемента — отступы от внешней границы элемента до его содержания. Эти отступы еще иногда называют полями.

Существует несколько способов записи свойства padding.

padding: 10px;
padding: 5px 10px;
padding: 5px 10px 15px;
padding: 5px 10px 15px 20px;		--------------- верх/право/низ/лево     (top/right/bottom/left)

    Одинаковые отступы со всех сторон.

    Отступы сверху и снизу 5px, справа и слева 10px.

    Отступ сверху 5px, слева и справа 10px, снизу 15px.

    Разные отступы со всех сторон, в порядке верхний, правый, нижний, левый.

Также можно задавать отступы для разных сторон с помощью свойств padding-left, padding-right, padding-top, padding-bottom.

Для строчных элементов лучше не задавать вертикальных отступов, т.к. они ведут себя непредсказуемо.

В задании внутренние отступы блоков сделаны прозрачными.



Внешние отступы, свойство margin [5/23]

Свойство margin задает внешние отступы элемента — отступы от внешней границы элемента до границ родительского элемента или до соседних элементов.

Способы записи свойства margin аналогичны свойству padding.

margin: 10px;
margin: 5px 10px;
margin: 5px 10px 15px;
margin: 5px 10px 15px 20px;

    Одинаковые отступы со всех сторон.

    Сверху и снизу 5px, справа и слева 10px.

    Сверху 5px, слева и справа 10px, снизу 15px.

    Верхний, правый, нижний, левый отступы соответственно.

Можно задавать отступы для разных сторон с помощью свойств margin-left, margin-right, margin-top, margin-bottom.

Строчные элементы реагируют только на горизонтальные отступы.




Рамки [6/23]

Рамка задаётся с помощью свойства border, которое состоит из трёх компонентов:

    ширина рамки;
    стиль рамки;
    цвет.

Например:

selector{
    border: 5px solid red;
}

Это правило задаёт красную сплошную рамку толщиной 5px.

Задавать рамку можно одним свойством border, а можно и с помощью отдельных свойств border-width, border-style, border-color. Например:

selector{
    border-width: 5px;
    border-style: solid;
    border-color: red;
}

Это правило задаёт такую же рамку, как и в примере выше.

Несколько самых распространенных стилей рамок:

    solid — сплошная;
    dashed — пунктирная;
    dotted — точками.

Рамку можно задавать и строчным, и блочным элементам.
Пример фрагмента css:
span{
    border:none;
}

.b1{
    border: 2px dashed yellow;	--------------- желтая рамка штрихпунктиром
}

.b2{
    border: 2px dotted yellow;	-------------- желтая рамка точками
}

.b3{
    border: 10px solid yellow;	--------------- желтая рамка спложной линией
}



Стандартная блочная модель [7/23]

Стандартная блочная модель отвечает на основной вопрос:

    Сколько же в итоге места будет занимать элемент?

Ответ следующий:

    Область, занимаемая блочным элементом, складывается из его ширины и высоты содержания, внутренних и внешних отступов, ширины рамок .

Для строчных элементов есть свои особенности, которые мы опишем позже.

Схема блочной модели:

Блочная модель

    ширина/высота содержания — свойства width и height (синий прямоугольник на схеме);
    внутренние отступы — свойство padding;
    рамки — свойство border;
    внешние отступы — свойство margin.



«Схлопывание» внешних отступов [9/23]

Во второй части курса разберем некоторые важные тонкости блочной модели. И начнем с внешних отступов (или маргинов).

Вертикальный отступ между двумя соседними элементами равен максимальному отступу между ними. Если отступ одного элемента равен 20px, а второго 40px, то отступ между ними будет 40px.

Этот эффект называется эффектом «схлопывания» внешних отступов или «схлопывания» маргинов.

Горизонтальные отступы между элементами просто складываются. Например, горизонтальный отступ между двумя элементами с отступами 30px будет равен 60px.




«Выпадание» внешних отступов [10/23]

«Выпадание» — это еще один эффект, связанный с вертикальными внешними отступами. Если внутри родительского блока расположить блок и задать ему отступ сверху, то внутренний блок прижмется к верхнему краю родительского, а у родительского элемента появится отступ сверху. Т.е. верхний отступ внутреннего элемента «выпадает» из родительского элемента.

Если у родительского элемента тоже был задан внешний отступ, то выберется максимальный отступ между собственным и «выпавшим» .

Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу внутренний отступ (паддинг) сверху или добавить рамку сверху.

Внешние и внутренние отступы всегда складываются.
Задание

    Второму блоку задайте margin-top:20px;
    Первому блоку задайте margin-top:40px;
    Первому блоку задайте border:1px solid white;
    Первому блоку задайте padding-top:20px;

Обратите внимание на отступ от края первого блока до второго блока. Он будет размером 40px (2 клеточки).





Как отцентровать элемент? [11/23]

Чтобы отцентровать блочный элемент, нужно выполнить следующие действия:

    Задать элементу ширину, которая меньше ширины родительского контейнера.
    Задать для внешних отступов справа и слева значение auto.

Примеры кода:

selector{
    width:100px;
    margin:0 auto;
}
selector{
    width:100px;
    margin-left:auto;
    margin-right:auto;
Пример:
<!DOCTYPE html>
<html>

    <head>
       <title>Как отцентровать элемент?</title>
       <meta charset="utf-8">
       <link rel="stylesheet" href="/assets/course9/style1.css" />
    </head>
    
    <body>
        <div class="block">Блок 1</div>       
    </body>
    
</html>
---------------
body{
    padding:20px;
}
.block{                             // в итоге отцентрованный блок
    height:96px;
    line-height:96px;
    text-align:center;
    vertical-align:center;
    width: 96px;
    margin-left:auto;
    margin-right:auto;
}



Блочная модель и строчные элементы [12/23]

Еще раз акцентируем внимание на особенности поведения строчных элементов в блочной модели:

    Не реагируют на CSS-свойства width и height.
    Частично реагируют на margin, воспринимая только горизонтальные отступы.
    Частично реагируют на padding, воспринимая только горизонтальные отступы.
    При задании вертикальных padding визуально увеличиваются, но без увеличения занимаемого места (не отталкивают другие элементы).
    Воспринимают рамки. Аналогично padding рамки сверху и снизу не увеличивают занимаемое элементом место.


Ширина 100% и ширина по умолчанию [13/23]

CSS-свойство width задаёт не общую ширину блока, а только ширину содержания. Общая ширина блока затем складывается из трёх компонентов: ширины содержания, внутренних отступов и ширины рамок слева и справа.

Поведение элемента может зависеть от того, как именно вы зададите его ширину.

Первый вариант. Вариант по умолчанию, когда ширина не задается, соответствует значению width:auto;. В этом случае блок занимает всю ширину родительского блока. Если у блока есть внутренние отступы или рамки, то его ширина содержания автоматически уменьшается, а общая ширина остается равной ширине родителя.

Второй вариант. Когда ширина блока задана явно, например, width:100%;. В этом случае ширина содержания блока равна ширине родительского блока. Если блоку добавить внутренние отступы и рамки, то его общая ширина становится больше ширины родителя.



Изменяем блочную модель, свойство box-sizing [15/23]

Проблему с шириной тянущихся полей решить сложно. Идеальным вариантом было бы изменение алгоритма расчета ширины элемента, чтобы свойство width задавало не ширину содержания, а общую ширину.

К счастью, такая возможность была добавлена в CSS3 с помощью свойства box-sizing, которое уже поддерживается большинством современных браузеров.

Это свойство имеет два значения:

    content-box — значение по умолчанию, соответствует стандартной блочной модели.
    border-box — изменяет режим расчета ширины элемента на описанный выше.

Данное свойство лучше задавать с использованием префиксов, т.к. оно достаточно новое:

-webkit-box-sizing: border-box;
 -moz-box-sizing: border-box;
 box-sizing: border-box;

пример:
<body>
        <div class="block" style="width:200px;">
            <input type="text" value="Фамилия" />
        </div>
        <div class="block" style="width:250px;">
            <input type="text" value="Имя" />
        </div>
        <div class="block" style="width:300px;">
            <input type="text" value="Отчество" />
        </div>
    </body>

-----------------
body{
    padding:20px;
}
.block{
    padding:10px;
    margin-bottom:20px;
}
input[type="text"]{
    color:#666;
    border:2px solid #ccc;
    border-radius:5px;
    width:100%;
    padding:5px 10px;
    box-sizing: border-box; -------------------- содержания блока для ввода текста вписывается в рамку болока
}




HTML Academy
Блочная модель документа / Второе испытание [16/23]
<!DOCTYPE html>
<html>
    <head>
       <title>Второе испытание</title>
       <meta charset="utf-8">
    </head>
    <body>
        <div class="block block1" style="padding:0;">
            <div class="block block2">
                <input type="text" style="width:100%;" value="Значение поля" />
            </div>
        </div>
    </body>
</html>
-----------------------
/* Базовые стили, изменять не нужно */
html, body{
    margin:0;
    padding:0;
}
body{
    width:260px;
    min-height:210px;
    padding:20px;
    font-family:"Arial", sans-serif;
    font-size:14px;
    line-height:1.5;
    color:white;    
    background-color:#3A78A1;
    background-image:url('/assets/course9/grid.png');
    background-repeat:repeat;
    background-position:-80px -80px;
}
input[type="text"]{
    height:38px;
    font-size:18px;
    font-family:sans-serif, "Arial";
    border:2px solid #ccc;
    border-radius:5px;
}
.block{
    background:rgba(0, 255, 255, 0.2);
}

/* Cтили, которые можно изменять */
.block1{	-----------------------первый блок (с рамкой)
    border: 2px solid;
    width:256px;
    height:114px;
}

.block2{	-------------------- второй блок (внутри первого) без рамки
    margin:18px 18px;
    width:220px;
    height:78px;
}

input[type="text"] {	------------------ блок ввода текста (внутри первых двух)
    margin:20px 20px;
    height:24px !important;
    width:156px !important;
    padding:5px 10px;
}




Управление типом элемента, свойство display [17/23]

Тип элемента не является чем-то вечным и неизменным, его можно изменять с помощью CSS. За это отвечает свойство display.

С его помощью, например, можно сделать абзацы и заголовки строчными, а спаны и стронги блочными элементами.

У свойства display много значений. С двумя из них вы уже заочно познакомились. Свойство display:block обозначает блочный элемент, а display:inline — строчный. 	------------------ задается в css свойствах, например тег <p> можно сделать строкой с помощью свойства display:inline, а тег <strong> можно сделать блоком с помощью свойства display:block.

В третьей части курса мы познакомимся с некоторыми более продвинутыми значениями свойства display.




display: inline-block [18/23]

Иногда возникает необходимость расположить в ряд несколько элементов с заданными размерами. Строчные элементы для этого не подходят, т.к. не воспринимают размеры. Блочные элементы тоже не подходят, т.к. до и после них существует перенос строки. Конечно, блочные элементы можно приспособить для такой задачи, используя дополнительные свойства (которые будут разбираться в курсе про сетки).

Но более простой способ — использовать блочно-строчные элементы. В HTML нет тэгов, которые по умолчанию вели бы себя как блочно-строчные, но любой элемент можно переключить в данный режим, задав ему свойство display со значением inline-block.

Особенности блочно-строчных элементов:

    им можно задавать размеры, рамки и отступы, как и блочным элементам;
    их ширина по умолчанию зависит от содержания, а не растягивается на всю ширину контейнера;
    они не порождают принудительных переносов строк, поэтому могут располагаться на одной строке, пока помещаются в родительский контейнер;
    элементы в одной строке выравниваются вертикально подобно строчным элементам.



display: table [19/23]

Дальнейшие несколько заданий будут посвящены табличным типам элементов.

Табличные сетки были очень популярны на заре веба. Действительно, у табличных сеток есть преимущества, которые очень сложно получить с помощью блоков. Например, столбцы одинаковой высоты.

Однако, семантически таблицы не предназначены для разметки сеток и постепенно от них отказались. Но память об их удобстве жила.

Позднее было разработано семейство значений свойства display, которое позволяет задать табличное поведение любым элементам.

Первое значение — display:table задает элементу тип таблица. Особенности табличных элементов:

    можно задавать ширину, высоту, рамки, отступы;
    по умолчанию ширина зависит от содержания;
    переносы строки до и после элемента.

Табличные элементы похожи на блочные за исключением ширины по умолчанию.




display: table-row [20/23]

Как вы догадались, мы строим таблицу на дивах с помощью новых значений свойства display. Знания про таблицы вы можете освежить в курсе Знакомство с таблицами.

Любая таблица содержит элементы строка таблицы, внутри которых должны содержаться элементы ячейка таблицы. Соответствие тэгов таблицы значениям display:

<table> — display:table;

<tr> — display:table-row;

<td> — display:table-cell;

В этом задании вы создадите строки таблицы с помощью display:table-row;. Строка — необычный элемент. Она является контейнером для ячеек и практически не имеет собственного отображения. Для нее можно только задавать цвет фона.
пример:
<body>
        <h1>Посещения по городам</h1>
        <div class="table">
            <div class="row">
                <div class="cell">Город</div>
                <div class="cell">Посещения</div>
                <div class="cell">Страниц</div>
                <div class="cell">Время</div>
            </div>
            <div class="row">
                <div class="cell">СПБ</div>
                <div class="cell">500</div>
                <div class="cell">6</div>
                <div class="cell">00:08:05</div>
            </div>
        </div>
</body>

------------------------
div{
    padding:5px;
    margin:5px;
    border:1px dotted white;
}
.table{
    display:table; 	----------------- задает содержимое как таблицу
    background:#D9EDF7;
    border-color:#3A87AD;
}
.row{
    background:#F2DEDE;
    border-color:#B94A48;
    display:table-row; 	------------------- задает содержимое как отдельную строку в таблице
}
.cell{
    background:#FBEED5;
    border-color:#C09853;
}



display: table-cell [21/23]

С помощью значения table-cell свойства display можно задать элементу тип ячейка таблицы. Конечно, лучше чтобы элементы-ячейки находились внутри элементов-строк, которые находятся внутри элементов-таблиц. ---------- задает свойства для строки в виде ячейки таблицы, и соответственно выстраивается таблица в виде нескольких ячеек в строке.

Вы можете просто задать элементу тип ячейка таблицы, не добавляя вокруг него дополнительных элементов-строк и таблиц. В этом случае браузер создаст дополнительные анонимные элементы строки и таблицы. Неудобство заключается в том, что вы не сможете ими управлять.

К таблицам, созданным с помощью CSS, можно применять те же свойства, что и к обычным таблицам. Например, задавать отступы между ячейками или режим схлопывания границ.




display: none [22/23] + visibility: hidden

Значение none свойства display используется очень часто. С его помощью можно скрыть элемент, как будто его и не было. Скрытый элемент не отображается и не занимает места на странице. (display: none)

Данное свойство применяется при создании выпадающих меню, динамических галерей, переключающихся вкладок и много где еще.

Есть еще одно CSS-свойство, которое используется для сокрытия элементов. Это свойство visibility со значением hidden. Оно «прячет» элемент — он становится невидимым, но занимает место на странице.



HTML Academy
Блочная модель документа / Последнее испытание [23/23]
<!DOCTYPE html>
<html>
    <head>
       <title>Последнее испытание </title>
       <meta charset="utf-8">
    </head>
    <body>
        <div class="column">
            <strong>Базовые</strong><br/>
            block<br/>
            inline<br/>
            list-item<br/>
            none
        </div>
        <div class="column">
            <strong>Сложные</strong><br/>
            inline-block<br/>
            inline-table
        </div>
        <div class="table">
            <div class="row">
                <div class="cell col-1">
                    <strong>Табличные</strong>
                </div>
                <div class="cell col-2"></div>
                <div class="cell col-3"></div>
            </div>                
            <div class="row">
                <div class="cell col-1">
                    table
                </div>
                <div class="cell col-2">
                    -row<br/>
                    -cell<br/>
                    -column<br/>
                    -caption<br/>
                </div>
                <div class="cell col-3">
                    строка<br/>
                    ячейка<br/>
                    колонка<br/>
                    заголовок<br/>
                </div>
            </div>
        </div>
    </body>
</html>

------------------
/* Базовые стили, изменять не нужно */
html, body{
    margin:0;
    padding:0;
}
body{
    width:260px;
    min-height:210px;
    padding:20px;
    font-family:"Arial", sans-serif;
    font-size:14px;
    line-height:1.5;
    color:white;
    background-color:#3A78A1;
    background-image:url('/assets/course9/grid.png');
    background-repeat:repeat;
    background-position:-80px -80px;
}

/* Cтили, которые можно изменять */
.column{
    margin-bottom:10px;
    padding:10px;
    border:2px solid white;
    background:rgba(0, 255, 255, 0.2);
    display: inline-block;
    vertical-align:top;
    box-sizing: border-box;
    width: 100px;
    margin-right: 10px;
}

/* Превращаем в таблицу, схлопываем границы */
.table {
display:table;
border-collapse: collapse;
}

/* Превращаем в строки */
.row{
display: table-row;
}

/* Превращаем в ячейки и задаем ширину (минус границы), можно использовать border-box и тогда width будет 100px */
.cell{
    padding:5px 10px;
    border:2px solid white;
    background:rgba(0, 255, 255, 0.2);
    display: table-cell;
    width: 96px;
    }
    
/* Удаляем 3-ю колонку */
.col-3 {
display:none;
}



Относительное позиционирование [2/20]

CSS-свойство position задает режим позиционирования элементов. Значением по умолчанию является static, которое означает «обычное позиционирование».

Значение relative обозначает «относительное позиционирование». Относительно спозиционированный элемент можно перемещать относительно его исходного положения.

Относительно спозиционированный элемент остается в потоке документа, а при его перемещении наблюдаются интересные эффекты. Для начала просто зададим относительное позиционирование выбранному блоку.





position:relative и top [3/20]

Пока что ничего не произошло, но мы еще и не перемещали элемент. Чтобы эффект перемещения был более наглядным, блок .block-relative обёрнут в блок .block-shadow, который служит «тенью» элемента.

Блок-тень имеет те же размеры, что и блок внутри него. Это позволит нам отследить, как изменяется поведение относительно спозиционированного элемента в потоке.

Свойство top позволяет сместить относительно спозиционированный элемент вверх или вниз относительно его исходного положения. Значение этого свойства обычно задается в пикселях, но можно использовать и другие единицы измерения CSS.
пример:
<body>
        <div class="block">Блок 1</div>
        <div class="block-shadow">
            <div class="block-relative">Блок 2</div>
        </div>
        <div class="block">Блок 3</div>
    </body>
--------------
.block-relative{
    position:relative;
    top: -10px;
    padding:10px;
    margin-bottom:20px;
    background:#3A78A1;
    color:white;
}




position:relative и left [4/20]

Вы заметили, что когда мы сместили блок вниз, нижележащие блоки не сдвинулись?

Это происходит потому, что относительно спозиционированный элемент на самом деле никуда не смещается. Он остаётся в потоке ровно там же, где и был (это место обозначено блоком-тенью). А смещается иллюзорная копия блока.

Свойство left позволяет сместить блок влево или вправо относительно исходного положения.

В этом задании вы не только сместите блок по горизонтали, но и убедитесь в том, что он остался в потоке, увеличив его высоту. При этом нижний блок должен будет сместиться.
пример:
<body>
        <div class="block">Блок 1</div>
        <div class="block-shadow">
            <div class="block-relative">Блок 2</div>
        </div>
        <div class="block">Блок 3</div>
    </body>
-----------------
.block-relative{
    position:relative;
    top:10px;
    left: -10px;
    height:100px;
    padding:10px;
    margin-bottom:20px;
    background:#3A78A1;
    color:white;
}


position:relative и bottom [5/20]

Свойство bottom аналогично свойству top, только смещает элемент в другом направлении.

Положительное значения свойства bottom сместит элемент вверх, а отрицательное вниз.



position:relative и right [6/20]

Свойство right аналогично свойству left и тоже смещает элемент в другом направлении.

Как вы уже убедились, относительно спозиционированный элемент можно смещать по горизонтали и по вертикали, комбинируя свойства top/bottom со свойствами left/right.

Ещё раз убедимся, что элемент на самом деле никуда не смещается, увеличив отступ снизу (margin...). Размер отступа будет расчитываться от нижнего края блока-тени, а не от края смещенного блока-иллюзии.




Относительное позиционирование на практике [7/20]

В реальных проектах относительное позиционирование может использоваться для создания декоративных эффектов, хотя область его применения намного шире.

В этом задании вы создадите псевдотень для изображений похожую на тень в отзывах на главной странице HTML Academy. Все стили уже подготовлены, не хватает только тех, которые отвечают за позиционирование.
<body>
        <div class="frame">
            <img width="150" src="/themes/htmlacademy/img/opinions/morozov.jpg" alt="" />
        </div>
        <div class="frame">
            <img width="75" src="/themes/htmlacademy/img/opinions/efimova.jpg" alt="" />
        </div>
    </body>
----------------------
.frame{
    display:inline-block;
    margin:10px;
    border-radius:6px;
    background-color:#27AE60;
}
.frame img{
    display:block;
    border-radius:5px;
    position: relative;
    top: -5px;
    left: -5px;
}



Абсолютное позиционирование [8/20]

Значение absolute свойства position задаёт элементу абсолютное позиционирование.

Абсолютно спозиционированные элементы обладают следующими особенностями:

    Выпадают из потока документа. Место, которое они занимали, становится как бы пустым и его занимают соседние элементы.
    Ширина по умолчанию зависит от содержимого (а не растягивается на всю доступную ширину).
    Остаются на том же месте, где были, если не заданы значения свойств top, left, right, bottom.




Абсолютное позиционирование и строчные элементы [9/20]

Абсолютное позиционирование изменяет поведение не только блочных элементов (ширина по умолчанию), но и строчных.

Если строчный элемент спозиционирован абсолютно, то он ведет себя точно так же, как и абсолютно спозиционированный блочный. Например, такому строчному элементу можно задавать размеры с помощью width и height.

Можно сказать, что есть еще один тип элементов — абсолютно спозиционированные. Такими становятся элементы всех остальных типов (блочные, строчные, блочно-строчные и т.д.), если им задано свойство position:absolute;.
<body>
        <div class="block">Блок 1</div>
        <span class="inline-absolute">Строчный элемент</span>
        <div class="block">Блок 3</div>
    </body>
-------------------
.inline-absolute{
    background:red;
    color:white;
    opacity:0.5;
    position:absolute;
    width: 200px;
    height: 100px;
}
.block{
    margin-bottom:20px;
    padding:10px;
    background:#3A78A1;
    color:white;
    text-align:center;
}
body{
    padding:20px;
}




Абсолютное позиционирование на практике [17/20]

На практике абсолютное позиционирование часто применяют в декоративных целях, когда нужно аккуратно разместить какие-либо иконки, управляющие элементы или другие «рюшечки».

В этом задании вы узнаете, как применяется абсолютное позиционирование в блоках достижений в HTML Academy. С помощью внутреннего отступа в левую часть блока добавляется пустое пространство, в которое с помощью абсолютного позиционирования выносится иконка достижения.



Фиксированное позиционирование [18/20]

Значение fixed свойства position задаёт элементу фиксированное позиционирование.

Фиксированное позиционирование похоже на абсолютное, но есть и отличия:

    Фиксированный элемент тоже выпадает из потока.
    Фиксированный элемент привязывается к определенной точке в окне браузера и остается на ней всегда, даже при прокрутке страницы.
    Фиксированный элемент можно позиционировать с помощью свойств top, left, right, bottom, но точка отсчета всегда привязана к окну браузера.

Можете представить себе фиксированный элемент, как стикер, который наклеен на монитор. Такие элементы часто применяют для создания навигационных панелей, привязанных к верхней или нижней части окна браузера.




z-index или кто кого перекроет [19/20]

Если в одном месте страницы оказываются несколько «абсолютных» блоков, то они перекрывают друг друга. По умолчанию выше оказывается тот блок, который расположен дальше в коде страницы.

C помощью CSS-свойства z-index можно управлять тем, как перекрываются блоки. Значением этого свойства может быть целое число. Чем больше z-index, тем выше располагается блок.

Cвойство z-index работает для элементов, у которых position задано как absolute, fixed и relative. Таким образом, «относительный» элемент может перекрывать «абсолютный».



Курс «Позиционирование»
Испытание: собери слово «вечность» [20/20]

В «Снежной королеве» Кай собирал из льдинок слово «Вечность». В этом испытании вам нужно собрать из 12 заготовок слово «HTML».

Используйте тот тип позиционирования и те приёмы позиционирования, которые вам больше понравились. Сетка на заднем фоне поможет вам правильно расчитать координаты. Напомним, что маленькая ячейка имеет размер 20 на 20 пикселей, а большая 100 на 100.

<!DOCTYPE html>
<html>
    <head>
       <title>Испытание: собери слово «вечность» </title>
       <meta charset="utf-8">
       <link rel="stylesheet" href="https://htmlacademy.ru/assets/course10/style1.css" />
    </head>
    <body>
        <div class="h h1"></div>
        <div class="h h2"></div>
        <div class="h h3"></div>
        <div class="v v1"></div>
        <div class="v v2"></div>
        <div class="v v3"></div>
        <div class="v v4"></div>
        <div class="v v5"></div>
        <div class="v v6"></div>
        <div class="corner-top"></div>
        <div class="corner-bottom"></div>
        <div class="logo"></div>
    </body>
</html>
-----------------------------------
html{
    padding:0;
}
body{
    padding:0;
    margin:0;
    height:260px;
    width:260px;
}
div{
    display:inline-block;
    background:white;
}
/* горизонтальные элементы */
.h{
    width:50px;
    height:10px;
    position: relative; /*устанавливаем позиционирование*/
}

.h1{
    top:150px;
    left: 20px;
}

.h2{
    top: 130px;
    left: 26px;
}

.h3{
    width:40px;
    top: 170px;
    left: 92px;
}


/* вертикальные элементы */
.v{
    width:10px;
    height:50px;
    position: relative; /* установим позиционирование */
    top: 170px; /* положение по вертикали */
/* у этих элементов одинаково, поэтому */
/* можно задать сразу всем элементам */
/* одинаковую координату */
}

.v1{
    left: -132px;
}

.v2{
    left: -106px;
}

.v3{
    left: -80px;
}
.v4{
    left: -54px;
}
.v5{
    left: -28px;
}
.v6{
    left: -22px;
}

/* уголки */
.corner-top{
    border:15px solid white;
    border-top-width:20px;
    border-bottom-width:0;
    border-top-color:transparent;
    background:none;
    position: relative; /* установим позиционирование */
    left: 150px; 
    top: 69px; /* и координаты */
}

.corner-bottom{
    border:15px solid transparent;
    border-top-width:20px;
    border-bottom-width:0;
    border-top-color:white;
    background:none;
    position: relative; /* установим позиционирование */
    left: 116px; 
    top: 89px; /* и координаты */
}

/* лого */
.logo{
    width:64px;
    height:64px;
    background:url('/assets/course10/logo.png');
    position: relative; /* установим позиционирование */
    left: 19px; 
    top: 24px; /* и координаты */
}



Курс «Сетки»
Пробуем управлять потоком [1/32]

C понятием потока документа вы познакомились в курсе про позиционирование.

Поток — это порядок отображения элементов на странице. По умолчанию блочные элементы отображаются как прямоугольные области, идущие друг за другом сверху вниз, а строчные элементы располагаются сверху вниз и слева направо и при необходимости переносятся на новую строку.

Потоком можно управлять и изменять привычное поведение элементов в потоке. Например, можно заставить блочные элементы двигаться не сверху вниз, а выстраиваться в несколько колонок.

А научившись управлять потоком, вы сможете строить сетки.


Управление потоком, шаг 3 [3/32]

Со вторым блоком разобрались. Теперь уже первые два блока наезжают на третий.

Чтобы получить нужный нам поток, осталось задать размеры третьему блоку, отцентровать его и избавиться от эффекта «наезжания».

Поможет нам в этом свойство clear.
<body>
        <div class="container">
            Наш поток:
            <div class="header block">.header</div>
            <div class="column1 block">.column1</div>
            <div class="column2 block">.column2</div>
            <div class="column3 block">.column3</div>
            <div class="footer block">.footer</div>
        </div>
        <div class="container">
            Что строим:
            <img src="/assets/course15/final-flow-1.png">
        </div>
    </body>

-------------------------
body{
    font-family:'PT Sans', sans-serif;
}
.container{
    width:300px;
    margin:10px auto;
}
.block{
    padding:10px;
    margin-bottom:10px;
    border:2px dashed #ccc;
    color:#CC0000;
    background:rgba(255, 234, 171, 0.5);
}
.column1{
    float:left;
    width:120px;
    min-height:50px;
}
.column2{
    float:right;
    width:120px;
    min-height:50px;
}
.column3{
    clear: both;
    width:150px;
    min-height:50px;
    margin-left: auto;
    margin-right: auto;
    }



Курс «Сетки»
Другой поток, шаг 2 [5/32]

А пока вы пошагово создаёте второй поток, поговорим о сетках.

Сетка — это взаимное расположение крупных блоков сайта. Вспомните любой сайт, например, ВКонтакте или HTML Academy.

У ВКонтакте простая сетка, которая состоит из верхней части, или «хедера», под которой располагаются две колонки, а в самом низу расположен «футер» или нижняя часть сайта. Вот так схематично можно представить сетку ВКонтакте:

-------------------------------------
 хедер
-------------------------------------
 левая колонка | правая колонка
 меню          | основное содержание
-------------------------------------
 футер
-------------------------------------

У HTML Academy на разных страницах используются разные сетки. Например, на главной странице есть двухколончатый хедер, под ним содержание страницы в три колонки, затем нижнее меню и двухколончатый футер.

Как вы понимаете, сетки могут быть самыми разными.


Другой поток, шаг 3 [6/32]

Что нужно знать и уметь, чтобы строить сетки? Две вещи:

    управлять размерами элементов;
    управлять поведением элементов в потоке.

Первая часть детально разбирается в курсе «Блочная модель документа». Там вы учитесь:

    задавать размеры;
    рамки;
    внешние и внутренние отступы;
    рассчитывать полный размер элемента;
    рассчитывать занимаемую им площадь.

Управлять поведением в потоке мы будем учиться в этом курсе.


Другой поток, финал [7/32]

Существует несколько способов управлять потоком и строить сетки:

    флоаты;
    инлайн-блоки;
    табличная вёрстка;
    флексбоксы.

Табличная вёрстка — самый простой для понимания способ построения сеток. Но он считается устаревшим и использовать его не рекомендуется. В будущем можно будет использовать для такой вёрстки не таблицы, а элементы с display:table, display:table-row и display:table-cell.

Флексбоксы — это новая и очень мощная технология для построения сеток. К сожалению, её поддержка браузерами ещё достаточно слабая.

А флоаты и инлайн-блоки мы разберём в этом курсе более подробно. Основной упор сделаем на флоаты, т. к. сейчас это самый распространённый способ построения сеток.

А пока что завершите создание своей второй сетки.

<body>
        <div class="container">
            Наш поток:
            <div class="header block">.header</div>
            <div class="column1 block">.column1</div>
            <div class="column2 block">.column2</div>
            <div class="column3 block">.column3</div>
            <div class="footer block">.footer</div>
        </div>
        <div class="container">
            Что строим:
            <img src="/assets/course15/final-flow-2.png">
        </div>
    </body>
------------------
body{
    font-family:'PT Sans', sans-serif;
}
.container{
    width:300px;
    margin:10px auto;
}
.block{
    padding:10px;
    margin-bottom:10px;
    border:2px dashed #ccc;
    color:#CC0000;
    background:rgba(255, 234, 171, 0.5);
}
.column1{
    float:left;
    width:65px;
    min-height:50px;
    margin-right:9px;
}
.column2{
    float:left;
    width:80px;
    min-height:50px;
}
.column3{
    float:right;
    width:65px;
    min-height:50px;
}
.footer{
    clear: both;
}



Погружение в флоаты [8/32]

А теперь детально разберём свойство float, его значения, особенности поведения и способы применения.
Т. к. у этого свойства нет устоявшегося русского перевода или термина, то мы будем называть его «флоатом», а также использовать конструкции наподобие «зафлоатить».

Изначально float было предназначено для того, чтобы включать обтекание элементов текстом. Наподобие того, как в более старой версии HTML текст обтекал изображения c атрибутами align="left" или align="right".

То есть, можно сказать, что float — это свойство, включающее режим обтекания. Но, как часто бывает, судьба уготовила ему совсем другую роль.

Свойство float имеет следующие значения:

    left — прижимает элемент к левому краю родителя, другие элементы обтекают его справа;
    right — прижимает элемент к правому краю родителя, другие элементы обтекают его слева;
    none — отключает режим обтекания и возвращает элементу нормальное поведение.

Обратите внимание, что зафлоатить элемент по центру нельзя.




float и выпадание из потока [10/32]

Мы уже говорили про выпадание элементов из потока, когда разбирали абсолютное и фиксированное позиционирование.

Зафлоаченные элементы тоже выпадают из потока, но лишь частично:

    Блочные элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.
    Строчные же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.

Ещё раз: для блочных элементов флоатные не существуют, но текст внутри блоков флоатные обтекает.

Такое поведение флоатов даёт интересные эффекты:

    Эффект прохождения сквозь блоки. Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.
    Эффект выпадания из родителя или схлопывания родителя. Проявляется тогда, когда все дочерние блоки в родителе зафлоачены. В этом случае родитель схлопывается по высоте, как будто в нём нет содержимого, а блоки выпадают из него.



Флоат рядом с флоатом [11/32]

Флоатные элементы становятся невидимыми для блочных элементов и видимыми для текста. А как же они взаимодействуют друг с другом?

Если вкратце то: флоатные элементы видят друг друга.

Идущие друг за другом флоаты выстраиваются в ряд, пока им хватает свободного места. Если места не хватает, то они начинают переноситься на следующую строчку. Почти как текст.

Как раз эта особенность флоатов и позволила применять их для создания сеток. Ведь в начале двухтысячных в CSS не было никакого другого способа создавать колонки и задавать им размеры.

Блочные элементы всегда располагались в разных строках. А строчные элементы, хоть и могли располагаться на одной строке, совершенно не воспринимали размеры. Позиционирование тоже не подходило для сеток, т. к. элементы выпадали из потока.

В общем, флоаты оказались как нельзя кстати для тех, кто решил уходить с табличной вёрстки.

<!DOCTYPE html>
<html>

    <head>
       <title>Флоат рядом с флоатом</title>
       <meta charset="utf-8">
       <link href="http://fonts.googleapis.com/css?family=PT+Sans:400&subset=cyrillic" rel="stylesheet" type="text/css">
    </head>
    
    <body>
        <div class="container">
            <h1>Флоат влево</h1>
            <div class="block block1">.block1</div>
            <div class="block block2">.block2</div>
            <div class="block block3">.block3</div>
        </div>
        
        <div class="container">
            <h1>Флоат вправо</h1>
            <div class="block block4">.block4</div>
            <div class="block block5">.block5</div>
            <div class="block block6">.block6</div>
        </div>
        
    </body>
--------------------------
body{
    font-family:'PT Sans', sans-serif;
}
h1{
    font-size:20px;
    margin-top:0;
}
.container{
    width:400px;
    padding:10px;
    min-height:100px; /* прячем эффект выпадания флоатов */
    margin:20px auto;
    box-shadow:0 0 2px #ccc;
}
.block{
    margin-bottom:10px;
    padding:10px;
    background:#3498db;
    color:white;
    border:2px solid #34495e;
}

.block1 {
    float:left;
    margin-right:10px;
    }
    
.block2 {
    float:left;
    margin-right:10px;
    }
    
.block3 {
    float:left;
    }
    
.block4 {
    float:right;
    margin-left:10px;
    }
    
.block5 {
    float:right;
    margin-left:10px;
    }
    
.block6 {
    float:right;
    }




Когда флоатов много, а места мало [12/32]

Следует отметить, что поведение нескольких флоатов, когда им не хватает места в одной строке, является очень странным.

Когда не влезающий флоат переносится на новую строку, возможно несколько вариантов и не все из них логичны. Например, флоат может «зацепиться» за один из предшествующих флоатов и встать ниже не в самом начале строки, а за предшествующим.

В этом упражнении примеры специально подобраны так, чтобы вы увидели странности поведения флоатов при недостатке места.

Естественно, эти особенности повлияли на приёмы использования флоатов в создании раскладок (еще одно название для сеток). Но об этом позже.

<!DOCTYPE html>
<html>
    <head>
       <title>Когда флоатов много, а места мало</title>
       <meta charset="utf-8">
       <link href="http://fonts.googleapis.com/css?family=PT+Sans:400&subset=cyrillic" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div class="container">
            <h1>Флоат влево</h1>
            <div class="block block1">.block1</div>
            <div class="block block2">.block2</div>
            <div class="block block3">.block3</div>
        </div>
        <div class="container">
            <h1>Флоат вправо</h1>
            <div class="block block4">.block4</div>
            <div class="block block5">.block5</div>
            <div class="block block6">.block6</div>
        </div>
    </body>
</html>
----------------------------------------------------
body{
    font-family:'PT Sans', sans-serif;
}
h1{
    font-size:20px;
    margin-top:0;
}
.container{
    width:400px;
    padding:10px;
    min-height:150px; /* прячем эффект выпадания флоатов */
    margin:20px auto;
    box-shadow:0 0 2px #ccc;
}
.block{
    margin-bottom:10px;
    padding:10px;
    background:#3498db;
    color:white;
    border:2px solid #34495e;
}
.block1, .block2, .block3{
    float:left;
    margin-right:10px;
    width:95px;
}
.block4, .block5, .block6{
    float:right;
    margin-left:10px;
    width:95px;
}

.block1 {
    width:200px;
    height:50px;
    }
    
.block4 {
    margin-left:30px;
    height:50px;
    }
    
.block6 {
    width:300px;
    }


Простейшая сетка, шаг 1 [17/32]

Мы разобрали по косточкам свойство float, познакомились с clear и научились бороться с некоторыми проблемами флоатов.

В этой части курса мы будем практиковаться строить сетки на флоатах.

И начнём с простейшей сетки «хедер - две колонки - футер». Одна колонка будет фиксированной ширины, а вторая будет растягиваться в зависимости от ширины контейнера.

В исходном состоянии у нас 4 блока, расположенных друг под другом. Первым делом займёмся боковой панелью или «сайдбаром»: зафлоатим её влево и зададим её фиксированную ширину.

    Цель 1 Задайте сайдбару флоат влево.
    Цель 2 Задайте сайдбару ширину 150px.

Простейшая сетка, шаг 2 [18/32]

Мы зафлоатили сайдбар, и он вывалился из контейнера и залез на футер. Исправим это с помощью псевдораспорки.

Вам нужно будет добавить контейнеру колонок класс clearfix. А после этого добавить несколько свойств в CSS-правило для псевдораспорки.


    Цель 1 Добавьте элементу с классом content-container класс clearfix.
    Цель 2 Добавьте CSS-правилу .clearfix:after свойство content со значением ''.
    Цель 3 Туда же добавьте свойство display со значением table
    Цель 4 и свойство clear со значением both.

Простейшая сетка, финал [19/32]

Поздравляем! Вы победили выпадание. Теперь завершим сетку.

В почти готовую сетку мы добавили немного текста, чтобы посмотреть как она будет себя вести с наполнением. Сейчас видно, что синий блок контента частично залезает под сайдбар. Чтобы избавиться от этого эффекта, можно задать блоку контента маргин слева.

После этого сетка будет завершена. Кстати, мы получили ещё один интересный результат. Мы не зафлоатили блок контента, поэтому он тянется на всю ширину родительского контейнера. А фиксированный маргин слева предохраняет его от заползания под сайдбар.

Таким образом, у нас получилась сетка из двух колонок, одна из которых фиксированная, а вторая тянется. Здесь важно следующее — сайдбар в HTML коде должен располагаться до блока контента, иначе такого эффекта не получится.
--------------------------------
<body>
        <div class="wrapper">
            <div class="header">Хедер</div>
            <div class="content-container clearfix">
                <div class="sidebar">
                    <p>Для нужного нам эффекта мы дадим основному блоку левый margin, чтобы он ужался направо, а боковую панель заfloat'им.</p>
                </div>
                <div class="content">
                    <p>У этого способа есть один очень серьезный недостаток. Обратите внимание, что в исходном HTML блок "sidebar" идет до блока "content" с основным содержимым. Не нужно думать, что так сделано случайно. Так сделано специально, потому что иначе этот самый способ с наложением колонки поверх margin'а не работал бы.</p>
                </div>
            </div>
            <div class="footer">Футер</div>
        </div>
    </body>
------------------------------
body{
    margin:0;
    padding:0;
    font-family:'PT Sans', sans-serif;
}
.wrapper{
    width:550px;
    margin:0 auto;
    box-shadow:0 0 2px #ccc;
}
.header,
.footer{
    padding:10px;
    background:#ecf0f1;
}
.sidebar{
    float:left;	----------------зафлоаченный левый блок в сетке
    width:150px;
    min-height:150px;
    padding:10px;
    background:rgba(46, 204, 113, 0.8);
    color:white;
}
.content{
    min-height:100px;
    padding:10px;
    background:#3498db;
    color:white;
    margin-left:170px;	--------------- правый блок сетки контент, маргин слева чтобы не запозал на левый блок
}
.clearfix:after{	--------------- псевдо-блок распорка. идет в сетке по принципу остатка от блоков и не дает выпадать из родителя соседним(связанным) блокам
    content:'';
    clear:both;
    display:table;
}


Сетка посложнее, шаг 1 [20/32]

Теперь построим более сложную сетку. В конце у нас получится вот такой результат:

Да, мы повторяем раскладку главной страницы HTML Academy: двухколончатый хедер и контент в три колонки.

На этом шаге создадим сетку хедера. Пока что работаем без содержания.


Сетка посложнее, шаг 2 [21/32]

Обратите внимание на способ именования классов: колонки имеют класс layout-column.

Префикс layout обозначает «сетка» или «раскладка». Таким образом, мы даём понять, что классы с этим префиксом предназначены для создания сетки. Обычно для таких классов задают только флоаты, размеры и внешние отступы.

Использование значимых префиксов для именования классов — хороший приём. Используйте его в своей вёрстке.

На втором шаге мы создадим колонки содержания.

<body>
        <div class="wrapper">
            <div class="header clearfix">
                <div class="layout-column layout-column-1">
                    Лого
                </div>
                <div class="layout-column layout-column-2">
                    Меню
                </div>
            </div>
            <div class="features clearfix">
                <div class="layout-column">
                    Колонка 1
                </div>
                <div class="layout-column">
                    Колонка 2
                </div>
                <div class="layout-column">
                    Колонка 3
                </div>
            </div>
            <div class="footer">
                Футер        
            </div>
        </div>
    </body>
----------------------------
body{
    margin:0;
    padding:0;
    font-family:'PT Sans', sans-serif;
}
.wrapper{
    width:430px;
    margin:0 auto;
    box-shadow:0 0 2px #ccc;
}
.clearfix:after{
    content:'';
    clear:both;
    display:table;
}
.header{
    background:#34495e;
    margin-bottom:10px;
    color:white;
}
.header .layout-column{
    min-height:50px;
    background:rgba(192, 57, 43, 0.9);
    border-bottom:2px dashed #95a5a6;
}
.header .layout-column-1{
    float:left;
    width:280px;
}
.header .layout-column-2{
    float:right;
    width:130px;
}
.features{
    margin-bottom:10px;

    
}
.features .layout-column{
    min-height:100px;
    background:rgba(236, 240, 241, 0.9);
    border-bottom:2px dashed #95a5a6;
    float:left;
    width:130px;
    
}
.footer{
    min-height:50px;
    background:#34495e;
    color:white;
}



Погружение в inline-block [28/32]

C блочно-строчными элементами вы уже знакомились в курсе про блочную модель документа. Напомним, что это элементы, у которых свойство display имеет значение inline-block.

Блочно-строчные элементы ведут себя двояко. Снаружи они выглядят как обычные строчные, но внутри они ведут себя как блочные.

От строчных им достались следующие черты:

    по ширине они ужимаются под своё содержимое;
    могут располагаться в одну строку;
    реагируют на вертикальное выравнивание, vertical-align;
    реагируют на горизонтальное выравнивание, text-align, заданное у родителя.

От блочных:

    им можно задавать размеры с помощью width и height;
    а также внешние и внутренние отступы и рамки, которые работают во всех направлениях и увеличивают размер элемента.

 <body>
    
        <div class="container">
        
            <div class="block">
                Блок 1<br> Высота средняя
            </div>
            
            <div class="block">
                Блок 2<br> Высота больше среднего
            </div>
            
            <div class="block">
                Блок 2<br> Низкий
            </div>
            
        </div>
        
    </body>
------------------------

    Цель 1 Задайте элементам с классом block блочно-строчный тип.
    Цель 2 Затем задайте контейнеру горизонтальное выравнивание текста по центру,
    Цель 3 а блокам выравнивание по левому краю.
    Цель 4 Задайте блокам вертикальное выравнивание посередине: middle.
-------------------------
body{
    font-family:'PT Sans', sans-serif;
}
.container{
    width:400px;
    padding:10px;
    margin:20px auto;
    box-shadow:0 0 2px #ccc;
    text-align:center;
}
.block{
    width:70px;
    margin:10px 5px;
    padding:10px;
    background:#3498db;
    color:white;
    border:2px solid #34495e;
    display: inline-block;
    text-align:left;
    vertical-align:middle;
}------------------------




float vs inline-block [29/32]

Блочно-строчные элементы могут выстраиваться друг за другом, а если не хватает места, то они переносятся на следующую строку.

Поведение похоже на флоатные элементы, однако, есть существенное отличие.

При переносе на следующую строку блочно-строчные ведут себя намного логичней. Высота строк у них рассчитывается по максимальному элементу с учётом отступов.

Это упражнение создано, чтобы продемонстрировать отличие в поведении флоатов и инлайн-блоков. В исходном состоянии мы видим несколько флоатных блоков, которые не смогли выстроиться в ряды, так как зацепились друг за друга.

Вы измените тип блоков на блочно-строчные и сами всё увидите, насколько умнее ведут себя инлайн-блоки.
------------------------------------------
У элементов с классом .block:

    Цель 1 отключите режим обтекания,
    Цель 2 поменяйте тип на блочно-строчный,
    Цель 3 установите вертикальное выравнивание по верхнему краю.
    Цель 4 Затем увеличьте маргин снизу до 20px.
---------------------------------------------
body{
    font-size:16px;
    font-family:'PT Sans', sans-serif;
}
.container{
    width:400px;
    padding:10px;
    margin:20px auto;
    box-shadow:0 0 2px #ccc;
}
.container:after{
    content:'';
    display:table;
    clear:both;
}
.block{
    /*float:left;*/
    display: inline-block;
    vertical-align:top;
    
    width:90px;
    margin-right:10px;
    margin-bottom:20px;
    padding:10px;
    background:#3498db;
    color:white;
    border:2px solid #34495e;    
}----------------------------




Простая сетка на inline-block [30/32]

Блочно-строчные элементы очень часто используют для создания декоративных элементов: кнопок, плашек, блочков. Также благодаря их умному поведению с их помощью создают различные списки товаров в каталогах.

Для создания сеток страниц эти элементы используются реже. Первая причина заключается в том, что их не поддерживают старые браузеры, например, IE7 и младше. А сетка страницы — слишком критичная вещь, чтобы позволять ей ломаться даже в старых браузерах.

Есть и еще одна проблема, с которой мы столкнёмся в этом задании. Давайте попробуем построить сетку, как на картинке, когда у нас края товаров вплотную прилегают к краям контейнера:

Ширина контейнера 400px, ширина товара с рамками 120px, отступ между товарами 20px. Чтобы три товара влезали в строку «пиксель-в-пиксель», нужно у каждого третьего товара обнулить отступ справа. Используем для этого селектор .item:nth-child(3n).
------------------------------

    Цель 1 Задайте элементам с классом .item блочно-строчный тип,
    Цель 2 маргин справа 20px
    Цель 3 и вертикальное выравнивание по верхнему краю.
    Цель 4 Затем обнулите маргин справа у каждого третьего .item.
------------------------------
.item{
    display: inline-block;
    width:116px;
    min-height:75px;
    margin-bottom:20px;
    margin-right:20px;
    vertical-align:top;
    
    
    text-align:center;
    background:#3498db;
    color:white;
    border:2px solid #2c3e50;    
}

.item:nth-child(3n) {
    margin-right:0px;
    }-----------------------




inline-block и пробелы в коде [31/32]

Мы рассчитали всё правильно, однако по три товара в строку не помещается.

Причина заключается в пробелах после тэгов в HTML-коде. Блочно-строчные ведут себя как текст, поэтому если в коде есть пробел между элементами, то он отображается и на странице. Этот пробел увеличивает отступы между товарами, не давая им поместиться в одну строку.

Бороться с пробелом после блочно-строчных можно несколькими способами:

    удалять пробелы в коде;
    обнулять размер шрифта;
    играться с маргинами после блочно-строчного.

У каждого из способов есть свои недостатки, а подробнее эти и другие способы разбираются в нашем переводе хорошей статьи (есть ещё более обширная статья про блочно-строчные).    
http://css-live.ru/articles/zagadochnye-otstupy-mezhdu-inlajn-blokami.html

Мы попробуем последние два способа.

Способ со шрифтом заключается в том, что мы задаём нулевой размер шрифта у контейнера инлайн-блоков, а самим инлайн-блокам задаём исходный размер шрифта. Способ не работает, если вы используете относительные размеры шрифта.

Способ с маргинами заключается в том, что мы уменьшаем отступ после инлайн-блока на ширину пробела, около 4px. А если нам нужно, чтобы элементы стояли вплотную друг к другу, то задаём отрицательный отступ. Проблема с этим способом заключается в том, что размер пробела может быть разным в разных шрифтах и может изменяться при изменении размера шрифта.
-----------------------------

    Цель 1 1 способ: задайте для .catalog нулевой размер шрифта,
    Цель 2 а для .item размер шрифта 16px.
    Цель 3 2 способ: верните .catalog размер шрифта 16px и уменьшите у .item маргин справа до 16px.
-----------------------------
body{
    font-size:16px;
    font-family:'PT Sans', sans-serif;
}
h1{
    margin:0;
    margin-bottom:0.5em;
    font-size:18px;
}
.container{
    width:400px;
    margin:20px auto;
}
.catalog{
    width:400px;
    background:#ecf0f1;
    box-shadow:0 0 3px #999;
    
    font-size:16px;
}
.item{
    display:inline-block;
    width:116px;
    min-height:75px;
    margin-bottom:20px;
    margin-right:16px;
    text-align:center;
    background:#3498db;
    color:white;
    border:2px solid #2c3e50;
    vertical-align:top;
    
    font-size:16px;
}
.item:nth-child(3n){
    margin-right:0;
}---------------------------




/////////////////////////////////////////
Курс «Фоны»
В этом курсе вы научитесь использовать фоновые изображения и задавать цвета фона. Также мы разберемся с популярными в веб форматами изображений и познакомимся с некоторыми приёмами создания декоративных эффектов.
Автор: Александр Першин

---------------------------------

Cвойство background-color [1/16]

Цвет фона можно задать с помощью CSS-свойства background-color.

Напомним, что цвета в CSS можно задавать в разных форматах: в шестнадцатеричном (или HEX), в RGB или RGBA, а также с помощью цветовых констант, таких как red или green.

Более подробно о цветах можно прочитать на странице W3C HTML Colors или в переводной статье о теории цвета на Хабре.
http://www.w3schools.com/html/html_colors.asp


Вот пример использования свойства:

selector{
    background-color:#FF0000;
}
----------------------------



Свойство background-image [2/16]

Фоновое изображение можно задать с помощью CSS-свойства background-image. Делается это так:

selector{
    background-image:url('адрес-картинки');
}

Адрес картинки обязательно заключается внутрь url('...'). Адреса фоновых картинок такие же, как и адреса обычных картинок, которые вы задавали в курсе про ссылки и изображения.

Элементу можно одновременно задавать и цвет фона, и фоновую картинку. В этом случае картинка будет отображаться поверх фонового цвета.

В этом курсе мы в качестве подопытных картинок будем использовать отличные иконки из Хабрапоста Работа в перерывах от работы. Если знаете автора, передайте ему огромное спасибо.
Сами иконки вот: http://iconka.com/downloads/cat-power/

----------------------------------------


Свойство background-repeat [3/16]

По умолчанию фоновое изображение повторяется. Это хорошо заметно, когда оно меньше блока. Управлять этим поведением можно с помощью CSS-свойства background-repeat. У свойства 4 значения:

    repeat — повторять во всех направлениях. Это значение по умолчанию.
    repeat-x — повторять только по горизонтали.
    repeat-y — повторять только по вертикали.
    no-repeat — не повторять.
-----------------------------
Задание

Задайте блокам режим повторения фона:

    по горизонтали — 1 блоку.
    по вертикали — 2 блоку.
    не повторять — 3 блоку.
    во все стороны — 4 блоку.
------------------------------------
.block1{
    background-color:#2ecc71;
    background-image:url('/assets/course13/cat_box.png');
    background-repeat: repeat-x;
    
}
.block2{
    background-color:#3498db;
    background-image:url('/assets/course13/cat_fish.png');
    background-repeat: repeat-y;
    
}
.block3{
    background-color:#e74c3c;
    background-image:url('/assets/course13/cat_drunk.png');
    background-repeat: no-repeat;
    
}
.block4{
    background-color:#e67e22;
    background-image:url('/assets/course13/cat_tied.png');
    background-repeat:repeat;
}-----------------------------------





Свойство background-position [4/16]

Cвойство background-position управляет расположением фонового изображения. Значение свойства состоит из двух частей, разделенных пробелом: x y.

x задаёт расположение по горизонтали, а y по вертикали.

В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.

В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях.

Примеры использования свойства:

background-position:50% 50%;
// далее только значения
right bottom;
50px 100px;
0 100%;
left bottom;

Так сработают примеры:

    картинка будет по центру;
    правый нижний угол;
    отступ 50px от левого края и 100px от верхнего;
    левый нижний угол;
    левый нижний угол.
---------------------------------
Задание

Задайте блокам расположение фона:

    50% 50% — 1 блоку.
    100% 0 — 2 блоку.
    0 100% — 3 блоку.
    100% 100% — 4 блоку.
--------------------------------------
.block1{
    background-color:#2ecc71;
    background-image:url('/assets/course13/cat_box.png');
    background-repeat:no-repeat;
    background-position:50% 50%;
    
}
.block2{
    background-color:#3498db;
    background-image:url('/assets/course13/cat_fish.png');
    background-repeat:no-repeat;
    background-position:100% 0;
    
}
.block3{
    background-color:#e74c3c;
    background-image:url('/assets/course13/cat_drunk.png');
    background-repeat:no-repeat;
    background-position:0 100%;
    
}
.block4{
    background-color:#e67e22;
    background-image:url('/assets/course13/cat_tied.png');
    background-repeat:no-repeat;
    background-position:100% 100%;
    
}-------------------------------------





Ещё немного background-position [5/16]

Когда фоновое изображение больше блока, то оно обрезается. Управлять тем, какую часть изображения будет видно, также можно с помощью свойства background-position.

Иногда для этого удобно использовать относительные значения (проценты), а иногда абсолютные (пиксели).

Кстати, можно использовать не только положительные, но и отрицательные значения. А также комбинировать пиксели и проценты.
------------------------------------
Задайте блокам расположение фона:

    35px 25px — 1 блоку.
    -95px 25px — 2 блоку.
    -45px 50% — 3 блоку.
    100% 50% — 4 блоку.
----------------------------------
body{    
    font-family:Tahoma, sans-serif;
    padding:0;
    padding-top:20px;
    margin:0; 
    text-align:center;
}
.block{
    display:inline-block;
    width:120px;
    height:120px;
    margin:5px;
    background-image:url('/assets/course13/logo.png');
    background-repeat:no-repeat;
    border-radius:5px;
    box-shadow:1px 1px 3px #999;
    background-color:#34495e;
}
.block1{
    background-position: 35px 25px;
    

}
.block2{
    background-position: -95px 25px;
    

}
.block3{
    background-position: -45px 50%;
    

}
.block4{
    background-position: 100% 50%;

}-------------------------------------




Свойство background-attachment [6/16]

Обычно фоновое изображение прокручивается вместе с содержимым блока. Это хорошо видно в мини-браузере. Прокрутите окно вниз и увидите, что фон поднимется наверх.

С помощью свойства background-attachment можно зафиксировать фон на месте и он не будет перемещаться при прокручивании.

Значение свойства:

    scroll — фон прокручивается вместе с содержимым. Это значение по умолчанию.
    fixed — фон не прокручивается, зафиксирован на одном месте.

Это тот случай, когда легче показать, чем объяснять: выполняйте задание и смотрите, как изменяется поведение фона при прокрутке.
--------------------------
Задание

Задайте для body «неподвижный» режим фонового изображения.
Цели задания:

    «неподвижный» режим задан
----------------------------------
body{    
    padding:0;
    margin:0; 
    background-image:url('/assets/course13/moon.jpg');
    background-position:50% 50%;
    background-repeat:no-repeat;
    background-attachment:fixed;
    
    
}
.block{
    width:128px;
    height:128px;
    margin:20px auto;
    border-radius:5px;
    background-color:#34495e;
    background-repeat:no-repeat;
    background-position:50% 50%;
}
.block:nth-child(1){
    background-image:url('/assets/course13/cat_clean.png');
}
.block:nth-child(2){
    background-image:url('/assets/course13/cat_fight.png');
}
.block:nth-child(3){
    background-image:url('/assets/course13/cat_hiss.png');
}
.block:nth-child(4){
    background-image:url('/assets/course13/cat_poo.png');
}-------------------------------------




Свойство background [7/16]

Фон элемента можно задавать с помощью отдельных свойств: background-color, background-image и т.д. Получается довольно громоздкая запись.

Также задать фон можно с помощью сокращенного свойства background, в котором через пробел перечисляются его компоненты:

background:[bc] [bi] [br] [bp] [ba];
/* Обозначения:
[bc] — background-color
[bi] — background-image
[br] — background-repeat
[bp] — background-position
[ba] — background-attachment
*/

Если какой-то компонент не указан, то берется значение по умолчанию. Ниже примеры.

background:#e74c3c;
background:url('img.png') no-repeat;
background:url('img.png') 10px 20px;

В первом примере просто задан цвет фона.

Во втором примере задано не повторяющееся фоновое изображение, а также по умолчанию прозрачный цвет фона, расположение в левом верхнем углу.

В третьем примере задано фоновое изображение и его расположение, а также по умолчанию прозрачный цвет фона и режим повторения во все стороны.
----------------------------------------
Задание

Задайте блокам фон:

    Цвет фона #e74c3c, фоновая картинка /assets/course13/cat_eyes.png — 1 блоку.
    Цвет фона #2980b9, фоновая картинка /assets/course13/cat_fish.png — 2 блоку.

У обоих блоков фоновая картинка не должна повторяться и быть смещена на 10px слева и 5px сверху.
-------------------------------------
.block1{
    background: #e74c3c url('/assets/course13/cat_eyes.png') no-repeat 10px 5px; 
    

}
.block2{
    background: #2980b9 url('/assets/course13/cat_fish.png') no-repeat 10px 5px; 

}---------------------------------------





Формат JPEG [9/16]

В последующих нескольких заданиях мы рассмотрим наиболее распространенные форматы изображений для веб. И разберемся, где и как их лучше использовать при вёрстке.

Первый формат — JPEG. Этот формат хорошо подходит для фотографий и картин и плохо подходит для схем, чертежей, текста и графики.

При сохранении изображения в формат JPEG можно задавать уровень качества. Это позволяет добиваться снижения веса файла при достаточно хорошем качестве изображения.

Однако, если установить уровень качества слишком низким, то появятся артефакты.

JPEG не поддерживает прозрачность, поэтому изображение в формате JPEG — это всегда прямоугольник. Можно имитировать прозрачность, если в графическом редакторе задать изображению такой же цвет фона, как и у контейнера фотографии.

Используйте JPEG для размещения фото с наилучшим соотношением «размер файла»/«качество».
---------------------------------
Задание

Сначала задайте элементам с классом block фоновое изображение /assets/course13/cat_cage.jpg.

Затем задайте им же другое изображение более низкого качества /assets/course13/cat_cage_low.jpg.
------------------------------------
.block{
    height:90px;
    background-repeat:no-repeat;
    background-position: 50% 50%;
    background: url('/assets/course13/cat_cage_low.jpg') no-repeat 50% 50%;
}-----------------------------------





Формат PNG-8 [10/16]

На самом деле, формат PNG один. А PNG-8 и PNG-24 это его подтипы, а также режимы сохранения в Photoshop. Мы не будем глубоко вдаваться в детали, а разберем типовые особенности.

PNG-8 по характеристикам схож с форматом GIF. Он хорошо походит для схем, чертежей, графиков и текста, а также изображений, где мало цветов. Максимальное количество цветов — 256.

PNG-8, как и GIF, поддерживает прозрачность. Это означает, что пиксель либо полностью прозрачный, либо полностью непрозрачный.

Если нужно сделать изображение с прозрачностью, то лучше задавать обводку такую же, как цвет фона. В фотошопе при сохранении обводка называется «Mate». Без обводки картинка будет выглядеть «обкусанной». Если фон неоднородный (градиент, 3 блок в мини-браузере), то PNG-8 с обводкой будет смотреться плохо.

Чем PNG лучше GIF? PNG более современный и свободный формат, а GIF более старый и проприетарный (за его использование могут потребовать деньги). Уровень сжатия, качество и другие характеристики примерно одинаковые, поэтому лучше всегда использовать PNG.
------------------------------------------
Задание

Задайте элементам с классом block фоновое изображение /assets/course13/cat_cage_8.png.

Затем задайте им же другое изображение без обводки /assets/course13/cat_cage_8_no_mate.png.
------------------------------------------
.block{
    height:90px;
    background-repeat:no-repeat;
    background-position: 50% 50%;
    background:url('/assets/course13/cat_cage_8_no_mate.png') no-repeat 50% 50%; ----------------- без обводки контуры не четкие
}----------------------------------------------------




Формат PNG-24 [11/16]

PNG-24 — отличнейший формат. Он хорошо подходит и для схем-чертежей-графиков-текста, и для сложных многоцветных изображений, т.к. поддерживает практически неограниченное количество цветов.

На фотографиях обычно он уступает JPEG по размеру файла, но превосходит по качеству изображения. Но иногда разница по размеру файла настолько некритична, что можно использовать PNG.

Самый главный плюс PNG-24 — это полноценная поддержка полупрозрачности, которой нет ни в одном другом формате. Поэтому в веб-разработке при вёрстке сложных фонов, графических элементов со сложными тенями и так далее альтернативы PNG-24 просто нет.

Давным-давно в IE была проблема с поддержкой полупрозрачных PNG, но в более поздних версиях IE (8+), таких проблем нет.

Сравните котика-PNG-8 с обводкой из предыдущего задания и котика-PNG-24 из этого задания. Особенно то, как выглядят их края на желтом блоке и блоке с градиентом.

Некоторые верстальщики перестают использовать PNG-8 и используют только PNG-24.
-----------------------------------
Задание

Задайте элементам с классом block фоновое изображение /assets/course13/cat_cage.png
------------------------------------
<!DOCTYPE html>
<html>
    <head>
       <title>Формат PNG-24</title>
       <meta charset="utf-8">
    </head>
    <body>
        <div class="box box1">
            <div class="block"></div>
        </div>
        <div class="box box2">
            <div class="block"></div>
        </div>
        <div class="box box3">
            <div class="block"></div>
        </div>
    </body>
</html>
-----------------------------------------
.box{
    width:192px;
    height:90px;
    margin:10px auto;
    box-shadow:1px 1px 3px #999;
}
.box1{
    background-color:#2ecc71;
}
.box2{
    background-color:#f1c40f;
}
.box3{
    background:url('/assets/course13/gradient.jpg') no-repeat 50% 50%;
}
.block{
    height:90px;
    background-repeat:no-repeat;
    background-position: 50% 50%;
    background:url('/assets/course13/cat_cage.png') no-repeat 50% 50%;
}----------------------------------------




Формат GIF [12/16]

Наверное, единственная причина использовать GIF заключается в том, что он поддерживает анимированные изображения.

Во всех остальных случаях используйте PNG или JPEG (если речь идёт о фотографиях и PNG даёт слишком тяжёлый файл).
---------------------------------------
Задание

Задайте блокам фоновые картинки:

    /assets/course13/cat_purr.gif — 1 блоку.
    /assets/course13/cat_walk.gif — 2 блоку.
----------------------------------------
.block1{
    /* первый блок */
    background: url('/assets/course13/cat_purr.gif') no-repeat 50% 50%;
}
.block2{
    /* второй блок */
    background: url('/assets/course13/cat_walk.gif') no-repeat 50% 50%;
}-------------------------------------




Несколько фонов [13/16]

Несколько фонов одному элементу можно задать с помощью множественных фонов. Это достаточно новая возможность CSS3, и мы рассмотрим её в продвинутых курсах.

А сейчас рассмотрим старую надёжную технику создания нескольких фонов.

Суть техники заключается в том, что мы вкладываем элементы друг в друга и делаем их одинакового размера, а затем каждому элементу задаём свой фон. Т.е. каждый элемент служит одним слоем фона.

Фоны вложенных элементов перекрывают друг друга: чем глубже элемент, тем выше его фон.

Кстати, для удобства ширину лучше задавать внешнему элементу (т.к. все вложенные будут той же ширины), а высоту самому глубокому, т.к. он растянет по высоте всех своих родителей.
----------------------------------------------
Задание

Соберём миниатюру «Кот на ферме». Задайте фоновые картинки:

    /assets/course13/cows.jpg — 1 блоку.
    /assets/course13/cat_walk.png — 2 блоку.
    /assets/course13/fence.png — 3 блоку.

Картинки в фоне не должны повторяться. У второго блока позиция фона 190px 195px, у остальных по умолчанию.
------------------------------------------------
.block1{
    width:256px;
    margin:0 auto;
    box-shadow:1px 1px 3px #999;
    background: url('/assets/course13/cows.jpg') no-repeat;
}

.block2{
    background: url('/assets/course13/cat_walk.png') no-repeat 190px 195px;
    
}

.block3{
    height:256px;
    background: url('/assets/course13/fence.png') no-repeat;
}--------------------------------------





Эффекты с повторяющимся фоном [14/16]

Повторяющийся фон, тот у которого repeat, repeat-x или repeat-y, часто используется для создания интересных декоративных эффектов.

Например:

    стежки;
    зазубренные края;
    градиенты и тени.

Да, сейчас уже градиенты и тени можно делать с помощью CSS. Но иногда, когда тень или градиент достаточно сложные, проще использовать полупрозрачный PNG.

Самое главное при создании таких эффектов — выбрать картинку с нужным периодом. Она может быть очень маленькой и даст существенную экономию веса страницы.

Попрактикуемся. Только, пожалуйста, изменяйте режим повторения после того, как пропишете фоновые изображения. Так будет нагляднее.
---------------------------------------
Задание

Задайте фоновые картинки:

    /assets/course13/stitch.png — 1 блоку.
    /assets/course13/zigzag.png — 2 блоку.
    /assets/course13/shadow.png — 3 блоку.

Затем задайте всем блокам repeat-x.
-------------------------------------------
.block1{
    background-position:-30px 30px;
    background:url('/assets/course13/stitch.png') repeat-x;
    
}
.block2{
    background-position:0 0;
    background:url('/assets/course13/zigzag.png') repeat-x;
    
}
.block3{
    background-position:0 100%;
    background:url('/assets/course13/shadow.png') repeat-x;
-----------------------------------------------





Спрайты [15/16]

Спрайт — это одно большое изображение, в котором содержится много маленьких, как бы карта изображений. Вот живой пример (эта же картинка выведена на тёмном фоне внизу мини-браузера), который мы будем использовать в задании.

Спрайты используются, чтобы снизить количество запросов на сервер. Каждая маленькая картинка — это отдельный запрос, а чем меньше запросов, тем лучше. Поэтому маленькие картинки «склеивают» в одну большую.

Части спрайта отображают в элементах с небольшими размерами. Такому элементу задают картинку-спрайт в качестве фона и смещают её таким образом, чтобы была видна нужная её часть.

В спрайты обычно объединяют иконки и различные мелкие декоративные изображения. Кстати, есть сервисы для быстрого создания спрайтов и генерации CSS-кода для них, например, SpritePad.
-----------------------------------------
Задание

Задайте расположение фона:

    -408px -96px — элементу с классом icon-add.
    -96px -72px — элементу с классом icon-edit.
    -456px 0 — элементу с классом icon-remove.
--------------------------------------
<!DOCTYPE html>
<html>
    <head>
       <title>Спрайты</title>
       <meta charset="utf-8">
    </head>
    <body>
        <span class="btn btn-add">
            <i class="icon icon-add"></i>
            Добавить
        </span>
        <span class="btn btn-edit">
            <i class="icon icon-edit"></i>
            Редактировать
        </span>
        <span class="btn btn-remove">
            <i class="icon icon-remove"></i>
            Удалить
        </span>
        <!-- Картинка спрайта на тёмном фоне -->
        <div class="full-sprite"></div>
    </body>
</html>
------------------------------------------
body{    
    font-family:Tahoma, sans-serif;
    padding:0;
    padding-top:10px;
    margin:0; 
}
.btn{
    display:block;
    width:110px;
    margin:20px auto;
    padding:7px 12px;
    background:#34495e;
    border-radius:5px;
    font-size:13px;
    line-height:20px;
    color:white;
    cursor:pointer;
}
.btn-add{
    background:#27ae60;
}
.btn-remove{
    background:#c0392b;
}
.icon{
    display:inline-block;
    width:14px;
    height:14px;
    margin-right:2px;
    vertical-align:text-top;
    background:url('/assets/course13/bootstrap-sprites.png') no-repeat;
}
.icon-add{
    background-position: -95px -96px;
}
.icon-edit{
    background-position: -96px -72px;
}
.icon-remove{
    background-posinion: -456px 0;
}
.full-sprite{
    height:140px;
    background:#34495e url('/assets/course13/bootstrap-sprites.png') no-repeat 0 50%;
}------------------------------------------






Оформляем пункты, простой вариант [5/28]

Простейший способ оформить пункты меню — добавить между ними отступы и задать стили ссылок.

Хорошим тоном считается задавать стили ссылок для всех состояний: по умолчанию, посещенная, при наведении и щелчке. Но для этого дизайнер должен продумать и отрисовать все состояния ссылок.

Мы пойдем простейшим путем и зададим одинаковый цвет ссылок для всех состояний (всё-таки мы только тренируемся).

Обратите внимание на способ написания селекторов. Мы используем контекстные селекторы. Перед каждым CSS-правилом, относящимся к меню, мы пишем класс меню. Такой способ называется созданием пространства имен. Он позволяет эффективно отделять друг от друга стили, относящиеся к разным блокам.
Что повторить:

    Псевдоклассы :link, :visited и :active
    Контекстные селекторы
-------------------------------------
Задание

    Задайте элементам списка внешний отступ снизу 8px.
    Задайте ссылкам цвет #0088CC.
-----------------------------------------
<body>
    
        <ul class="main-menu">
        
            <li><a href="#company">О компании</a></li>
            <li><a href="#services">Услуги</a></li>
            <li><a href="#team">Сотрудники</a></li>
            <li><a href="#contacts">Контакты</a></li>
        </ul>
        
    </body>
---------------------------------
.main-menu li{
    margin-bottom: 8px;
}

.main-menu a{
    color: #0088CC;
}--------------------------------





Добавляем разделители [7/28]

Теперь нужно убрать рамки и фон у контейнера. Можно просто удалить эти свойства, либо задать им значение none.

Затем добавим рамки ссылкам. А чтобы не возникало двойных рамок на стыке ссылок, добавим им отрицательный внешний отступ снизу, такой же ширины, что и рамки.

И последний штрих. Уберем подчеркивание у ссылок, так как появились разделители и от обилия горизонтальных линий рябит в глазах.
Что повторить:

    Свойство text-decoration: подчеркивание и другие эффекты
--------------------------------------
Задание

    Убрать фон и рамки у списка.
    Добавить ссылкам сплошную рамку шириной 1px цвета #E5E5E5.
    Добавить ссылкам отрицательный внешний отступ снизу -1px.
    Убрать подчеркивание у ссылок.
---------------------------------------
.main-menu{
    width:180px;
    padding:0;
    margin:0;
    list-style:none;
    border:none; 
    background:none;
}

.main-menu a{
    display:block;
    padding:8px 14px;
    color:#0088CC;
    border: 1px solid #E5E5E5;
    margin: -1px;
    text-decoration: none;
}---------------------------------------




Оформляем состояния пунктов [8/28]

Пункт меню может находиться в трёх состояниях:

    спокойное состояние;
    наведён курсор мыши;
    активное состояние — открыта страница, которой соответсвует этот пункт.

Хорошим тоном считается задавать стили для этих состояний.

С помощью псевдокласса :hover задают стили при наведении курсора мыши. Для активного состояния создают дополнительный класс, который добавляют активному пункту.

Добавим стили для состояний. Будем считать, что мы находимся на странице Услуги.
Что повторить:

    Псевдокласс :hover
----------------------------
Задание

    Добавьте класс active ко второму элементу списка.
    Переопределите для ссылок внутри элемента с классом active цвет на white и фон на #0088CC.
    Задайте фон #F5F5F5 при наведении на ссылку и наведите курсор на неактивные пункты меню.
---------------------------
 <body>
        <ul class="main-menu">
            <li><a href="#company">О компании</a></li>
            <li class="active"> <a href="#services">Услуги</a></li>
            <li><a href="#team">Сотрудники</a></li>
            <li><a href="#contacts">Контакты</a></li>
        </ul>
    </body>
---------------------------
.main-menu a{
    display:block;
    padding:8px 14px;
    margin-bottom:-1px;
    color:#0088CC;
    text-decoration:none;
    border:1px solid #E5E5E5;
}
.main-menu a:hover{
    background: #F5F5F5;
}
/* ссылка в меню, внутри элемента с классом .active */
.main-menu .active a{
        color: white;
        background: #0088CC;
}
.main-menu{
    width:180px;
    padding:0;
    margin:0;
    list-style:none;
}
body{
    font-family:Arial, sans-serif;
    font-size:14px;
    line-height:1.4;
    padding:10px;
}
-------------------------------------





Переносим рамки, задаем отступы подменю [12/28]

Мы оставим рамки только для пунктов меню верхнего уровня.

Чтобы сделать это, нужно убрать рамки у ссылок и задать их для элементов списка. Также отрицательный отступ снизу уберем у ссылок и добавим элементам списка.

Используем для этого дочерний селектор .main-menu>li.

Также на этом этапе мы добавим отступы для контейнера подменю, т.е. для тэга ul.
------------------------------
<body>
    
        <ul class="main-menu">
            <li><a href="#company">О компании</a></li>
            <li class="active">
                <a href="#services">Услуги</a>
                
                <ul>
                    <li><a href="#s1">Разработка</a></li>
                    <li><a href="#s2">Продвижение</a></li>
                    <li><a href="#s3">Контекст</a>
                </ul>
                
            </li>
            <li><a href="#team">Сотрудники</a></li>
            <li><a href="#contacts">Контакты</a></li>
        </ul>
        
    </body>
---------------------------
Задание

    Уберите рамки и отступ снизу у ссылок и добавьте его элементам списка верхнего уровня.
    Задайте подменю внутренние отступы: 5px сверху и снизу, 30px слева и нулевой справа.
---------------------------
.main-menu{
    width:180px;
    padding:0;
    margin:0;
    list-style:none;
}

.main-menu>li{  ------------------------>>
    border:1px solid #E5E5E5;
    margin-bottom:-1px;
}   

.main-menu a{
    display:block;
    padding:8px 14px;
    color:#0088CC;
    text-decoration:none;
}

.main-menu a:hover{
    background:#F5F5F5;
}

.main-menu>.active>a{ ------------------>>
    color:white;
    background:#0088CC;
}
    
.main-menu ul{ --------------------->>
    padding:5px 0px 5px 30px;
    margin:0;
    list-style:none;
    
    
}
body{
    font-family:Arial, sans-serif;
    font-size:14px;
    line-height:1.4;
    padding:10px;
}-----------------------------------------





Оформляем пункты подменю [13/28]
Внимание! Проверка при наведении не срабатывает в Chrome - это его неприятный глюк. Но задание можно выполнить в Firefox или другом современном браузере.

Теперь оформим пункты подменю. Оформление будет отличаться от пунктов верхнего уровня и будет максимально простым.

С помощью какого селектора задавать стили для пунктов подменю?

Для этого можно использовать сложный контекстный селектор. Например, такой:
.main-menu li li a.
Он выберет только те ссылки, которые лежат внутри двух и более элементов списка, т.е. ссылки на втором уровне и ниже.

Также мы изменим поведение при наведении для подпунктов. Селектор будет очень похож на предыдущий:
.main-menu li li a:hover.
-------------------------------
<body>
        <ul class="main-menu">
            <li><a href="#company">О компании</a></li>
            <li class="active">
                <a href="#services">Услуги</a>
                <ul>
                    <li><a href="#s1">Разработка</a></li>
                    <li><a href="#s2">Продвижение</a></li>
                    <li><a href="#s3">Контекст</a>
                </ul>
            </li>
            <li><a href="#team">Сотрудники</a></li>
            <li><a href="#contacts">Контакты</a></li>
        </ul>
    </body>
----------------------------
Задание

    Задайте ссылкам подменю черный black цвет, внутренние отступы 3px вертикальные и 0px горизонтальные.
    Сделайте, чтобы у ссылок подменю при наведении не было фона background:none и появлялось подчеркивание.
    Наведите курсор на ссылки подменю.
--------------------------
.main-menu{
    width:180px;
    padding:0;
    margin:0;
    list-style:none;
}
.main-menu>li{
    border:1px solid #E5E5E5;
    margin-bottom:-1px;
}    
.main-menu a{
    display:block;
    padding:8px 14px;
    color:#0088CC;
    text-decoration:none;
}
.main-menu a:hover{
    background:#F5F5F5;
}
.main-menu>.active>a{
    color:white;
    background:#0088CC;
}
.main-menu ul{
    padding:5px 0 5px 30px;
    margin:0;
    list-style:none;
}

.main-menu li li a{
    color:black;
    padding: 3px 0;
}

.main-menu li li a:hover{
    background:none;
    text-decoration: underline; 
}

body{
    font-family:Arial, sans-serif;
    font-size:14px;
    line-height:1.4;
    padding:10px;
}




Горизонтальное меню [16/28]

Теперь из того же самого списка создадим горизонтальное меню.

Начнем с этапа, когда HTML-код уже размечен и заданы стили для контейнера. Теперь нужно преобразовать вертикальный список в горизонтальное меню.

Простейший способ сделать это — задать элементам списка строчный тип. Тогда они автоматически расположатся в одну строку. Также добавим им небольшой отступ справа.

Кстати, мы не задали ширину контейнеру, т.к. обычно горизонтальные меню занимают всю ширину макета.
Что повторить:

    Управление типом элемента, свойство display
-----------------------------------
<body>
        <ul class="main-menu">
            <li><a href="#company">О компании</a></li>
            <li><a href="#services">Услуги</a></li>
            <li><a href="#team">Сотрудники</a></li>
            <li><a href="#contacts">Контакты</a></li>
        </ul>
    </body>
---------------------------------------
Задание

    Сделайте элементы списка строчными.
    Добавьте элементам списка отступ справа 5px.
---------------------------------------
.main-menu{
    padding:10px 15px;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;    
    background:#f5f5f5;
}
.main-menu li{
    display:inline;
    margin-right: 5px;
}

.main-menu a{
    color:#0088CC;
}
body{
    font-family:Arial, sans-serif;
    font-size:14px;
    line-height:1.4;
    padding:10px;
}-------------------------------------------




Что делать, если пункты не влезают? [17/28]

У горизонтальных меню есть одна неприятная особенность. Иногда все пункты меню не влезают в одну строку. Как решить эту проблему?

На самом деле никак. Всегда может возникнуть ситуация, когда что-то не влезло, её не избежать. Но предусматривать такую ситуацию надо.

Главное правило — ссылки в меню должны быть доступны и видимы при любых обстоятельствах. Пусть они переносятся на другую строку и меню выглядит не так красиво, но главное, что ссылки видны.

Мы можем только уменьшить вред от этого эффекта. Например, сделать так, чтобы пункты меню переносились на новую строку целиком, запретив переносы текста внутри них.
Что повторить:

    Управляем пробелами: white-space
----------------------------------
<body>
        <ul class="main-menu">
            <li><a href="#company">О нашей компании</a></li>
            <li><a href="#services">Наши вам услуги</a></li>
            <li><a href="#team">Все наши сотрудники</a></li>
            <li><a href="#contacts">Наши контакты</a></li>
        </ul>
    </body>
--------------------
Задание

Запретите перенос строки внутри пунктов меню.
Цели задания:

    перенос строки запрещен
-------------------------------
    padding:10px 15px;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;    
    background:#f5f5f5;
}

.main-menu li{
    display:inline;
    margin-right:5px;
    white-space:nowrap; ---------------------------->  без переноса пробелов
}

.main-menu a{
    color:#0088CC;
}---------------------------
******************************************
Однако, с помощью css управлять пробелами и переносами можно более гибко. За это отвечает свойство white-space, значения которого:

    nowrap — отображает весь текст одной строкой без переносов;
    pre — сохраняет пробелы и переносы как в исходном коде аналогично тэгу <pre>;
    pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;
    normal — режим по умолчанию.
--------------------------------------------




Усложненное оформление пунктов [18/28]

Теперь давайте усложним оформление. Сделаем пункты более объемными и добавим разделители по аналогии с вертикальным меню.

Для начала избавимся от фона и отступов у списка. А рамку у списка оставим, т.к. в горизонтальном меню пункты не всегда занимают всю ширину или влезают на одну строку.

Чтобы расположить пункты в одну строку и иметь возможность задавать им отступы и размеры, зададим блочно-строчный тип элементам списка.

А ссылкам внутри элементов списка зададим блочный тип и добавим отступы.
Что повторить:

    display: inline-block
-------------------------------------
Задание

    Уберите фон и внутренние отступы у списка.
    Сделайте элементы списка блочно-строчными.
    Сделайте ссылки блочными и задайте им внутренние отступы, 8px вертикальные и 10px горизонтальные.
------------------------------------------
.main-menu{
    padding:0px 0px;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;
    background:none;
}
.main-menu li{
    display:inline-block;
    margin-right:5px;
        
}
.main-menu a{
    color:#0088CC;
    display:block;
    padding: 8px 10px;
}
body{
    font-family:Arial, sans-serif;
    font-size:14px;
    line-height:1.4;
    padding:10px;
    min-width:300px;
}--------------------------------------




Завершаем оформление пунктов [19/28]

На этом шаге мы добавим рамки, избавимся от лишних отступов и оформим состояния меню.

Так как отступы мы задали ссылкам, то и рамки добавим им же. Причем нам нужно задать только рамки слева, а чтобы не было двойной рамки у самого первого пункта, добавим отрицательный внешний отступ слева.

Обнулим отступ после элементов списка, но этого недостаточно, так как пробелы после блочно-строчных элементов добавляют небольшой отступ. Чтобы от него избавиться, зададим отрицательный внешний отступ справа элементам списка.

Затем оформим состояние ссылки при наведении (добавим фон). При желании можете поэкспериментировать с оформлением активного пункта меню.
---------------------------------
Задание

Задайте следующие свойства:

    Ссылкам сплошную рамку слева в 1px цветом #E5E5E5 и маргин слева -1px.
    Элементу списка маргин справа -4px.
    Ссылкам при наведении фон #F5F5F5 и наведите на них мышь.
------------------------------------
.main-menu{
    padding:0;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;
    margin-left:-1px;
}
.main-menu li{
    display:inline-block;
    margin-right:5px;
    margin-right: -4px;
    
}
.main-menu a{
    display:block;
    padding:8px 10px;
    color:#0088CC;
    margin-left:-1px;
    border-left:1px solid #E5E5E5;
}
.main-menu a:hover{
    background: #F5F5F5;
}--------------------------------





Точка отсчета координат [14/20]

По умолчанию «абсолютные» элементы позиционируются в системе координат, привязанной к окну браузера. Однако, систему координат можно изменить.

Если какой-нибудь из родителей «абсолютного» элемента имеет относительное позиционирование, то элемент будет позиционироваться относительно этого родителя. Если среди родителей несколько относительно позиционированных элементов, то «абсолютный» элемент будет позиционироваться относительно ближайшего из них.

В этом задании вы увидите, как происходит смена системы координат (и соответственно точек отсчета). Интересно, что позиционирование по умолчанию отличается от позиционирования внутри тэга body.



Тренируемся задавать координаты [15/20]

В этом задании вы потренируетесь в позиционировании. Задача заключается в том, чтобы с помощью свойств left, top, right и bottom расположить красный квадрат в каждом из четырех углов синего прямоугольника.

Синие прямоугольники спозиционированы относительно, поэтому у каждого красного квадрата своя система координат.




z-index или кто кого перекроет [19/20]

Если в одном месте страницы оказываются несколько «абсолютных» блоков, то они перекрывают друг друга. По умолчанию выше оказывается тот блок, который расположен дальше в коде страницы.

C помощью CSS-свойства z-index можно управлять тем, как перекрываются блоки. Значением этого свойства может быть целое число. Чем больше z-index, тем выше располагается блок.

Cвойство z-index работает для элементов, у которых position задано как absolute, fixed и relative. Таким образом, «относительный» элемент может перекрывать «абсолютный».
---------------------------------------------




Позиционируем выпадающее подменю [22/28]

Затем выпадающее подменю располагают в том месте, куда оно будет «выпадать». Лучше располагать так, чтобы оно немного «нависало» над родительским пунктом.

Также нужно установить для подменю z-index больше, чем у родительских пунктов, чтобы подменю располагалось выше и перекрывало их при появлении.

Так как абсолютное позиционирование сбрасывает ширину, то можно установить ширину для подменю.
Что повторить:

    Точка отсчета координат
    Тренируемся задавать координаты
    z-index или кто кого перекроет
----------------------------------------
Задание

    Задайте подменю координату сверху 5px, координату слева 170px.
    Свойство z-index со значением 10.
    А также ширину 150px.
----------------------------------------
.main-menu a{
    display:block;
    padding:8px 14px;
    margin-bottom:-1px;
    color:#0088CC;
    text-decoration:none;
    border:1px solid #E5E5E5;
}
.main-menu a:hover{
    background:#F5F5F5;
}
.main-menu>li{
    position:relative;
}
.main-menu .sub-menu{
    position:absolute;
    padding:0;
    margin:0;
    list-style:none;
    background:#FCF8E3;
    top:5px;
    left:170px;
    z-index:10;
    width:150px;    
}-----------------------------------------



Отображаем подменю при наведении [23/28]

Последний этап — добавление интерактивности.

Сначала прячем выпадающее подменю по умолчанию, с помощью display:none;.

Затем делаем так, чтобы при наведении мыши на пункт меню, внутри которого расположено подменю, оно появлялось. Для этого используем контекстный селектор в сочетании с псевдоклассом :hover и display:block;.
Что повторить:

    display: none
    Динамические эффекты с помощью :hover
------------------------------------------
Задание

    Спрячьте подменю по умолчанию.
    Сделайте так, чтобы оно появлялось при наведении на родительский элемент списка.
    Наведите мышь на второй пункт, чтобы подменю появилось.
----------------------------------------
.main-menu{
    width:180px;
    padding:0;
    margin:0;
    list-style:none;
}
.main-menu a{
    display:block;
    padding:8px 14px;
    margin-bottom:-1px;
    color:#0088CC;
    text-decoration:none;
    border:1px solid #E5E5E5;
}
.main-menu a:hover{
    background:#F5F5F5;
}
.main-menu>li{
    position:relative;
}
.main-menu .sub-menu{ ------------------------ тут этого блока не видно
    position:absolute;
    top:5px;
    left:170px;
    z-index:10;
    width:150px;
    padding:0;
    margin:0;
    list-style:none;
    background:#FCF8E3;
    display:none;
}


/* селектор для подменю, если навести мышь */ ----------------------------- тут блок появляется при наведении на родителя 
/* на родительский элемент верхнего меню */
.main-menu>li:hover .sub-menu{
    display:block;
}





Горизонтальное меню с выпадающим подменю [24/28]

Теперь построим горизонтальное меню, у которого будут вертикальные выпадающие подменю.

Разметка стандартная — двухуровневый список.

Алгоритм оформления почти такой же, как и в предыдущем случае. Сначала задаем режимы позиционирования, затем стили для подменю, затем механизм выпадания.

Так как мы хотим, чтобы выпадающее меню было вертикальным, то надо изменить селектор .main-menu li на .main-menu>li, чтобы блочно-строчными были только элементы списка верхнего уровня.
--------------------------------------
Задание

    Замените селектор .main-menu li на .main-menu>li.
    Задайте относительное позиционирование элементам списка верхнего уровня.
    Задайте абсолютное позиционирование подменю.
--------------------------------------
.main-menu>li{
    display:inline-block;
    margin-right:-4px;
    position:relative;
}
.main-menu a{
    display:block;
    padding:8px 10px;
    margin-left:-1px;
    color:#0088CC;
    border-left:1px solid #E5E5E5;    
}
.main-menu a:hover{
    background:#f5f5f5;
}
.main-menu .sub-menu{
    padding:0;
    margin:0;
    list-style:none;
    background:#FCF8E3;
    position:absolute;
}--------------------------------------





Оформляем выпадающее меню [25/28]

Оформим выпадающее меню.

Во-первых, зададим ширину для подменю. Во-вторых, зададим координаты. Сейчас подменю уже располагается хорошо, поэтому верхнюю координату трогать не будем, а зададим только координату слева.

Пункты подменю тоже оформим очень просто. Во-первых, зададим для ссылок рамку со всех сторон, а не только слева. И, во-вторых, добавим отрицательный отступ снизу, чтобы не было двойных рамок.
-------------------------------------
Задание

    Задайте для подменю ширину 150px и координату слева 1px.
    Задайте для ссылок в подменю сплошную рамку шириной 1px цветом #E5E5E5.
    Задайте для ссылок в подменю отрицательный внешний отступ снизу -1px.
--------------------------------------
.main-menu{
    padding:0;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;
}
.main-menu>li{
    position:relative;
    display:inline-block;
    margin-right:-4px;
}
.main-menu a{
    display:block;
    padding:8px 10px;
    margin-left:-1px;
    color:#0088CC;
    border-left:1px solid #E5E5E5;
}
.main-menu a:hover{
    background:#f5f5f5;
}
.main-menu .sub-menu{
    position:absolute;
    padding:0;
    margin:0;
    list-style:none;
    background:#FCF8E3;
    width: 150px;
    left:1px;
}

.main-menu .sub-menu a{
    border: 1px solid #E5E5E5;
    margin-bottom:-1px;
}--------------------------------





Включаем механизм выпадания [26/28]

По аналогии с 23 заданием делаем так, чтобы подменю появлялось при наведении мыши на родительский пункт меню.

Прячем подменю по умолчанию и отображаем с помощью контекстного селектора с псевдоклассом :hover.
------------------------------
Задание

    Спрячьте подменю по умолчанию.
    Сделайте так, чтобы оно появлялось при наведении на родительский элемент списка.
    Наведите мышь на второй пункт, чтобы подменю появилось.
-------------------------------
.main-menu{
    padding:0;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;
}
.main-menu>li{
    position:relative;
    display:inline-block;
    margin-right:-4px;
}
.main-menu a{
    display:block;
    padding:8px 10px;
    margin-left:-1px;
    color:#0088CC;
    border-left:1px solid #E5E5E5;    
}
.main-menu a:hover{
    background:#f5f5f5;
}
.main-menu .sub-menu{
    position:absolute;
    width:150px;
    left:1px;
    padding:0;
    margin:0;
    list-style:none;
    background:#FCF8E3;
    display:none;
}
.main-menu>li:hover .sub-menu{
    display:block;
}
.main-menu .sub-menu a{
    border:1px solid #E5E5E5;
    margin-bottom:-1px;
}----------------------------





Состояние «открытое подменю» [27/28]

Иногда нужно сделать так, чтобы выпадающее подменю было открыто по умолчанию (а не только при наведении мыши). Как этого добиться?

Сначала к элементу списка в меню верхнего уровня, где должно быть открыто подменю, добавим класс opened.

Затем используем селектор: .main-menu .opened .sub-menu. И в нём пропишем свойство, которое отображает подменю.

Очень похоже на выделение активного пункта меню. Кстати, чтобы выделить сам пункт меню с открытым подменю, можно использовать вот такой селектор .main-menu>.opened>a, т.е. «ссылка, которая лежит непосредственно в элементе с классом opened».
----------------------------
Задание

    Добавьте ко второму элементу списка класс opened.
    Сделайте так, чтобы подменю внутри пункта с классом opened отображалось по умолчанию.
    Задайте для ссылки, лежащей непосредственно внутри элемента с классом opened, белый цвет и фон #0088CC.
----------------------------
<body>
        <ul class="main-menu">
            <li><a href="#company">О компании</a></li>
            <li class="opened">
                <a href="#services">Услуги</a>
                <ul class="sub-menu">
                    <li><a href="#1">Разработка</a></li>
                    <li><a href="#2">Продвижение</a></li>
                    <li><a href="#3">Контекст</a></li>
                </ul>
            </li>
            <li><a href="#team">Сотрудники</a>
                <ul class="sub-menu">
                    <li><a href="#1">Руководство</a></li>
                    <li><a href="#2">Рабочие</a></li>
                </ul>
            </li>
        </ul>
    </body>
-----------------------------
.main-menu{
    padding:0;
    margin:0;
    list-style:none;
    border:1px solid #E5E5E5;
}
.main-menu>li{
    position:relative;
    display:inline-block;
    margin-right:-4px;
}
.main-menu a{
    display:block;
    padding:8px 10px;
    margin-left:-1px;
    color:#0088CC;
    border-left:1px solid #E5E5E5;
}
.main-menu a:hover{
    background:#f5f5f5;
}
.main-menu .sub-menu{
    display:none;
    position:absolute;
    width:150px;
    left:1px;
    padding:0;
    margin:0;
    list-style:none;
    background:#FCF8E3;
}
.main-menu .sub-menu a{
    border:1px solid #E5E5E5;
    margin-bottom:-1px;
}
.main-menu>li:hover .sub-menu{
    display:block;
}
.main-menu .opened .sub-menu{
    display:block;
}
.main-menu>.opened>a{
    color:white;
    background: #0088CC;
}--------------------------------





///////////////////////////////////////
Курс «Мастерская: декоративные элементы»
В этом курсе вы с нуля будете создавать различные декоративные элементы: социальные кнопки, переключатели страниц, блоки комментариев и так далее. Это прикладной курс, в котором вы будете использовать знания и навыки, полученные в предшествующих курсах. 
////////////////////////////////////////


Социальные кнопки, шаг 1 [1/18]

Начнём прохождение курса с простой задачи — вёрстки кнопок социальных сетей.

Обычно такие кнопки являются просто ссылками на страницы компании в социальных сетях. Стилизация работающих «лайков» является более сложной задачей.

Начнём с разметки. Нужно будет добавить в код три ссылки и задать каждой из них два класса. Один класс будет общим и будет отвечать за форму и размер кнопок. Второй класс будет уникальным и будет задавать фон и изображение соответствующей соцсети.
Что повторить:

    Что такое ссылка?
    Каскадность. Коктейль из классов
------------------------------
Задание

Добавьте 3 ссылки в блок .share после тэга <b>.

    Первая ссылка с классами: social и social-vk.
    Вторая ссылка с классами: social и social-fb.
    Третья ссылка с классами: social и social-tw.
----------------------------




Социальные кнопки, шаг 2 [2/18]

Мы будем выстраивать кнопки в ряд и задавать им размеры, поэтому нужно использовать блочно-строчный тип элемента.

Затем зададим фон и посмотрим, как ведут себя кнопки и подпись. Для того, чтобы красиво выровнять подпись «Соцсети» и кнопки, зададим вертикальное выравнивание по середине.

На этом этапе мы задаем общие стили кнопок, поэтому записываем их в CSS-правило для класса social.
Что повторить:

    Блочно-строчный тип
    Ширина и высота
    Внешние отступы
    Цвет фона
    Вертикальное выравнивание
-------------------------
Задание

Задайте для класса .social:

    Блочно-строчный тип элемента.
    Ширину и высоту 40px.
    Цвет фона #bdc3c7.
    Маргин справа 10px.
    Вертикальное выравнивание middle.
---------------------------

Вертикальное выравнивание: vertical-align [12/16]

Выравниванием текста по вертикали можно управлять с помощью свойства vertical-align. Его действие хорошо заметно в ячейках таблицы. Внутри текстовой строки "работа" этого свойства заметна, когда в ней есть фрагменты разного размера.

У данного свойства много значений, но самые часто используемые:

    top — выравнивание по верхнему краю строки;
    middle — по середине;
    bottom — по нижнему краю;
    baseline — по базовой линии (значение по умолчанию).

-------------------------




Социальные кнопки, шаг 3 [3/18]

У нас есть 3 серых ссылки-квадрата, осталось покрасить их в цвета соцсетей и добавить иконки.

В этом курсе мы часто будем использовать спрайты. Вот изображение-спрайт с иконками соцсетей:

Спрайт будет общим для всех ссылок, поэтому фоновое изображение зададим для класса social. А для уникальных классов соцсетей переопределим расположение фонового изображения и цвет фона.

Обратите внимание, что CSS-правила для конкретных соцсетей расположены в коде ниже, чем правило, задающее общий вид. Это нужно, чтобы работало переопределение CSS-свойств.
Что повторить:

    Фоновое изображение
    Повторение фона
    Расположение фона
    Спрайты
    Каскадность и приоритеты
---------------------
Свойство background-image [2/16]

Фоновое изображение можно задать с помощью CSS-свойства background-image. Делается это так:

selector{
    background-image:url('адрес-картинки');
}

Адрес картинки обязательно заключается внутрь url('...'). Адреса фоновых картинок такие же, как и адреса обычных картинок, которые вы задавали в курсе про ссылки и изображения.

Элементу можно одновременно задавать и цвет фона, и фоновую картинку. В этом случае картинка будет отображаться поверх фонового цвета.
-------------------------

Свойство background-position [4/16]

Cвойство background-position управляет расположением фонового изображения. Значение свойства состоит из двух частей, разделенных пробелом: x y.

x задаёт расположение по горизонтали, а y по вертикали.

В качестве значения x можно использовать ключевые слова left, center, right, значения в процентах и в пикселях.

В качестве значения y можно использовать ключевые слова top, center, bottom, значения в процентах и в пикселях.

Примеры использования свойства:

background-position:50% 50%;
// далее только значения
right bottom;
50px 100px;
0 100%;
left bottom;

Так сработают примеры:

    картинка будет по центру;
    правый нижний угол;
    отступ 50px от левого края и 100px от верхнего;
    левый нижний угол;
    левый нижний угол.
-------------------------
Задание

    Задайте для класса .social фоновое изображение /assets/course14/social.png без повторения.
    Для класса .social-vk цвет фона #6D8FB3 и расположение фонового изображения 0 0.
    Для класса .social-fb цвет фона #526da3 и расположение -40px 0.
    Для класса .social-tw цвет фона #73bfe6 и расположение -80px 0.
-----------------------------
.social{
    display:inline-block;
    width:40px;
    height:40px;
    margin-right:10px;
    vertical-align:middle;
    background-color:#bdc3c7; -------------------
    background-image:url('/assets/course14/social.png'); -----------------
    background-repeat: no-repeat; -------------------
}
.social-vk{
    background-color:#6D8FB3; ------------
    background-position: 0 0; ------------
}
.social-fb{
    background-color:#526da3;
    background-position: -40px 0;
}
.social-tw{
    background-color:#73bfe6;
    background-position: -80px 0;      
}--------------------------------





Переключатель страниц, шаг 1 [4/18]

Теперь потренируемся верстать переключатель страниц. Обычно разметка переключателей очень проста: это один див, внутри которого расположены ссылки с номерами страниц и ссылки «Вперёд/Назад».

Иногда внутри переключателя используют спаны, например, для «многоточий». Также переключатели иногда верстают списками.

Для начала зададим для ссылок и спанов блочно-строчный тип, размеры, внутренние отступы и фон.

Обратите внимание, что мы задаём не ширину, а минимальную ширину min-width, т.к. номера страниц могут быть длинными: 1 и 1000. Благодаря сочетанию паддингов и минимальной ширины, номер страницы будет всегда смотреться хорошо.
Что повторить:

    Внутренние отступы
----------------------------
Задание

Задайте ссылкам и спанам внутри блока .paginator:

    Блочно-строчный тип.
    Высоту 40px и минимальную ширину 20px.
    Горизонтальные паддинги 10px, вертикальные паддинги 0px.
    Цвет фона #95a5a6.
---------------------------
<!DOCTYPE html>
<html>
    <head>
       <title>Переключатель страниц, шаг 1</title>
       <meta charset="utf-8">
       <link href='//fonts.googleapis.com/css?family=PT+Sans:400,700&subset=cyrillic' rel='stylesheet' type='text/css'>
    </head>
    <body>
        <div class="paginator">
            <a href="#prev">Назад</a>
            <a href="#1">1</a>
            <span>&hellip;</span>
            <a href="#3">3</a>
            <a href="#next">Вперёд</a>
        </div>
    </body>
</html>
-----------------------------
body{
    margin:0;
    padding:0;
    font-size:16px;
    font-family:"PT Sans", sans-serif;
}

.paginator{
    width:280px;
    padding:10px;
    margin:30px auto;
    white-space:nowrap;
    background:#ecf0f1;
}

.paginator a,
.paginator span{
    display: inline-block;
    height: 40px;
    min-width:20px;
    padding: 0 10px 0 10px;
    background: #95a5a6;
    }-----------------------------





Переключатель страниц, шаг 2 [5/18]

Теперь оформим текст переключателей.

Сначала зададим горизонтальное выравнивание по центру. Затем зададим вертикальное выравнивание по середине. Чтобы был виден эффект вертикального выравнивания, нужно задать высоту строки такую же, как высота элемента, т.е. 40px.

Затем зададим цвет ссылок, уберем подчеркивание и сделаем шрифт полужирным.
Что повторить:

    Горизонтальное выравнивание
    Вертикальное выравнивание
    Высота строки
    Текстовые эффекты
    Выделение жирным
--------------------------

Свойство font-weight: выделение жирным [3/16]

Жирность текста можно задавать с помощью свойства font-weight, которое имеет два значения:

    normal — обычное начертание;
    bold — жирное начертание.

На самом деле это свойство имеет много значений: bold, bolder, lighter, normal, 100, 200, 300, 400, 500, 600, 700, 800, 900. Эти значения задают степень жирности шрифта, от самого тонкого, до самого-самого жирного.

Но большинство браузеров всё равно умеют отображать только два варианта жирности: обычный и жирный. Поэтому и остальные значения свойства обычно не используют.
-------------------------

Свойство text-decoration: подчеркивание и другие эффекты [7/16]

Дополнительное оформление текста можно задать с помощью свойства text-decoration. Его значения:

    underline — подчеркивание;
    line-through — зачеркивание;
    overline — черта сверху;
    blink — мигание;
    none — убирает вышеперечисленные эффекты.

К тексту можно одновременно применить несколько эффектов, если перечислить значения через пробел.
-------------------------

Свойство line-height: управляем высотой строки [14/16]

Высотой строки или, правильнее, межстрочным интервалом можно управлять с помощью свойства line-height. Значение этого свойства можно задавать следующими способами:

    Множителем, например 1.5, 2.
    В процентах: 150%.
    С помощью любых других единиц измерения css: 12px, 2em.
    Ключевым словом normal, которое задает автоматический расчет высоты строки.

Предпочтительнее задавать межстрочный интервал либо множителем, либо в относительных единицах измерения.
----------------------------

Горизонтальное выравнивание текста: text-align [11/16]

Выравнивание текста по горизонтали задается с помощью свойства text-align. Его вы уже использовали в курсе про таблицы. Значения свойства:

    left — выравнивание по левому краю;
    right — по правому краю;
    center — по центру;
    justify — по ширине.
----------------------

Вертикальное выравнивание: vertical-align [12/16]

Выравниванием текста по вертикали можно управлять с помощью свойства vertical-align. Его действие хорошо заметно в ячейках таблицы. Внутри текстовой строки "работа" этого свойства заметна, когда в ней есть фрагменты разного размера.

У данного свойства много значений, но самые часто используемые:

    top — выравнивание по верхнему краю строки;
    middle — по середине;
    bottom — по нижнему краю;
    baseline — по базовой линии (значение по умолчанию).
----------------------------
<!DOCTYPE html>
<html>
    <head>
       <title>Переключатель страниц, шаг 2</title>
       <meta charset="utf-8">
       <link href='//fonts.googleapis.com/css?family=PT+Sans:400,700&subset=cyrillic' rel='stylesheet' type='text/css'>
    </head>
    <body>
        <div class="paginator">
            <a href="#prev">Назад</a>
            <a href="#1">1</a>
            <span>&hellip;</span>
            <a href="#3">3</a>
            <a href="#next">Вперёд</a>
        </div>
    </body>
</html>
----------------------------
body{
    margin:0;
    padding:0;
    font-size:16px;
    font-family:"PT Sans", sans-serif;
}
.paginator{
    width:280px;
    padding:10px;
    margin:30px auto;
    white-space:nowrap;
    background:#ecf0f1;
}
.paginator a,
.paginator span{
    display:inline-block;
    min-width:20px;
    padding:0 10px;
    height:40px;
    background-color:#95a5a6;
    vertical-align:middle;
    text-align: center;
    line-height: 40px;
    color: white;
    text-decoration: none;
    font-weight: bold;
    }------------------------------





Переключатель страниц, шаг 3 [6/18]

Займемся переключателями «вперед» и «назад». Пока что мы используем текстовые надписи. Но мы их спрячем и заменим на стрелочки.

Первым делом добавим к переключателям классы prev и next. Чтобы спрятать текст, используем свойство text-indent с большим отрицательным значением.

Затем отделим переключатели от номеров страниц с помощью отступов и с помощью уже знакомой техники спрайтов добавим на фон стрелочки. Вот спрайт на тёмном фоне:
--------------------------
Задание

    Добавьте первой ссылке класс prev, последней класс next.
    Для обоих классов задайте text-indent:-1000px;.
    Маргин размером 20px справа для .prev и слева для .next.
    Для обоих классов задайте неповторяющийся фон /assets/course14/arrows.png.
    Положение фона 0 0 для .prev и 0 -40px для .next.
---------------------------
body{
    margin:0;	---------------- внешний отступ
    padding:0;	---------------- внутренный отступ
    font-size:16px;	------------------- размер шрифта
    font-family:"PT Sans", sans-serif;	----------------- тип шрифта
}
.paginator{
    width:280px;	----------------- высота блока
    padding:10px;	----------------- внутренний оступ блока
    margin:30px auto;	----------------- внешние отступы болка верх/низ и право/лево
    white-space:nowrap;	---------------- пробелы между словами в блоке не переносятся
    background:#ecf0f1;	----------------- цвет фона
}
.paginator a,
.paginator span{
    display:inline-block;	--------------- строчно-блочный тип
    min-width:20px;		--------------- минимальная ширина блока
    padding:0 10px;
    height:40px;		--------------- высота блока
    background-color:#95a5a6;	--------------- цвет фона
    color:white;		--------------- цвет шрифта
    text-align:center;		--------------- выравнивание текста по ширине
    vertical-align:middle;	--------------- выравнивание текста по высоте
    line-height:40px;		--------------- высота блока
    text-decoration:none;	--------------- оформление текста/без подчеркивания
    font-weight:bold;		--------------- шрифт/жирный
}
.paginator .prev{
    text-indent:-1000px;	--------------- вынос текста из блока далеко/без смещения блока
    background-image:url('/assets/course14/arrows.png');	-----------------  картинка для фона
    background-repeat: no-repeat;	------------------------- картинка для фона не повторяется
    background-position: 0 0;		------------------------- смещение картинки / нет
    margin-right:20px;			------------------------ внещшний отступ блока справа
}
.paginator .next{
    text-indent:-1000px;
    background-image:url('/assets/course14/arrows.png');
    background-repeat: no-repeat;
    background-position: 0 -40px;
    margin-left: 20px;
}--------------------------




Переключатель страниц, шаг 4 [7/18]

Переключатель страниц почти готов. Но хороший верстальщик и хороший дизайнер всегда думают о мелочах.

В этом задании мы поработаем над состояниями элементов переключателя.

Первая очевидная деталь относится к номерам страниц. Надо как-то выделять текущую страницу. Для этого будем использовать класс current, для которого зададим зелёный фон.

Менее очевидная деталь относится к состояниям кнопок-стрелочек «вперед» и «назад». Когда мы находимся на первой странице, кнопка «назад» должна быть неактивна, а когда на последней странице — неактивна кнопка «вперед».

Оформим неактивные кнопки с помощью класса disabled, который будет делать кнопку полупрозрачной.
-----------------------------
Задание

    Добавьте ссылке с классом prev класс disabled.
    Добавьте ссылке на 1 страницу класс current.
    Для .current задайте цвет фона #16a085.
    Для .disabled задайте 30% прозрачность opacity:0.3;.
    Задайте ссылкам цвет фона #2ecc71 при наведении.
--------------------------------
<body>
        <div class="paginator">
            <a class="prev disabled" href="#prev">Назад</a>
            <a class="current" href="#1">1</a>
            <span>&hellip;</span>
            <a href="#3">3</a>
            <a class="next" href="#next">Вперёд</a>
        </div>
    </body>
-----------------------------------
.paginator .prev{
    text-indent:-1000px;
    margin-right:20px;
    background-image:url('/assets/course14/arrows.png');
    background-repeat:no-repeat;
    background-position:0 0;
}
.paginator .next{
    text-indent:-1000px;
    margin-left:20px;
    background-image:url('/assets/course14/arrows.png');
    background-repeat:no-repeat;
    background-position:0 -40px;
}
.paginator .current{
    background: #16a085;
}
.paginator .disabled{
    opacity: 0.3;	-------------------- прозрачность 30%.
}
------------------------------------





Контакты, шаг 1 [10/18]

В этой серии заданий мы оформим невзрачный и скучный блок контактов.

Блоки с контактной информацией, похожие на тот, который вы видите в мини-браузере, встречаются на многих сайтах. Штука нехитрая — пишем адрес, сайт и email, а потом добавляем переносы строк с помощью <br>.

Как улучшить оформление этого блока?

Во-первых, выделить заголовок и добавить отступы между элементами контактов. Во-вторых, добавить для каждого элемента небольшие иконки.

Давайте начнем.
---------------------------


Контакты, шаг 2 [11/18]

Заголовок и отступы сделали блок контактов более структурированным.

Отступы слева, как вы уже догадались, предназначены для размещения иконок.

Иконки будем размещать по одной из классических техник: «абсолютные элементы + спрайты».

В каждом из блоков .item есть пустой див .icon, в котором и будет отображаться иконка.

Зададим этому диву абсолютное позиционирование, фиксированные размеры и расположим в верхнем левом углу родителя (для этого мы задавали относительное позиционирование для .item).

Осталось задать для .item картинку-спрайт в качестве фона. Вот она:
-----------------------------------
Задание

Задайте для .icon:

    Абсолютное позиционирование, кординату сверху 3px, слева 0px.
    Ширину 22px, высоту 32px.
    Фоновое изображение /assets/course14/contacts.png без повторения, положение фона 0 0.
----------------------------
body{
    font-family:"PT Sans", sans-serif;
    font-size:14px;
    color:#777777;
}
.contacts{
    width:250px;
    margin:0 auto;
    margin-top:80px;
}
.contacts .title{
    font-size:20px;
    color:#7f8c8c;
    font-weight:bold;	---------------------------- полужирный текст
    margin-bottom:20px;
}
.contacts .item{
    position:relative;
    padding-left:30px;
    margin-bottom:10px;
}
.contacts .icon{
    position:absolute;
    top:3px;
    left:0px;
    width:22px;
    height:32px;
    background-image:url('/assets/course14/contacts.png');
    background-repeat:no-repeat;
    background-position:0 0;

}---------------------------------




Контакты, шаг 3 [12/18]

На последнем шаге нужно задать каждому элементу контактов свою иконку.

Сделаем это так же, как в задании про социальные кнопки. Сначала добавим каждому из блоков .item свой уникальный класс. А затем в CSS переопределим положение фона для этих классов.

И финальный штрих — зададим цвет ссылок, который сочетается с цветом иконок.
---------------------------
Задание

    Добавьте первой иконке класс icon-location, второй icon-phone, третьей icon-email.
    Задайте положение фона 0 0 для icon-location, -30px 0 для icon-phone, -60px 0 для icon-email.
    Задайте цвет ссылок #e2534b.
----------------------------
body{
    font-family:"PT Sans", sans-serif;
    font-size:14px;
    color:#777777;
}
.contacts{
    width:250px;
    margin:0 auto;
    margin-top:80px;    
}
.contacts .title{
    font-size:20px;
    color:#7f8c8c;
    font-weight:bold;
    margin-bottom:20px; 
}
.contacts .item{
    position:relative;
    padding-left:30px;
    margin-bottom:10px;
}
.contacts .icon{
    position:absolute;
    top:3px;
    left:0;
    width:22px;
    height:32px;
    background:url('/assets/course14/contacts.png') no-repeat 0 0;
}

.contacts .icon-location{
    background-position:0 0;
    
}

.contacts .icon-phone{
    background-position:-30px 0;
}

.contacts .icon-email{
    background-position:-60px 0;
}

.contacts a{
    color:#e2534b;
}----------------------------






Комментарии, шаг 1 [13/18]

В последней серии заданий мы сверстаем список комментариев.

Кстати, обратите внимание на CSS. В предыдущих заданиях мы создавали пространства имён классов в CSS с помощью контекстных селекторов. Например:

.contacts .title{}
.contacts .item{}

О пространствах имен уже говорилось в курсе про меню.

В этой серии заданий мы будем использовать другой способ создания пространства имён. Он заключается в том, что мы будем добавлять к названию каждого класса префикс, например:

.comment-avatar{}
.contacts-title{}

Оба способа хороши и используются в зависимости от предпочтений. Самое главное — использовать пространства имён.

В этом задании мы начнём оформлять блоки аватара и автора комментария.
---------------------------
Задание

    Задайте для .comment-avatar ширину и высоту 70px.
    Задайте для .comment-avatar цвет фона #7f8c8c, фоновое изображение /assets/course14/avatar.png без повторения, расположение фона 50% 50%.
    Задайте для .comment-author размер шрифта 16px, полужирное начертание, а также маргин снизу 5px.
------------------------------
body{
    font-family:"PT Sans", sans-serif;
    font-size:14px;
    color:#777777;
}
.comment{
    position:relative;
    margin-left:50px;
    margin-top:90px;
    margin-right:20px;
}
.comment-avatar{
    width: 70px;
    height: 70px;
    background:#7f8c8c;
    background-image:url('/assets/course14/avatar.png');
    background-repeat:no-repeat;
    background-position: 50% 50%;
}
.comment-author{
    font-size:16px;
    font-weight:bold;
    margin-bottom: 5px;
}----------------------------





Комментарии, шаг 2 [14/18]

Продолжаем работу. На этом шаге оформим сам текст комментария и дату комментария.

Обычно менее важную информацию стараются приглушить. Для этого используют следующие приёмы: уменьшают размер шрифта, задают менее контрастный цвет текста или сочетают эти эффекты. Простейшие CSS-свойства помогают эффективно расставлять акценты в дизайне.

В нашем случае дата комментария не столь важна, поэтому её и приглушим.
------------------------
Задание

    Задайте для .comment-text паддинг со всех сторон 12px, цвет фона #f8f8f8, сплошную рамку снизу толщиной 5px цветом #e5e6e6.
    Задайте для .comment-date размер шрифта 12px, цвет текста #bdc3c7 и маргин сверху 5px.
-----------------------
<body>
        <div class="comment">
            <div class="comment-avatar"></div>
            <div class="comment-author">Дима Дивов</div>
            <div class="comment-text">
                Неплохой курс. Нравится собирать и применять теорию на практике.
                <div class="comment-date">16.09.2013</div>
            </div>
            <a href="#reply" title="Ответить" class="comment-reply"></a>
        </div>
    </body>
-----------------------------
body{
    font-family:"PT Sans", sans-serif;
    font-size:14px;
    color:#777777;
}
.comment{
    position:relative;
    margin-left:50px;
    margin-top:90px;
    margin-right:20px;
}
.comment-avatar{
    width:70px;
    height:70px;
    background:#7f8c8c url('/assets/course14/avatar.png') no-repeat 50% 50%;
}
.comment-author{
    font-size:16px;
    font-weight:bold;
    margin-bottom:5px;
}
.comment-text{
    padding: 12px 12px;
    background: #f8f8f8;
    border-bottom: 5px solid #e5e6e6;
}
.comment-date{
    font-size:12px;
    color: #bdc3c7;
    margin-top: 5px;
}----------------------------





Комментарии, шаг 3 [15/18]

На этом шаге оформляем кнопку ответа на комментарий.

Все приёмы вам уже знакомы: кнопка будет абсолютно спозиционированным элементом с фиксированными размерами. На фон ей зададим иконку. Затем разместим кнопку в правом верхнем углу комментария.

Блок комментария обладает относительным позиционированием, поэтом проблем с размещением иконки не возникнет.
---------------------------
Задание

Задайте для .comment-reply:

    Абсолютное позиционирование, координаты сверху 0px, справа 0px.
    Ширину и высоту 15px.
    Фоновое изображение /assets/course14/reply.png без повторения, положение фона 0 0.
--------------------------
<body>
    
        <div class="comment">
        
            <div class="comment-avatar"></div>
            <div class="comment-author">Дима Дивов</div>
            <div class="comment-text">
                Неплохой курс. Нравится собирать и применять теорию на практике.
                <div class="comment-date">16.09.2013</div>
            </div>
            <a href="#reply" title="Ответить" class="comment-reply"></a>
        </div>
        
    </body>
---------------------------------
.comment-avatar{
    width:70px;
    height:70px;
    background:#7f8c8c url('/assets/course14/avatar.png') no-repeat 50% 50%;
}

.comment-author{
    font-size:16px;
    font-weight:bold;
    margin-bottom:5px;
}

.comment-text{
    padding:12px;
    background:#f8f8f8;
    border-bottom:5px solid #e5e6e6;
}

.comment-date{
    margin-top:5px;
    font-size:12px;
    color:#bdc3c7;
}

.comment-reply{
    position:absolute;
    top: 0px;
    right: 0px;
    width:15px;
    height:15px;
    background-image: url('/assets/course14/reply.png');
    background-repeat: no-repeat;
    background-position: 0 0;
    
}------------------------------



Из книги Подоба:

table - вперше скористаємось тегом таблиці; цей тег має масу
атрибутів та властивостей, але вони нас поки не цікавлять, адже увесь
наступний вигляд ми “магічно” застосуємо кількома класами з Twitter
Bootstrap

thead - містилище заголовкових рядочків таблиці, так званий хідер
таблиці;

tr - рядок таблиці, однаковий як для тіла таблиці, так і для хідера
таблиці;

th - тег однієї комірки таблиці саме в шапці таблиці; по замовчу-
ванню він застосовує жирний шрифт до внутрішнього тексту;

tbody - тіло таблиці, містить рядочки тіла таблиці

td - тег однієї комірки таблиці, але вже тіла таблиці; не застосовує
додаткових стилів до внутрішніх елементів


використовує HTML5 тег - nav. Це семанти-
чний елемент, який вказує браузеру, що він містить навігаційний елемент
всередині.









































==============================
CSS
==============================

Напомним, что CSS расшифровывается как «каскадные таблицы стилей». Этот язык отвечает за внешний вид HTML-страницы. Синтаксис языка достаточно прост: он состоит из селекторов и свойств.

С помощью селекторов можно сказать браузеру какие именно элементы мы хотим оформить. Свойства описывают как именно мы хотим оформить эти элементы. То есть селекторы — это снайперский прицел, а свойства — это кисть, рубанок, скальпель и перфоратор.

В CSS комментарии задаются с помощью символов /* и */



CSS-правила [2/15]

Весь CSS-код состоит из повторяющихся блоков следующего вида:

селектор {
    свойство1: значение;
    свойство2: значение;
}

Такой блок называется «CSS-правило». Каждое CSS-правило содержит хотя бы один селектор и свойство.

Простейшие селекторы — это селекторы по именам тэгов. С их помощью можно задать стили для всех абзацев на странице, для всех ссылок или заголовков первого уровня. Такие селекторы просто содержат имя тэга без символов < и >


Продвинутые селекторы [3/15]

К более сложным селекторам можно отнести селекторы с использованием классов и псевдоклассов.

Класс позволяет объединять разные элементы в смысловые группы и применять к ним одинаковое оформление. Например, можно создать класс «элементы с ошибкой» и задать ему красный цвет текста. Затем можно добавлять этот класс к любому HTML-тэгу: абзацу, заголовку, элементу списка и т.д.

Класс тэга задаётся с помощью атрибута class, который содержит имя класса (или имена классов через пробел). Пример:

<p class="help"></p>
<p class="help error"></p>

В примере у первого абзаца задан класс help, у второго абзаца заданы классы help и error.

Селектор с использованием класса задается так: .имя_класса. Например:

.help{
}
.error{
}


ПРИОРИТЕТНОСТЬ ЗАДАВАНИЯ СИЛЕЙ: 
1) в style
2) в id
3) в class
4) в тэге



    <head>
            
        <style type="text/css">  ---->> так можно установить стиль ко всей странице, в "хиде", с помощью "стайл"  
            h1{
                font-size:1.5em;
                font-family:sans-serif;
            }
            p{
                color:green;
            }
        </style>
    </head>



    <head>
        <meta charset="utf-8">
        
        <link href="/assets/course2/style1.css" rel="stylesheet"> ------>> вот таким образом подключаются (линк) стили из внешних
									источников (указывается адрес)
        
    </head>
	------->> при этом href - тэг который задает именно ссылку, rel - это чтото из релеантности т.е. оптимизации - нужен!


/* - так можно заблокировать css


<p style="color: red;">...</p> - пример встроенного стиля css, с помощью стайл (сатрибут) и его свойста/значений;

body {
    padding: 0 20px;
    font-family: Arial, sans-serif;
    font-size: 16px;
}   

//* это CSS - 1) начинается кончается фигурными скобками
		2) атрибут заканчивается двоеточием
		3) чередование запятыми
		4) строка заканчивается точка-запятая

font-size: 16px;  - размер шрифта

text-shadow: 2px 2px 0 #ccc; - вид тени и цвет

font-family: Georgia, serif; - шрифт

/* Пример оформления цитаты */

blockquote {      -------------->> так задается параметры селектора
    margin: 1.5em 0;
    padding: 0.5em 15px;
    line-height: 1.5;
    background: #f9f9f9;
    border-left: 2px solid #ccc;    
}


strong {  ---->>> селектором выступает тег
    color: green;
}

.nice-cite {  ------>> так задается параметры произвольной переменной (класс) (.) - с точкой
    margin: 1.5em 0;
    padding: 0.5em 25px;
    line-height: 1.5;
    background: #f5f5f5;
    border-left: 5px solid #E7471E;    
}

<p class="help">...</p> - сначала в документе
.help { 
color: green; 
}  		а затем в стилях,   — выберет все теги с классом "help"

text-decoration: line-through;  --------->> перечеркнутый текст

padding-left: 15px; --------->> отступ слева в пикселях

background-color: #FFF0F0; --------->> заливка фона и номер цвета


.first,       ---------->> так задается одно правило на несколько классов
.fifth {
    background:white;
    }
    
.second {
    background:yellow;
    }
    

Контекстные селекторы [5/18]

Селектор может состоять из нескольких частей, разделенных пробелом, например:

p strong{}
ul .hit{}
.footer .menu a{}

Такие селекторы называют контекстными. Их используют для того, чтобы применить стили к элементу, только если он вложен в нужный элемент.

Например, селектор .menu a сработает для ссылки a только в том случае, если она расположена внутри элемента с классом .menu.

Таким образом, можно задавать элементам различные стили в зависимости от их контекста. Если ссылка расположена внутри меню, сделать её крупнее, а если внутри основного текста, то задать ей нужный цвет.

<body>
        <div class="shooter-1">    -------->> класс first внутри класса shooter-1
            <ul class="target">
                <li class="first">1</li>
                <li class="second">2</li>
                <li class="third">3</li>
                <li class="fourth">4</li>
                <li class="fifth">5</li>
            </ul>
        </div>
        <div class="shooter-2">
            <ul class="target">
                <li class="first">1</li>
                <li class="second">2</li>
                <li class="third">3</li>
                <li class="fourth">4</li>
                <li class="fifth">5</li>
            </ul>
        </div>
    </body>

.shooter-1 .first, ----------------->> указывается цель: класс внутри класса
.shooter-1 .third,
.shooter-1 .fourth
{
    background:white;
    }

.shooter-1 .second,
.shooter-1 .fifth
{
    background:red;
    }
    
.shooter-2 .first 
{
    background:red;
    }
    
.shooter-2 .second,
.shooter-2 .third,
.shooter-2 .fourth,
.shooter-2 .fifth
{
    background:white;
    }


li{			------------->> например, задаем фон для всех (двух) списков
background: white;
}

.shooter-1 .third+li, .shooter-2 .first+li{ ---------->> задаем фон для отдельных элементов списков со здвигом на 1 от маркированых элементов
background: red;
}

.shooter-2 .third+li{ ----------->>
background: yellow;
}




Дочерние селекторы [8/18]

Потомком называются любые элементы, расположенные внутри родительского элемента. А дочерними элементами называются ближайшие потомки. Взгляните на пример:

<ul>
    <li><em>...</em></li>
    <li><em>...</em></li>
</ul>

По отношению к <ul> <li> являются дочерними элементами и потомками, а <em> — потомки, но не дочерние элементы.

Контекстные селекторы влияют на всех потомков, что не всегда удобно. Иногда необходимо задать стили только для дочерних элементов. Особенно это полезно при работе с многоуровневыми списками.

Для этого существует дочерний селектор, в котором используется символ >. Например: ul>li или ul>li>em.

В этом задании вы разберетесь, чем отличаются контекстные и дочерние селекторы.

.places>li {
    border-bottom:1px solid #ccc;
}

.places>li>em {  ------------>> указан конкретный путь к к оторому применятеся стиль
    font-weight:bold;
}




Псевдоклассы [9/18]

Псевдоклассы — это дополнения к обычным селекторам, которые делают их еще точнее и мощнее. Обычный селектор — это снайперский прицел, а с псевдоклассом он становится прибором ночного видения.

Псевдокласс добавляется к селектору c помощью символа :, вот так селектор:псевдокласс. Например:

a:visited{}
li:last-child{}
.alert:hover{}

Знакомство с псевдоклассами мы начнем с first-child и last-child.

Псевдокласс first-child позволяет выбрать первый дочерний элемент родителя, а last-child — последний дочерний элемент. Например:

li:last-child{}

Этот селектор выберет последний элемент списка.
li {		--------->>> задает стиль для всего списка
    background:white;
    }
    
li:first-child {	----------->> задает стиль для первого элемента списка
    background:red;
    }
    
li:last-child {		---------->> задает стиль для последнего элемента списка
    background:yellow;
    }



Псевдокласс :nth-child [10/18]

Псевдоклассы из предыдущего примера относятся к семейству псевдоклассов, помогающих выбирать элементы по их расположению.

Вспомним задание 4. В нём каждому тэгу <li> был задан собственный класс. Используя классы, мы могли выбрать любой из пяти тэгов. Если бы тэгов было десять, то пришлось бы использовать десять разных классов.

С помощью псевдокласса nth-child можно выбирать тэги по порядковому номеру, не используя классы. Синтаксис псевдокласса:
селектор:nth-child(выражение).
li {
    background:white;
    }
    
li:nth-child(3), 		------------------->> указаны для стиля конкретные по порядку элементы стиля
li:nth-child(4) {
    background: red;
    }



:nth-child и контекстные селекторы [11/18]

Селекторы с псевдоклассами хорошо сочетаются с контекстными селекторами.

Например, селектор:

.shooter-2 li:nth-child(3){}

Выберет третий тэг <li> внутри блока с классом shooter-2.
li {
    background:white;
    }
    
.shooter-1 li:nth-child(2),
.shooter-1 li:nth-child(5) {
    background:red;
    }

.shooter-2 li:nth-child(1) {
    background:red;
    }



Псевдокласс :hover [12/18] ----------->> подсветка элемента (строки, значения) когда наводится мышь

Некоторые псевдоклассы позволяют выбирать элементы, с которыми взаимодействует пользователь. Сначала познакомимся с псевдоклассом :hover.

Этот псевдокласс позволяет выбрать элемент, когда на него наведен курсор мыши и кнопка мыши не нажата. Примеры:

1. a:hover{}
2. tr:hover{}
3 .menu-item:hover{}

Первый селектор выбирает ссылку, второй строку таблицы, третий элемент с классом menu-item, но только в том случае, если на них наведен курсор мыши.

Благодаря этому псевдоклассу можно добавлять в интерфейс динамику и интерактивность, т.к. элементы начинают реагировать на действия пользователя, изменяя свой внешний вид.

tr:hover{            ------------->> при этом происходит подсветка сроки таблбибцы бкобгдба бна нее наводится мышь
background:#FCF8E3;
}




Динамические эффекты с помощью :hover [13/18]

Интересовались ли вы, как с помощью CSS создаются выпадающие меню?

Львиная доля динамических эффектов, создаваемых с помощью CSS, опираются на несколько псевдоклассов, главный из которых, конечно же, :hover. Весь секрет заключается в сочетании контекстных селекторов и псевдоклассов. Посмотрите на пример:

li.top ul.submenu{
    display:none;
}
li.top:hover ul.submenu{
    display:block;
}

Первое правило прячет список-подменю. Второе правило гласит: «если на верхний пункт меню, в котором находится подменю, наведут курсор, то надо показать подменю». Вот так всё просто.

Общий принцип такой: родительский элемент реагирует на наведение мыши и изменяет свойства элементов-потомков. Т.е. всё работает на контекстных селекторах вида селектор1:hover селектор2
<head>
       <title>Динамические эффекты с помощью :hover</title>
       <meta charset="utf-8">
       <link rel="stylesheet" href="/assets/course7/style4.css" />
       <style>			--------->> так задается стиль CSS в хиде страницы
           em{display:none;}   --------->> тут задали свойство, что элемент обнесенный <em> </em> на дисплее не показывается
        </style>
</head>
...
<tr>
    <td>1.</td>
    <td>Мартен Фуркад <em>Франция</em></td>    ----------->> вот он
    <td><strong>151</strong></td>
</tr>
...
td:hover em {
    display:inline;    ------->> тут задано свойство, что если мышь наводится на строку с элементом <em> то надпись высвечивается
    }
    
td:hover strong {   ---------->> тут задано, что если мышь наводится на элемент <strong> то к значению применяется цвет
    color:#0088CC;
    }



Псевдоклассы :link, :visited и :active [14/18]

Отвлечемся от биатлона и познакомимся с псевдоклассами для ссылок.

    :link выбирает еще не посещенные ссылки.
    :visited выбирает посещенные ссылки.
    :active выбирает активные ссылки (кнопка мыши зажата на ссылке).

Пример задания CSS-правил для ссылок:

a:link{}
a:visited{}
a:hover{}
a:active{}

Обратите внимание на порядок правил. Если их расположить по-другому, то некоторые могут не сработать.
a:link {		------------>> задается свойства для всех ссылок до посещения
    color:black;
    }
    
a:visited {		------------>> задаются свойства для ссылки уже посещенной
    color:#ccc;
    }
    
a:active {		------------>> задается свойства для ссылке на которой нажата мышь
    color:green;
    }




Псевдокласс :focus [15/18]

Псевдокласс :focus позволяет выбрать элемент, который в данный момент в фокусе. Например, текстовое поле, в которое установлен курсор, находится в фокусе.

В фокусе могут быть не только текстовые поля. Если вы переключаетесь между элементами веб-страницы с помощью клавиши TAB, то в фокус будут попадать ссылки.

Пример использования псевдокласса:

input:focus{
    стили для поля в фокусе
}
<body>
        <form class="login" method="post" action="">
            <label for="login">Логин</label>
            <input type="text" id="login" name="login" />	--------- вот ячейка
            <label for="password">Пароль</label>
            <input type="password" id="password" name="password" />	--------- и вот ячейка
            <input type="submit" value="Войти" />			--------- и вот ячейка
        </form>
</body>
...
input:focus{		------->> границы активной ячейки, куда установлена мышь, меняют цвет на указанный синий (красиво) 
    border-color:#0088CC;
}



Селекторы атрибутов [16/18]

Ранее мы познакомились с атрибутом class и специальными селекторами по классу. Существуют селекторы, которые позволяют выбирать элементы по любым атрибутам.

Чаще всего такие селекторы используются при работе с формами, так как поля форм имеют атрибут type с разными значениями.

Селекторы атрибутов записываются с использованием квадратных скобок: элемент[атрибут]. Примеры селекторов:

1. input[checked]{}
2. input[type="text"]{}

Первый селектор выберет поля формы, у которых есть атрибут checked, второй селектор выберет поля формы, у которых атрибут type имеет значение text.
<form class="login" method="post" action="">
            <label for="login">Логин</label>
            <input type="text" id="login" name="login" required />
            <label for="password">Пароль</label>
            <input type="password" id="password" name="password" />
            <input type="submit" value="Войти" />
</form>
...
input[required] {	------------- задан цвет фона для ячейки с required
    background:#FCF8E3;
    }
    
input[type="password"] {	---------- задан цвет фона для ячейки с type="password"
    background:#F2DEDE;
    }
    
input[type="submit"] {		----------- задан цвет фона для кнопки Отправить
    border-color:green;
    }



Селектор по id [17/18]

Существует еще один HTML-атрибут, для которого существует специальный селектор. Этот атрибут id (идентификатор), а селектор записывается с помощью символа #, например, #some-id.

На значение id распространяются те же ограничения, что и на имя класса. Также id должен быть уникальным на странице.
Использование селекторов по id при верстке считается плохой практикой.

Но есть исключение. Использование id при вёрстке форм — это хорошо и похвально. Поэтому, иногда можно задавать стили для элементов форм, используя их идентификаторы.
<form class="login" method="post" action="">
            <label for="fullname">Имя</label>
            <input type="text" id="fullname" name="fullname" />	-------- вот id
            <label for="year">Год рождения</label>
            <input type="text" id="year" name="year" />		--------- и вот id
            <input type="submit" value="Войти" />
</form>
...
#fullname {		----------------- задан цвет фона для ячейки по id (якорь)
    background:#FCF8E3;
    }
    
#year {			----------------- задана ширина ячейки по id (якорь)
    width:100px;
    }



Принудительное наследование [7/18]

Для каждого свойства может быть задано значение inherit.

Оно означает, что данное свойство принимает такое же значение, как и у родительского элемента. Значение inherit может быть использовано для усиления наследуемых значений, а также в свойствах, которые обычно не наследуются.

Запись выглядит следующим образом:

p{
    background:inherit;
}

В данном случае у тегов p свойство background будет таким же, как и у их родительских тегов.


Каскадирование [8/18]

CSS расшифровывается как «Cascading Style Sheets» или «каскадные таблицы стилей».

Каскадность обозначает, что к одному и тому же элементу может применяться несколько CSS-правил (наборов CSS-свойств). Среди этих свойств могут быть и конфликтующие между собой. Поэтому существуют инструкции, которые определяют, каким будет финальный набор свойств элемента.

Например, для элемента:

<p class="text" style="color: red;"></p>

CSS-правила существуют как минимум в трёх разных местах:

    в подключаемом файле style.css для селекторов p или .text;
    в атрибуте style;
    в стандартных стилях отображения, встроенных в браузер.

Каскадирование как раз и определяет, какие именно свойства из этих источников применятся к данному абзацу.

Имеется три основные концепции, управляющие порядком, в котором применяются CSS-свойства:

    важность;
    специфичность;
    порядок исходного кода.

Самыми важными для нас являются последние две и подробнее о них мы поговорим отдельно.


Битва за курочку [9/18]

Перед тем как разбирать сложные правила работы каскадирования, расчёта специфичности и определения приоритетов, потренируемся на котиках.

Разберём пример. Вот HTML-код, в котором есть абзац с двумя классами:

<p class="red blue">Синий или красный?</p>

А вот CSS-код c двумя правилами для этих классов:

.blue{
    color:blue;
}
.red{
    color:red;
}

Вопрос: какого цвета будет текст абзаца? Какое из CSS-правил приоритетнее?

Ответ: красного цвета, второе правило приоритетнее.

Это происходит потому, что селекторы у правил одинакового типа, и соответсвенно обладают одинаковой специфичностью. В таком случае более высоким приоритетом обладает то правило, которое расположено в CSS-коде ниже. В нашем случае это правило для класса red.


Битва за курочку. Раунд второй [10/18]

Чуть более сложный пример. Тот же HTML:

<p class="red blue">Синий или красный?</p>

Немного другой CSS:

p.blue{
    color:blue;
}
.red{
    color:red;
}

В этом случае текст абзаца будет синим. Происходит это потому, что селектор p.blue более специфичный, чем селектор .red.

Простое объяснение специфичности звучит так:

    Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.

В нашем примере селектор .red выберет все тэги с нужным классом, а селектор p.blue выберет только абзацы с нужным классом. 



Битва за курочку. Раунд третий [11/18]

А теперь посмотрим, как ведут себя контекстные селекторы.

<div class="experiment">
    <p class="red blue">Синий или красный?</p>
</div>

И в CSS используем контекстный селектор для второго правила:

p.blue{
    color:blue;
}
.experiment .red{
    color:red;
}

Какой теперь будет цвет текста?		------------------ .experiment .red специфичнее чем p.blue (приоритетнее)



Битва за курочку. Борьба накаляется [12/18]

Как вы уже знаете, существуют селекторы не только по классам, но и по id. Они начинаются с решётки #.

HTML:

<div id="experiment-1" class="experiment">
    <p class="red blue">Синий или красный?</p>
</div>

CSS:

#experiment-1 .blue{
    color:blue;
}
.experiment .red{
    color:red;
}			----------------- #experiment-1 .blue специфичнее чем .experiment .red (# приоритетнее)

Особенность атрибута id заключается в том, что его значение должно быть уникальным в пределах страницы. То есть, может существовать только один тэг с определенным значением id.

Получается, что селектор по id может выбрать только один элемент. И поэтому он на порядок специфичнее селекторов по тэгам, классам, а также комбинаций этих селекторов.



Битва за курочку. Запрещённый приём [13/18]

Битва подходит к концу, и чтобы удержать победу, Рудольф решается на запрещённый приём:

Он прописывает стили с помощью атрибута style прямо в тэге курочки.

CSS-правила, которые прописаны в style обладают наивысшим приоритетом. Такой способ задания стилей не приветствуется в профессиональной вёртске сайтов и годится только для создания быстрых прототипов. Поэтому мы и назвали этот приём запрещённым.

Однако существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте style. Для этого нужно использовать ключевое слово !important. Оно задаёт CSS-свойству усиленный приоритет. Вот пример:

HTML:

<p style="color:red;" class="blue">Синий или красный?</p>

CSS:

.blue{
    color:blue !important;
}

Цвет текста в этом примере будет синим.

При вёрстке не рекомендуется часто использовать !important. По возможности старайтесь обходиться без него.

<body>
        <h1>Кому достанется курочка?</h1>
        <div id="keks-vs-rudolf" class="battle">
            <div class="cat cat-keksik">Кексик</div>
            <div class="cat cat-rudolf">Рудольф</div>
            
            <!-- Видя, как победа ускользает из лап,
            Рудольф решается на запрещенный приём -->
            <div style="margin-left:120px;" class="chicken to-keksik to-rudolf"></div>  -------- сильная позиция приоритета
        </div>            
 </body>
... но
/* Усилением селектора здесь не обойтись.
   Придётся ответить грубостью на грубость */
.to-keksik{
    margin-left:-120px !important;    ---------- сильнейшая победная позиция приоритета - использовать редко
}



Перекрестное наследование [17/18]

При создании стилей для сходных по внешнему виду или функциональности элементов, которые могут использоваться на странице неоднократно, очень удобно пользоваться перекрёстным наследованием.

Прием этот заключается в следующем:

    создается базовый стиль для таких элементов;
    определяются вспомогательные стили, которые применяются к элементам по мере надобности;
    элемент наследует базовый стиль и один или несколько вспомогательных.

Пример:

На странице используются кнопки разного назначения: для отправки форм, для сброса информации в полях формы, как элементы навигации и т.д.

Можно вынести общее оформление (размеры, отступы и т.д.) для всех кнопок в отдельное CSS-правило для класса, например, .button.

А затем создать дополнительные CSS-правила, в которых будут определены только различающиеся свойства этих кнопок, например, цвет фона. Для этих правил можно использовать такие названия классов: .button-send, .button-clear, .button-navigation.

Каждая кнопка в HTML-коде будет иметь два класса: общий и дополнительный.

<a class="button button-send">Отправить</a>

<!DOCTYPE html>
<html>

	<head>
	    <title>Перекрестное наследование</title>
	    <link href="http://fonts.googleapis.com/css?family=PT+Sans:400&subset=cyrillic" rel="stylesheet" type="text/css">
	</head>
	
	<body>
	
	    <div class="cats">
    		<div class="cat cat-keksik">Кексик</div>
    		<div class="cat cat-rudolf">Рудольф</div>
    		<div class="cat cat-snezhok">Снежок</div>
    		<div class="cat cat-adolf">Адольф</div>
	    </div>
	    
	</body>
</html>
...
body{
    padding:10px;
    font-family:'PT Sans', sans-serif;
}
.cats{
    position:relative;
    width:390px;
    padding:20px;
    margin:20px auto;
    text-align:center;
    box-shadow:0 0 3px #999;
}
.cats .cat{
    display: inline-block;
    width:100px;
    height:100px;
    margin:10px;
    padding:10px;
    text-align:center;
    color: #fff;
    background-repeat:no-repeat;
    background-position: 50% 80%;
    box-shadow:0 0 3px #999;
    border-radius:5px;
}
.cats .cat-keksik{
    background-color:#3498db;
    background-image:url('/assets/course13/cat_walk.png');
}
.cats .cat-rudolf{
    background-color:#e74c3c;
    background-image:url('/assets/course13/cat_grumpy.png');
}
.cats .cat-snezhok{
    background-color:#2ecc71;
    background-image:url('/assets/course66/cat_w.png');
}
.cats .cat-adolf{
    background-color:#e67e22;
    background-image:url('/assets/course66/cat_a.png');
}





color:#2980b9;		-------------- цвет шрифта
font-size:12px;		-------------- размер шрифта
border:1px solid green;	-------------- граница ячейки толщиной линии и цветом линии
line-height:16px;	-------------- высота строки
padding:25px;		-------------- внутренние отступы в ячейке
text-align:left/center;	-------------- выравнивание текста в ячейке по горизонтали лево/центр/право
font-style:italic; 	-------------- стиль текста курсивом
cursor:pointer;		-------------- меняется стиль курсора при наведении на блок (курсок в виде руки)
list-style-type:square;	-------------- стиль маркеров в списке - квадратные
background:#3498db;	-------------- цвет фона ячейки
list-style: none;	-------------- уберает маркеры в списках
margin-left:120px; (-120px)		------------- смещение по горизонтали +/- право/лево
background-image:url('/assets/course66/cat_w.png');	----------- фон блока берется как картинка по ссылке
font-weight:bold;	-------------- насыщенность текста - полужирный
text-decoration:line-through;	------------- оформление текста - перечеркнутый текст
font-weight:bold;	----------------- оформление текста - шрифт полужирный
font-style:italic;	----------------- оформление текста - шрифт курсив как <i>
font-size:0.8em;	----------------- оформление текста - доля от нормального размера



Еще одна задачка на специфичность [14/18]

Как вы уже догадались, самым главным механизмом для определения приоритетов стилей является специфичность. Поэтому давайте еще немного потренируемся работать с ней.

Рассмотрим пример: на полу в коробке сидит кот

<div id="floor"><span class="cat-in-box">Кексик</span></div>

Допустим в стилях существуют следующие определения:

span{
    background-color:#27ae60; /* Зеленый */
}
div span{
    background-color:#2980b9; /* Синий */
}
#floor .cat-in-box{
    background-color: #34495e; /* Мокрый асфальт */
}
.cat-in-box{ 
    background-color: #8e44ad; /* Фиолетовый */
}
#floor span{
    background-color: #c0392b; /* Красный */
}
div .cat-in-box{
    background-color: #e67e22; /* Оранжевый */
}

А теперь вопрос на засыпку: какого цвета будет коробка? Сначала сделайте предположение, а затем проверьте.



Расчет значения специфичности [15/18]

Вы вдоволь наигрались со специфичностью, а теперь пришло время изучить полные правила её вычисления.

Специфичность селектора разбивается на 4 группы — a, b, c, d:

    если стиль встроенный, т.е. определен как style="...", то а=1, иначе a=0;
    значение b равно количеству идентификаторов (тех, которые начинаются с #) в селекторе;
    значение c равно количеству классов, псевдоклассов и селекторов атрибутов;
    значение d равно количеству селекторов типов элементов и псевдо-элементов.

После этого полученное значение приводится к числу (обычно в десятичной системе счисления). Селектор, обладающий большим значением специфичности, обладает и большим приоритетом.

Посчитаем специфичность в нашем примере:
Селектор		a,b,c,d		Число
span			0,0,0,1		1
div .cat-in-box		0,0,1,1		11
#floor .cat-in-box	0,1,1,0		110
div span		0,0,0,2		2
.cat-in-box		0,0,1,0		10
#floor span		0,1,0,1		101

Остюда сразу видно, что в нашем примере самым приоритетным является селектор #floor .cat-in-box.


<head>			---------- может быть это стандартная ссылка
       <title>Наследуемые свойства</title>
       <meta charset="utf-8">
       <link href="http://fonts.googleapis.com/css?family=PT+Sans:400&subset=cyrillic" rel="stylesheet" type="text/css">
</head>





Главный текстовый тэг — span [1/16]

При оформлении текста с помощью css чаще всего используют тэг <span>. Он обозначает "просто текстовый блок". То есть особенного собственного смысла он не имеет. Также этот тэг никак не изменяет отображение текста.

Однако, дополнительный смысл данному тэгу добавляют с помощью классов. Например:

<span class="error"></span>
<span class="ok"></span>

А уже для класса с помощью css задают стили и тем самым изменяют оформление.




Свойство font-size: задаем размер шрифта [2/16]

Cвойство font-size задает размер шрифта.

Размер шрифта лучше всего задавать в em — относительной единице измерения. 1em обычно равен длине буквы M в данном шрифте.

Другие единицы измерения для задания размеров шрифта:

    Пиксели: 20px
    Пункты: 15pt
    Проценты: 80%

Пиксели и пункты — это абсолютные единицы измерения, а проценты — относительные.

Также размер шрифта можно задавать с помощью ключевых слов: small, large и т.д. Но их обычно не используют.
h2 {font-size: 1em;}
.bigger {font-size:1.5em}
.smaller {font-size:0.7em;}




Свойство font-weight: выделение жирным [3/16]

Жирность текста можно задавать с помощью свойства font-weight, которое имеет два значения:

    normal — обычное начертание;
    bold — жирное начертание.

На самом деле это свойство имеет много значений: bold, bolder, lighter, normal, 100, 200, 300, 400, 500, 600, 700, 800, 900. Эти значения задают степень жирности шрифта, от самого тонкого, до самого-самого жирного.

Но большинство браузеров всё равно умеют отображать только два варианта жирности: обычный и жирный. Поэтому и остальные значения свойства обычно не используют.
h1{
    font-size:1.5em;
    font-weight: normal;	---------------- делает заголовок не жирным
}

.bold {
    font-weight: bold;	------------------ делает блок с классом жирным
    }



Свойство font-style: курсив [4/16]

Начертание текста можно задавать с помощью свойства font-style. Его значения:
    normal — обычное начертание;
    italic — курсивное начертание.
Это свойство имеет и другие значения, но их почти не используют.
h2{
    font-size:1.2em;
    font-style: italic;		------------- делает заголовок курсивом
}

em {
    font-style: normal;		------------- делает курсивный текст (тэг <em>) не курсивным (нормальным)
    }
    
.italic {
    font-style: italic;		------------- делает блок текста (с классом) курсивом
    }




Свойство font-family: шрифт [5/16]

Задать семейство шрифта можно с помощью свойства font-family. Можно задавать конкретное название шрифта: "Times New Roman". А можно задавать желаемый тип шрифта, например:

    serif — шрифт с засечками;
    sans-serif — шрифт без засечек.

Есть и другие типы, но они используются реже.

Обычно в качестве значения свойства задают список шрифтов, перечисляя их через запятую. В начале списка располагают самый редкий шрифт, затем похожий, но более распространенный, а в самом конце списка — желаемый тип шрифта. Пример:

body{
font-family: "Verdana", "Arial", serif;
}
Браузер проходит по списку слева направо и использует первый найденный в системе шрифт.
h2{
    font-size:1.2em;
    font-family: "Tahoma";	----------- задан шрифт для заголовка
}

p {
    font-family: "Arial";	------------ задан шрифт для параграфа
    }



Свойство color: цвет текста [6/16]

Цвет текста задаётся с помощью свойства color. Значение цвета можно задавать разными способами:

    Шестнадцатеричным кодом, например #FF9900.
    Ключевым словом: red.
    В RGB-формате: rgb(255, 255, 0).

Чаще всего цвет задают в шестнадцатеричном формате.
h2{
    font-size:1.2em;
    color: #B94A48;
}

i {
    color: green;
    }
    
li {
    color: rgb(200, 200, 200);	-------------- крассный/зеленый/синий
    }



Свойство text-decoration: подчеркивание и другие эффекты [7/16]

Дополнительное оформление текста можно задать с помощью свойства text-decoration. Его значения:

    underline — подчеркивание;
    line-through — зачеркивание;
    overline — черта сверху;
    blink — мигание;
    none — убирает вышеперечисленные эффекты.

К тексту можно одновременно применить несколько эффектов, если перечислить значения через пробел.
.under {
    text-decoration: underline;		------------ текст подчеркнутый
    }
    
.over {
    text-decoration: overline;		------------ текст надчеркнутый
    }
    
.through {
    text-decoration: line-through;	------------ текст зачеркнутый
    }




Декоративное подчеркивание [8/16]

Вы, наверное, уже много раз видели красивое пунктирное подчеркивание. Его используют для оформления ссылок и других динамических элементов. Технология следующая:

    Убираем обычное подчеркивание с помощью text-decoration.
    Задаем нужный цвет текста с помощью color.
    Добавляем декоративное подчеркивание с помощью свойства border-bottom.

Также можно при наведении курсора скрывать такое подчеркивание с помощью псевдокласса :hover.
.dashed{
    text-decoration:none;	------------------ вот например сняли подчеркивани с активной ссылки
    color:#0088CC;		------------------ тут задали для ссылки жругой цыет шрифта
    border-bottom: 1px dashed #0088CC;		------------------- а тут сделали подчеркивание пунктирной (dashed) линией
}

.dashed:hover{
    border-bottom:none;
}




Задаем регистр символов с помощью text-transform [9/16]

С помощью css можно управлять даже регистром символов: делать буквы строчными или прописными. Делается это с помощью свойства text-transform. Его значения:

    lowercase — все строчные;
    uppercase — все прописные;
    capitalize — каждое слово начинается с прописной;
    none — отменяет изменение регистра.
h2{
    font-size:1.2em;
    text-transform: uppercase;		--------------- каждое слово блока выдает Заглавными буквами
}

.lower {
    text-transform: lowercase;		--------------- каждое слово блока выдает маленькими буквами
    }

.capital {
    text-transform: capitalize;		-------------- каждое слово блока начинается Заглавной буквой
    }




Управляем пробелами: white-space [10/16]

Как вы уже знаете, браузер игнорирует множественные пробелы и переносы строк в html-коде. Изменить это поведение можно с помощью тэга <pre>.

Однако, с помощью css управлять пробелами и переносами можно более гибко. За это отвечает свойство white-space, значения которого:

    nowrap — отображает весь текст одной строкой без переносов;
    pre — сохраняет пробелы и переносы как в исходном коде аналогично тэгу <pre>;
    pre-wrap — работает как значение pre, но добавляет автоматические переносы, если текст не помещается в контейнер;
    normal — режим по умолчанию.
h2{
    font-size:1.2em;
    white-space:pre-wrap;	----------------- равняет текст по ширине браузера
}

.nowrap {
    white-space:nowrap;		----------------- убирает переносы, текст вытягивается в длинну
    }
    
.like-pre {
    white-space:pre;		----------------- текст размещается точно как в коде написан 
    }



Горизонтальное выравнивание текста: text-align [11/16]

Выравнивание текста по горизонтали задается с помощью свойства text-align. Его вы уже использовали в курсе про таблицы. Значения свойства:

    left — выравнивание по левому краю;
    right — по правому краю;
    center — по центру;
    justify — по ширине.
h1{
    font-size:1.5em;
    text-align: center;		-------------------- разместил текст заголовка по центру
}

.right {
    text-align: right;		------------------- выровнял текст блока по правому краю 
    }
    
.justify {
    text-align: justify;	------------------ растянул текст блока по ширине
    }





Вертикальное выравнивание: vertical-align [12/16]

Выравниванием текста по вертикали можно управлять с помощью свойства vertical-align. Его действие хорошо заметно в ячейках таблицы. Внутри текстовой строки "работа" этого свойства заметна, когда в ней есть фрагменты разного размера.

У данного свойства много значений, но самые часто используемые:

    top — выравнивание по верхнему краю строки;
    middle — по середине;
    bottom — по нижнему краю;
    baseline — по базовой линии (значение по умолчанию).
li{
    white-space:nowrap;		------------------ задали списку чтобы блоки текста не переносились
    background:#f5f5f5;		------------------ задали фон для списков
    margin-bottom:10px;		------------------ задали отступ вниз между строками списка
}
small{
    font-size:0.5em;		------------------ задали размер шрифта в половину от обычного (для наглядности)
    color:#666;
}

.top {
    vertical-align: top;	----------------- задали блоку текста выравнивание по верхнему краю
    }
    
.middle {
    vertical-align: middle;	----------------- задали блоку текста выравнивание по центру вертикали
    }
    
.bottom {
    vertical-align: bottom;	------------------ задали блоку текста выравнивание по низу
    }



Верхние и нижние индексы на css [13/16]

С помощью css можно имитировать тэги <sub> и <sup>, которые применяются для создания нижних и верхних индексов. Делается это так:

    Используем свойство vertical-align со значением sub или super.
    Немного уменьшаем размер шрифта с помощью font-size.
h2{
    font-size:1.2em;   
}

.sub{
   vertical-align:sub;		------------------- спустили текс в нижний индекс (субтитры)
   font-size: 0.7em;		------------------- для наглядности уменьшили размер шрифта
}

.sup{
    vertical-align:super;	----------------- подняли текст в верхние индексы (саппы)
    font-size: 0.7em;		----------------- для наглядности уменьшили размер шрифта
}




Свойство line-height: управляем высотой строки [14/16]

Высотой строки или, правильнее, межстрочным интервалом можно управлять с помощью свойства line-height. Значение этого свойства можно задавать следующими способами:

    Множителем, например 1.5, 2.
    В процентах: 150%.
    С помощью любых других единиц измерения css: 12px, 2em.
    Ключевым словом normal, которое задает автоматический расчет высоты строки.

Предпочтительнее задавать межстрочный интервал либо множителем, либо в относительных единицах измерения.
span{
    background:#eee;		-------------------- задали куску текста цвет фона
    background:rgba(210, 210, 210, 0.3);
}


.low{
    line-height: 10px;		------------------- задали куску текста межстрочный интервал (маленький) - в пикселях неудобно
}


.high{
    line-height: 1.5;		----------------- задали куску текста местрочнфй интервал (большой) 1,5=150% и т.д. - лучше всего 1,5/150% или в em.
}




Вертикальный ритм текста [15/16]

В веб-дизайне существует понятие "вертикальный ритм текста". Оно достаточно сложное и мы не будем глубоко в него вдаваться. Отметим лишь, что хороший вертикальный ритм улучшает восприятие текста.

Чтобы сохранить вертикальный ритм и хорошую читабельность текста при любом размере шрифта, нужно задавать размеры шрифта, межстрочный интервал и вертикальные отступы между заголовками и абзацами в относительных единицах.

Тогда, как бы пользователь ни изменял размер шрифта, ваш текст останется читабельным и удобным для восприятия. В этом задании вы потренируетесь использовать относительные единицы измерения.
<a http://pixelgene.ru/articles/vertical-rhythm.html/>	---------------- статья о вертикальном ритме текста

body{
    font-size:16px;	---------------- мы задали размер шрифта для всего боди
    line-height:1.3;	---------------- мы задали межстрочный интервал для всего боди
}
h1{
    font-size:1.3em;	---------------- для заголовка мы увеличили шрифт на к-т 1,3 от боди
    margin-top:0.7em;	---------------- для заголовка мы установили верхний интервал в к-т 0,7 от боди (от 1,3)
}
p{
    margin-top:0.5em;	---------------- для параграфа мы установили верхний отступ в к-т 0,5 от боди (от 1,3)
    margin-bottom:0.5em;	--------- для параграфа мы установили нижний отступ в к-т 0,5 от боди (от 1,3)
}



JAVASCRIPT.

    <body>
        <h1>Подключение скриптов</h1>
        
        <p id="blinking"> Подключение скриптов можно выполнять разными способами. Один из способов заключается в описании скриптов прямо внутри HTML-страницы.</p>
        


        <script>     -------------------->>> подключение скрипта (поведение на странице) написанного на языке javascript
						подключается с помощью <script> </>

            var p = document.getElementById('blinking');
            p.style.fontStyle = 'italic';
            setInterval(function(){
                if (p.style.fontStyle == 'normal') {
                    p.style.fontStyle = 'italic';
                } else {
                    p.style.fontStyle = 'normal';
                }
            }, 1000);
        </script>
    
    </body>



    <body>
        <h1>Подключение скриптов</h1>
        <p id="blinking"> </p>  ----->>> Подключение скриптов можно выполнять разными способами. Один из способов заключается в подключении внешних скриптов
        
        <script src="/assets/course2/scripts1.js"> </script> ----- >> таким образом подключается скрипт из внешнего файла
        
    </body>
