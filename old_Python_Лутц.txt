========================
Виртуальная машина Python - PVM - запускает байткод (файл pyc)

""" Метод перезагрузки импортированого модуля"""
>>> from imp import reload 	# В версии 3.0 требуется загрузить функцию
>>> reload(script1)			# перезапускает файл не выходя из интерпритатора


""" Метод запусктить модуль к исполнению"""
>>> exec(open(‘script1.py’).read())	
# Один из методов запустить файл (модуль) к исполнению


>>> sys.path[:],
(['/home/ryndin/data/work/virtualenvs/studentsdb/src/studentsdb', 
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python27.zip',
 '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7', 
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/plat-linux2',
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-tk', 
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-old', 
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-dynload',
 '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7', 
'/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/plat-linux2',
 '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/lib-tk', 
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages'],)


"""отладчик - глава 35"""
pdb()
import pdb; pdb.sat_trace()


""" Импорт модуля math"""
>>> import math
>>> math.pi
3.1415926535897931
>>> math.sqrt(85)
9.2195444572928871


""" Импорт модуля генерации случайных чисел"""
>>> import random
>>> random.random()
0.59268735266273953
>>> random.choice([1, 2, 3, 4])
1


>>> S[-1]		# Последний элемент в S
‘m’
>>> S[len(S)-1]		# Отрицательная индексация, более сложный способ
‘m’


""" Оператор поиска в элемента в строке"""
>>> S="SPAM"
>>> S.find("P")
1


""" Оператор замены элемента в строке"""
>>> S="SPAM"
>>> S=S.replace("M", "NZ")
>>> S
'SPANZ'


""" Оператор разбития в список по точке"""
>>> line='aaa,sss,ddd,fff'
>>> line=line.split(',')
>>> line
['aaa', 'sss', 'ddd', 'fff']


>>> dir(line)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']


==========
Списки
==========
>>> line			// type "list" - список это последовательность, изменяемая
['aaa', 'sss', 'ddd', 'fff']

>>> line.append("ggg")		# вставка элемента
>>> line
['aaa', 'sss', 'ddd', 'fff', 'ggg']

>>> line.extend("ddd")		# вставка по элементно
>>> line
['aaa', 'sss', 'ddd', 'fff', 'ggg', 'd', 'd', 'd']

>>> line.remove("ddd")		# удаление элемента по имени/значению элемента
>>> line
['aaa', 'sss', 'fff', 'ggg', 'd', 'd', 'd']

>>> line.sort('name')	# соритровка по имени по возрастанию
>>> line.reverse()		# например, после сортировки, дает в обратном прядке
>>> line
['aaa', 'd', 'd', 'd', 'fff', 'ggg', 'sss']

>>> line.pop()			# удаление последнего элемента или по значению в списке
'sss'
>>> line
['aaa', 'd', 'd', 'd', 'fff', 'ggg']

>>> line.pop()
'ggg'

>>> line
['aaa', 'd', 'd', 'd', 'fff']

>>> insort() 		// вставка по индексу положения в списке

>>> help(line.pop)	// оператор помощи/описания логики оператора pop или др.


====================
2 равноценных метода подстановки - генераторы строк
====================
>>> ‘%s, eggs, and %s’ % (‘spam’, ‘SPAM!’)
# Выражение (во всех версиях)

‘spam, eggs, and SPAM!’
>>> ‘{0}, eggs, and {1}’.format(‘spam’, ‘SPAM!’) # Метод (2.6, 3.0)


====================
Вложенные списки в Гнераторы списков
====================
>>> m=[[1,2,3],[4,5,6],[7,8,9]]		// вложенный список
>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

>>> n=[x[1] for x in y]		// генератор списка по столбцам списков
>>> n
[2, 5, 8]

>>> n=[x[1] for x in y if x[1]%2==0]		// с условием четности значений
>>> n
[2, 8]

>>> doubles = [c * 2 for c in 'spam'] 	// Дублирование символов в строке
>>> doubles
[‘ss’, ‘pp’, ‘aa’, ‘mm’]


>>> m
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

>>> n=[item*2 for item in m]		// удвоение позиций списков
>>> n
[[1, 2, 3, 1, 2, 3], [4, 5, 6, 4, 5, 6], [7, 8, 9, 7, 8, 9]]


>>> n=list(map(sum, m)) // создало список просумировав вложенные Списки Списка m 
						// это все функции
>>> n
[6, 15, 24]


=================
наглядный пример map()

>>> values=[2,4,9,16,25]
>>> import math
>>> res=[]
>>> for item in values: res.append(math.sqrt(item))		// наполнение корнями квадратными
... 		// генератор
>>> res				// пример наполнения списка через генератор списка (мат.функция)
[1.4142135623730951, 2.0, 3.0, 4.0, 5.0]
>>> 

>>> map(math.sqrt, values)		// пример наполнения списка через меппинг (мат.функция)
		// то есть применить первфй аргуметь Последовательно по второму Объекту
[1.4142135623730951, 2.0, 3.0, 4.0, 5.0] 
=================


================
Словари - это ! не Последовательности - это отображения
================
Это Коллекции объектов, к которым доступ оп Ключу!
>>> D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
>>> D
{'food': 'Spam', 'color': 'pink', 'quantity': 4}

>>> D['quantity']+=1		// значение изменили. отображение элементов произвольное
>>> D
{'food': 'Spam', 'color': 'pink', 'quantity': 5}

>>> D={}			// Создание пустого Словаря и наполнение Словаря
>>> D
{}
>>> D['name']='Yurii'		// Наполнение Словаря
>>> D['job']='dev'
>>> D['age']=40
>>> D
{'age': 40, 'job': 'dev', 'name': 'Yurii'}


>>> massiv={'name':{'first':'Ryndin', 'last':'Yurii'},		// Создание Словаря Разнотипного
...         'job':['ing', 'dev'],
...         'age':40}
>>> massiv
{'age': 40, 'job': ['ing', 'dev'], 'name': {'last': 'Yurii', 'first': 'Ryndin'}}

>>> massiv['job']+='eco'	// Добавление строки в элемент Словаря - Как Отдельные элементы	
>>> massiv
{'age': 40, 'job': ['ing', 'dev', 'e', 'c', 'o'], 'name': {'last': 'Yurii', 'first': 'Ryndin'}}

>>> massiv['job'].append('eco') 	// Добавление в Элемент Словаря - как Отдельный Элемент
>>> massiv
{'age': 40, 'job': ['ing', 'dev', 'e', 'c', 'o', 'eco'], 'name': {'last': 'Yurii', 'first': 'Ryndin'}}

>>> massiv['job'].remove('e') 	// Удаление элемента Элемента Словаря
>>> massiv
{'age': 40, 'job': ['ing', 'dev', 'c', 'o', 'eco'], 'name': {'last': 'Yurii', 'first': 'Ryndin'}}


>>> dir(massiv)			// методы Словаря
['__class__', '__cmp__', '__contains__', '__delattr__', '__delitem__', '__doc__', '__eq__',
 '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__',
 '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__',
 '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__',
 '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'has_key', 'items', 'iteritems',
 'iterkeys', 'itervalues', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values',
 'viewitems', 'viewkeys', 'viewvalues']

>>> dir(massiv['job'])	// Методы Элемента Словаря
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__',
 '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', 
'__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__',
 '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__',
 '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index',
 'insert', 'pop', 'remove', 'reverse', 'sort']


=====================
Словари и Ключи / цикл for
=====================
>>> D={'a':1, 's':2, 'd':3}
>>> D
{'a': 1, 's': 2, 'd': 3}

>>> KS=list(D.keys())		// создание Списка(фу) из ключей Словаря(метод)
>>> KS
['a', 's', 'd']

>>> KS.sort()		// Сортировка Списка (меняет Список при выполнении)
>>> KS
['a', 'd', 's']

>>> for key in KS:
...     print (key, '=>>', D[key])	
		// 1) доступ к Списку КС; 	// 2) доступ к элементу Словаря по Ключу
... 
('a', '=>>', 1)
('d', '=>>', 3)
('s', '=>>', 2)

>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

>>> for key in sorted(D):	
		// ОФИГЕННО ! Новая функция sorted() делает то же но Код Короче !
		// Сортирует по значениям ключей в Словаре !
	print(key, ‘=>>’, D[key])
a =>> 1
b =>> 2
c =>> 3


=====================
Цикл for это оператор работы с Последовательностями также (а не только Словарями)
=====================
>>> for c in 'spam':
    print(c.upper())


====================
Цикл While родственник for но более уневерсален,
работает с Повторениями Выполнений (Генерироваными Последовательностями)
====================
>>> x = 4
>>> while x > 0:
        print('spam!' * x)
        x -= 1
spam!spam!spam!spam!
spam!spam!spam!
spam!spam!
spam!


=================
iter /+/ next - Объект (D) способен к итерации, если имеет встроенный оператор __iter__
=================
>>> squares=[x**2 for x in[1,2,3,4,5]]

>>> dir(squares)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', 
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',
'__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__',
'__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__',
 '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',
 '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend',
 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

>>> squares
[1, 4, 9, 16, 25]


==================
Оператор if дает проверку наличия элементов в Словарях"""
==================
>>> D
{'a': 1, 's': 2, 'd': 3}

>>> D['e']=99		// добавлен элемент в Словарь
>>> D
{'a': 1, 's': 2, 'e': 99, 'd': 3}

>>> D['f']		// Нет Элемента в Словаре
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'f'

>>> 'f' in D
False
>>> if 'f' not in D:
...     print('missing')
... 
missing

>>> if 'a' not in D:	// Есть Элемент в Словаре
...     print('missing')
... else:
...     print('is there')
... 
is there


=====================
Еще метод проверки наличия Элемента в Словаре/Списке - get()
=====================
>>> D
{'a': 1, 's': 2, 'd': 3}

>>> test=D.get('x', "netu")
>>> test
'netu'			// дает строку если элемента по ключу в словаре нет

>>> test=D.get('a', "netu")
>>> test
1				// дает значение по ключу из словаря, так как он есть

или вот так тоже можно:
>>> test=D['x'] if 'x' in D else 'netu' 
>>> test
'netu'

>>> test=D['a'] if 'a' in D else 'netu' 
>>> test
1


===================
Кортежи - последовательности как и Списки, но неизменяемы как Строки - (,)
===================
>>> T=(1,2,3,4,5)
>>> T
(1, 2, 3, 4, 5)

>>> T[2]		// Выборка элемента кортежи (тьюпла)
3

>>> T[2]=10		// менять Значение элемента кортежа Нельзя
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> len(T)
5
>>> R=T+(6,7,8)
>>> R
(1, 2, 3, 4, 5, 6, 7, 8)	// Создается новый Кортеж путем конкатинации

>>> T.index(3)		// Оператор index() выдает Индекс элемента по Значению
2

>>> T.count(4)		// Оператор count() выдает Сколько таких значений в Кортеже
1

>>> dir(T)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__',
 '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__',
 '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__',
 '__sizeof__', '__str__', '__subclasshook__', 'count', 'index']
		//	# 1) Кортежи имею 2 метода count и index
			# 2) Кортежи способны к итерациям __iter__


>>> T = (‘spam’, 3.0, [11, 22, 33])
		// Кортежи способны хранить Разные элементы, но неизменяемы

>>> T[1]
3.0
>>> T[2][1]		// такой вызов Кортежа возможен - элемент Списка в Кортеже
22


==============
Файлы
==============
>>> f=open('test.txt', 'w')		// Создали новый Файл с расширением и в режиме Записи
>>> f.write('Hello\n')		// Закинули в Файл Данные
>>> f.write('World\n')	
>>> f.close()		// Сохранили и Закрыли Файл

>>> open('test.txt')
<open file 'test.txt', mode 'r' at 0x7fa35846c540>		// по умолчанию мод открытия 'r'
>>> f=open('test.txt')		// затем надо Переменной присвоить Метод открытия Файла
>>> text=f.read()		
		// затем другой переменной - метод Чтения открытого Файла / Всегда читается в Переменную в виде Строки !!

>>> text
'Hello\nWorld\n'
>>> print(text)		// Затем например Печать
Hello
World

>>> dir(text)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__',
 '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__',
 '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', 
'__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split',
'_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith',
 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace',
 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines',
 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 
		// - все доступные методы для Строки из открытого Файла

>>> text.split()		// разделение Строки на элементы Списка
['Hello', 'World']
>>> text
'Hello\nWorld\n'		// В таком виде и выглядит Строка из Файла для Сценариев

>>> f=open('test.txt').read()	// Можно последовательно выполнить сразу 2 Функции для Файла
>>> f
'Hello\nWorld\n'
>>> print(f)
Hello
World


====================
Множества - как Словари но без Ключей
====================
Python 2.7.9 (default, Apr  9 2015, 19:58:11) 
[GCC 4.8.2] on linux2
>>> X=set('spam')
>>> X
set(['a', 'p', 's', 'm'])		// Одинаково Множиство сохраняется как set([]), как бы не задавалось

>>> Y={'h', 'a', 'm'}		// Создание как {}
>>> Y
set(['a', 'h', 'm'])		// Все равно set([])

>>> X & Y		// Пересечение (общие элементы)
set(['a', 'm'])

>>> X | Y		// Объединение (конкатинация)
set(['a', 'p', 's', 'h', 'm'])

>>> X - Y		// Разность
set(['p', 's'])

>>> {x**2 for x in [1,2,3,4,5]}		// Создание как {}
set([16, 1, 4, 25, 9])



=============
Числа
=============
Создание точного числа (без округлений)
-----------------------
>>> import decimal
>>> d=decimal.Decimal('0.0000')
>>> d=d+2
>>> d
Decimal('2.0000')

>>> d=d*3/45
>>> d
Decimal('0.1333333333333333333333333333')


Рациональное число (числитель/знаминатель) - Десятичное число - Самое Точное в виде Дроби
-----------------------
>>> from fractions import Fraction
>>> f=Fraction(2,3)
>>> f
Fraction(2, 3)
>>> f=f+1
>>> f
Fraction(5, 3)
>>> f=f+Fraction(1,2)
>>> f
Fraction(13, 6)		// Все время остается в виде Дроби

>>> Fraction(‘.25’)		// Конвертация Вещественого числа в Дробное
Fraction(1, 4)
>>> Fraction(‘1.25’)
Fraction(5, 4)

>>> Fraction(‘.25’) + Fraction(‘1.25’)
Fraction(3, 2)		// Самая точная Логика для Числа


True / False это как 1/0		// Булевое
------------------------
только в иде логических значений
А также есть None, обычно используется как пустое значение при инициализации Объектов


=================
Простая проверка Типа объекта
=================
>>> L=[1,2,3,4,5]
>>> if isinstance(L,list):
...     print('yes')
... else:
...     print('no')
... 
yes



=================
Инициализация инстансов Классов для возможности рачетов
=================
class Worker:

	def __init__(self, name, pay):		// Инициализация при создании - для Инстанса		
		self.name = name
		self.pay = pay

	def lastName(self):
		return self.name.split()[-1]		// Разбить строку по символам пробела	

	def giveRaise(self, percent):		// Обновить сумму выплат		
		self.pay *= (1.0 + percent)

>>> bob = Worker(‘Bob Smith’, 50000)	
		//  Создаются два экземпляра и для каждого // Инстансы (Наследники)
>>> sue = Worker(‘Sue Jones’, 60000)
		// определяется имя и сумма выплат

>>> bob.lastName()		// Функция инстанса 
‘Smith’
>>> sue.lastName()
‘Jones’

>>> sue.giveRaise(.10)		// Задаем параметр для функции Инстанса

>>> sue.pay		// Вывод результата функции Инстанса (расчет оплаты с премией)
66000.0


==================
Инициация и работа с Переменными
==================
На практике это означает, что перед тем как к счетчикам можно будет прибавлять некоторые
значения, их необходимо инициализировать нулевым значением; прежде чем к спискам можно будет
добавлять новые элементы, их необходимо инициализировать пустыми списками, и так далее.



================
Распространенные Операторы Чисел	math
================
>>> import math
>>> math.pi, math.e
(3.1415926535897931, 2.7182818284590451)
		// Распространенные константы

>>> math.sin(2 * math.pi / 180)
0.034899496702500969
		// Синус, тангенс, косинус

>>> math.sqrt(144), math.sqrt(2)
(12.0, 1.4142135623730951)
		// Квадратный корень

>>> pow(2, 4), 2 ** 4
(16, 16) 
		// Возведение в степень

>>> abs(-42.0), sum((1, 2, 3, 4))
(42.0, 10)
		// Абсолютное значение, сумма

>>> min(3, 1, 2, 4), max(3, 1, 2, 4)
(1, 4)
		// Минимум, максимум

>>> math.floor(2.567), math.floor(-2.567)
(2, -3)
		// Округление Числа (до ближайшего наименьшего целого)

>>> math.trunc(2.567), math.trunc(-2.567)
(2, -2)
		// Усечение (отбрасывание дробной части)



================
Генератор Случайных Выражений
================
>>> import random
>>> random.random()		// по умолчанию числа от 0 до 1
0.44694718823781876

>>> random.random()
0.28970426439292829

>>> random.randint(1, 10)		// выводит число в заданном диапозоне
5
>>> random.randint(1, 10)
4

>>> random.choice([‘Life of Brian’, ‘Holy Grail’, ‘Meaning of Life’])
		// выводит Случайное выражение
‘Life of Brian’
>>> random.choice([‘Life of Brian’, ‘Holy Grail’, ‘Meaning of Life’])
‘Holy Grail’


================
Методы создания Точних вычислений
================
>>> 0.1 + 0.1 + 0.1 - 0.3		// Должен быть получен ноль (близко, но не точно)
5.5511151231257827e-17

>>> from fractions import Fraction		// Дробные значения
>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
Fraction(0, 1)

>>> from decimal import Decimal		// Декларируемая точность
>>> Decimal(‘0.1’) + Decimal(‘0.1’) + Decimal(‘0.1’) - Decimal(‘0.3’)
Decimal(‘0.0’)

>>> 1 / 3
		// В Python 2.6 используйте знаменатель 3.0, чтобы выполнить операцию истинного деления
0.33333333333333331

>>> Fraction(1, 3)
Fraction(1, 3)


Точное представление
--------------------
>>> import decimal
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal(1) / decimal.Decimal(3)
Decimal(‘0.33’)


==============
Множества
==============
новый тип коллекций – множество, не-упорядоченная коллекция уникальных и  неизменяемых объектов, 
которая поддерживает операции, соответствующие математической теории множеств.

>>> x = set('abcde')
>>> y = set('bdxyz')

>>> x
set(['a', 'c', 'b', 'e', 'd'])

>>> 'e' in x
True
		// Проверка вхождения в множество

>>> x – y		// Разность множеств
set([‘a’, ‘c’, ‘e’])

>>> x | y		// Объединение множеств
set([‘a’, ‘c’, ‘b’, ‘e’, ‘d’, ‘y’, ‘x’, ‘z’])

>>> x & y
set([‘b’, ‘d’])		// Пересечение множеств

>>> x ^ y		// Симметрическая разность (XOR)
set(['a', 'c', 'e', 'y', 'x', 'z'])

>>> x > y, x < y 		// Надмножество, подмножество
(False, False)

>>> S = {‘s’, ‘p’, ‘a’, ‘m’}
>>> S.add(‘alot’)		// Добавление элемента Множества
>>> S
{‘a’, ‘p’, ‘s’, ‘m’, ‘alot’}

>>> a={}
>>> type(a)
<type 'dict'>		// Надо помнить, что пустой словарь имеет тип Словарь

>>> b=set()
>>> type(b)
<type 'set'>		
		// надо помнить. что пустое множество имеет тип Множество (при всех сходствах со Словарем)


>>> {1, 2, 3}.union([3, 4])		// такой вот синтаксис к Множествам
{1, 2, 3, 4}

>>> {1, 2, 3}.union({3, 4})
{1, 2, 3, 4} 


===================
Генераторы Множеств
===================
>>> {x ** 2 for x in [1, 2, 3, 4]}
{16, 1, 4, 9}	или   set[(16, 1, 4, 9)]

>>> {x for x in ‘spam’}
{‘a’, ‘p’, ‘s’, ‘m’}


===================
Удаление дуюлирующихся элементов в Списке:
===================
1) перевести Список во Множемтво (дубли удаляются),
2) Перевести Множество в Список

>>> L=[1,2,3,4,5,4,3,2,1]
>>> L
[1, 2, 3, 4, 5, 4, 3, 2, 1]
>>> L=list(set(L))		
		// Список переводим в Множество и опять возвращаем Список
>>> L
[1, 2, 3, 4, 5]


=================
Практика Множеств
=================
>>> engineers = {‘bob’, ‘sue’, ‘ann’, ‘vic’}
>>> managers = {‘tom’, ‘sue’}

>>> ‘bob’ in engineers
True # bob – инженер?

>>> engineers & managers
{‘sue’} # Кто одновременно является
# инженером и менеджером?

>>> engineers | managers
# Все сотрудники из обеих категорий
{‘vic’, ‘sue’, ‘tom’, ‘bob’, ‘ann’}

>>> engineers – managers
{‘vic’, ‘bob’, ‘ann’} # Инженеры, не являющиеся менеджерами

>>> managers – engineers
{‘tom’} # Менеджеры, не являющиеся инженерами

>>> engineers > managers
False # Все менеджеры являются инженерами?
# (надмножество)

>>> {‘bob’, ‘sue’} < engineers # Оба сотрудника - инженеры? (подмножество)
True

>>> (managers | engineers) > managers # Множество всех сотрудников является
True
# надмножеством менеджеров?

>>> managers ^ engineers
{‘vic’, ‘bob’, ‘ann’, ‘tom’}
# Сотрудники, принадлежащие к какой-то одной категории

 
""" bool True False 1/0 """
>>> type(True)
<type 'bool'>
>>> isinstance(True,int)
True

>>> True==1
True
>>> True is 1
False

>>> True+4
5
>>> True+False
1
>>> True*False
0

Python + NumPy	+ SciPy # Мощный Математический инструмент


""" Динамическая Типизация """ + """ Полиморфизм """
Переменная - это ссылка на объект


""" Списки. их объекты и ссылки """
L1=L2=[1,2,3,4]	# 2 ссылки на 1 объект
L1[0]=10	# меняет объект, 2 ссылки остаются

L3=L1[:] # копирование объета / создается новый объект со ссылкой L3


# Копирование Словарей / Копирование срезом для Словарей не работает
import copy
X = copy.copy(Y)
# Создание “поверхностной” копии любого объекта Y
X = copy.deepcopy(Y) # Создание полной копии: копируются все вложенные части


>>> L
[1, 2, 3]
>>> M=[1,2,3]		# Созданы 2 разных объекта но с одинаковыми значениям

>>> L==M		# Проверка на Одинаковость Значения объекта(тру)
True
>>> L is M		# Проверка на Одинаковость Объекта (фалс) 
False

""" Модуль Посмотреть количество Ссылок на Объект """
>>> import sys
>>> sys.getrefcount(X)
837


""" СТРОКИ - большая тема """  # строки - неизменяемые последовательности
>>> S='abracadabra manager'
>>> S
'abracadabra manager'

>>> S.find('ma')	# показывает по какому Индексу нашел Последовательность
12

>>> len(S)		# Длинна последовательности (строки)
19

>>> A=S+' //  '+S
>>> A
'abracadabra manager //  abracadabra manager'	# Конкатинация Строк

>>> A=S*3 + ' // ' + S
>>> A
'abracadabra managerabracadabra managerabracadabra manager // abracadabra manager'
# Повторение и Конкатинация Строки

>>> S
'abracadabra manager'
>>> A=S[2:9]		# Срез (Слайс) Строки
>>> A
'racadab'

>>> A=" is // %s // " %(S[2:9])		# Форматирование строки (Срез и Вставка из Строки)
>>> A
' is // racadab // '

# Новый Вариант Форматирования Строки
>>> A=" is // {0} // {1} ".format(S[2:9], "AAA") # Форматирование строки (Срез и Вставка из Строки)
>>> A
' is // racadab // AAA '

>>> S
' abracadabra manager '
>>> A=S.strip()		# Команда Уберает крайние Пробелы (перед и зад)
>>> A
'abracadabra manager'


>>> A=S.rstrip()	# Команда Удаление только Конечных Пробелов
>>> A
' abracadabra manager'

>>> A=S.replace('ab', 'xxx')	# Замена Элементов последовательности (Строки)
>>> A
' xxxracadxxxra manager '

>>> A=S.replace('ab', 'xxx').strip()	# Одновременное выполнение Двух операторов
>>> A
'xxxracadxxxra manager'

>>> S
' abracadabra manager '
>>> A=S.split(" ")		# Создание (Разбитие) Списка из Строки по Указанному Символу (" ")
>>> A
['', 'abracadabra', 'manager', '']

>>> A
['', 'abracadabra', 'manager', '']
>>> Q="".join(A)+" "		# Сборка Строки из 2х Строк и Списка(команда .join(LIST))
>>> Q
'abracadabramanager '


>>> S
' abracadabra manager '
>>> for item in S: print item	# Циклический обход по Строке (Списку)(for) и Выполенение Принта
... 
 
a
b
r
a
c
a
d
a
b
r
a
 
m
a
n
a
g
e
r
 
""" Обратный \Слеш в Строках """
>>> ‘knight\’s’, “knight\”s”
(“knight’s”, ‘knight”s’)


>>> s = "a\nb\tc"
>>> s
'a\nb\tc'		# \n - перенос строки 	\t - табулирование
>>> print s
a
b	c


>>> s = "a\nb\tc aaa\v  \\ "	# \v - вертикальная табуляция	\\ - оставляет по тексту 1 слеш (\) 
>>> print s
a
b	c aaa
               \ 

""" Отключение Экранирования Символов """
myfile = open(‘C:\new\text.dat’, ‘w’)	# файл не откроет - так так применит экранирование к символам

# Надо Так - 2 Варианта:
myfile = open(r’C:\new\text.dat’, ‘w’)	# "r" Отключает Экраинирование

myfile = open(‘C:\\new\\text.dat’, ‘w’) # Оставляет один символ Слеша (\)

>>> E=r"C:\home\data\work\test.txt"
>>> E
'C:\\home\\data\\work\\test.txt'	# Сам Интерпретатор ставит \\ значит и Я так Буду.
>>> print E
C:\home\data\work\test.txt		# Все Норм


""" Многострочные Блоки Текста / Кода """
>>> E=""" This is very
... comfotoble hotel 
... at the ocen """
>>> E
' This is very\ncomfotoble hotel \nat the ocen '	# Раставляет Экранированные Методы

>>> print E		# Все ОК при печати
 This is very
comfotoble hotel 
at the ocen 

""" Упражнения со Строками """
>>> print ("--"*20)
----------------------------------------

>>> print("abc"+"9")
abc9
>>> print("abc"+str(9))
abc9


>>> S
'vilage'
>>> for item in S: print(item)+'   ',	# Цикл(for) и Поиск(in)
... 
v    i    l    a    g    e  


>>> "spaz" in "spazmolgator"	# логика поиска в Строке
True

>>> S = ‘spam’		# Слайс / Срез
>>> S[0], S[-2] 	# Индексация от начала или от конца
(‘s’, ‘a’)

>>> S[1:3], S[1:], S[:-1] # Получение среза: извлечение подстроки
(‘pa’, ‘pam’, ‘spa’)


>>> S="1234123412341234"	# Поверхностная Копия Объекта с Шагом
>>> A=S[::4]
>>> A
'1111'

>>> S="1234123412341234"	# Поверхн Копия Объекта в Обратной последовательности 
>>> A=S[::-1]
>>> A
'4321432143214321'


>>> ‘spam’[1:3] 		# Синтаксис извлечения среза
‘pa’
>>> ‘spam’[slice(1, 3)] 	# используется Объект среза
‘pa’
>>> ‘spam’[::-1]
‘maps’
>>> ‘spam’[slice(None, None, -1)]	# Метод Среза (Копия) в Реверсе
‘maps’


""" Преобразование Числа в Строку и Обратно """
>>> int(“42”), str(42) 	# Преобразование из/в строки
(42, ‘42’)
>>> repr(42),		# Преобразование в строку, как если бы она была
‘42’			# литералом в программном коде

>>> print(str("spam"), repr("spam"))
('spam', "'spam'")	# НО !!!

""" Код Символов в кодировке ASCII """
>>> ord(‘s’)
115
>>> chr(115)
‘s’

>>> chr(ord("l")+1)	# Вычесление Следующего Символа по Алфавиту
'm'


object.method(arguments)	# Конструкция общего типа работы Интерпритатора



>>> A="xxxxxSPAMxxxxxxQ"		# начальная Строка
	
>>> len_SPAM=len("SPAM")		# Длинна Элемента
>>> where_SPAM=A.find("SPAM")		# № начала позиции Элемента

>>> B=A[0:where_SPAM]+"BBB"+A[(where_SPAM+len_SPAM):]	# Применяет Значения для формирования Строки
>>> B
'xxxxxBBBxxxxxxQ'



""" Еще раз join() """
>>> S = ‘spammy’
>>> L = list(S)
>>> L
[‘s’, ‘p’, ‘a’, ‘m’, ‘m’, ‘y’]
>>> L[3] = ‘x’ 			# Этот прием допустим для списков, но не для строк
>>> L[4] = ‘x’

>>> L
[‘s’, ‘p’, ‘a’, ‘x’, ‘x’, ‘y’]

>>> S = ‘’.join(L)		# "" это указан метод разделения между Элементами при формировании Строки
>>> S
‘spaxxy’

>>> A="XXX__".join(["asd", "qwe", "rty", "poi"])	# Задан метод Разделения при Джоин Строки
>>> A
'asdXXX__qweXXX__rtyXXX__poi'


""" Еще раз split() """
>>> line = ‘aaa bbb ccc’
>>> cols = line.split()
>>> cols
[‘aaa’, ‘bbb’, ‘ccc’]		# Создается Список из элементов Строки по Сплиту(Точке разрыва)


""" upper()   strip() // Строки """
>>> A="I am a very\n strong gay \t and I am brave!  \n"
>>> A
'I am a very\n strong gay \t and I am brave!\n'

>>> B=A.upper().strip()		# Команды Больших букв и Убрать последний символ пустой 				строки/ и экранитования
>>> B
'I AM A VERY\n STRONG GAY \t AND I AM BRAVE!'


""" endswith()  startswith() // Строки """
>>> B
'I AM A VERY\n STRONG GAY \t AND I AM BRAVE!'

>>> C=B.startswith("I"),B.endswith("E!") 	# Проверка наличия Подстроки в указанном месте
>>> C
(True, True)
>>> sum(C)		# Интерестно, что вывод С это список булевых значений потому сум(1,1)=2
2


>>> B
'I AM A VERY\n STRONG GAY \t AND I AM BRAVE!'
>>> "AM" in B		# Проверка наличия Подсткок методом in()
True
>>> "AM" and "ST" in B
True
>>> "AM" and "STO" in B
False


""" Еще раз Фрматирование строк """
>>> "This is %d crazy %s" % (2, "dogs")
'This is 2 crazy dogs'


>>> x=1.23456789
>>> x
1.23456789
>>> " %d   %f   %s   %e   " % (x,x,x,x)
' 1   1.234568   1.23456789   1.234568e+00   '	# Нравятся %f  %s   для чисел


vars()		""" Выводит все Переменные имеющие значения в Данный момент""" 


>>> message=""" I am  %(first_name)s  %(last_name)s  and me  %(age)s ears """
>>> person={"first_name":"Ryndin", "last_name":"Yurii", "age":40}
>>> print message % person
I am  Ryndin  Yurii and me  40 ears 	# Интересная конструкция связывания Переменных и Вывода


>>> tamplate="{0} and {1} but not {2}"		# Создание шаблона Строки
>>> tamplate.format("me", "you", "they")	# Додавание в Шаблон значений Атрибутов 
'me and you but not they'			# Вывод


>>> tamplate='{0} and {1} but not {2}'.format("Yurii", "Lena", "Zomby")
>>> tamplate
'Yurii and Lena but not Zomby'


""" 
Смешанный тип форматирования по Индексам переменных и Именам переменных
Причем сначала задается значение Неименнованной переменной (без ключа {0} и тд)
А затем задаются значения Именованных переменных (в произвольном порядке)
"""
>>> tamplate='{my_name} and {0} but not {they}'.format("Lena", my_name="Yurii", they="Zomby")
>>> tamplate
'Yurii and Lena but not Zomby'


>>> import sys
>>> ‘My {1[spam]} runs {0.platform}’.format(sys, {‘spam’: ‘laptop’})
‘My laptop runs win32’

>>> ‘My {config[spam]} runs {sys.platform}’.format(sys=sys, config={‘spam’: ‘laptop’})
‘My laptop runs win32’
	


>>> A="{0:<15}={1:>15}".format("span", 123.4567) # <15 - означает Ширину ячейки вывода и Направление 								Выравнивания 
>>> A
'span           =       123.4567'

import.sys
>>> ‘{0.platform:>10} = {1[item]:<10}’.format(sys, dict(item=’laptop’))
	# {1[item]:<10} - значение Аргумента по наименованию Ключа из Словаря + Ширина и Выравнивание
‘ win32 = laptop ‘

sys.platform =>> "win32"


""" Форматирование Разрядности Числа, как Вариант форматирования Строки"""
>>> A=1/3.0000
>>> A
0.3333333333333333
>>> "%.4f" % (A)
'0.3333'

""" Или в Новом Стиле Форматирования """
>>> ‘{0:.2f}’.format(A)
‘1.23’


""" Способ создать Словарь и Списка переменных """
>>> dict(motto='spam', pork='ham', food='eggs')
{'food': 'eggs', 'pork': 'ham', 'motto': 'spam'}
# и потому
>>> template = ‘%(motto)s, %(pork)s and %(food)s’
>>> template % dict(motto=’spam’, pork=’ham’, food=’eggs’) # Ключи словаря
‘spam, ham and eggs’


""" Форматирование Строк - Заключение - 2 схожих метода """
>>> data = dict(platform=sys.platform, spam=’laptop’)
создается словарь {"platform":"sys.platform", "spam":"laptop"}

>>> ‘My {spam:<8} runs {platform:>8}’.format(**data)	# Ширина ячеек+Выравнивание 
							** - Все пары Словаря из переменной
‘My laptop runs win32’

>>> ‘My %(spam)-8s runs %(platform)8s’ % data		# Ширина ячеек+Выравнивание
‘My laptop runs win32’					% Переменная
 

""" Бинарное число """
>>> "{0:b}".format(555)
'1000101011'

>>> bin(555)
'0b1000101011'


""" Форматирование Строк - Все способы Хороши """ 
>>> A="{}  {}  {}".format("aaa", "bbb", "ccc")
>>> A
'aaa  bbb  ccc'

>>> A="{0}  {1}  {2}".format("aaa", "bbb", "ccc")
>>> A
'aaa  bbb  ccc'

>>> A="%s  %s  %s" % ("aaa", "bbb", "ccc")
>>> A
'aaa  bbb  ccc'



""" Списки """
[]		list()
# это Упорядоченные Изменяемые Последовательности (Группы) - доступно Индексирование, Смещение, Итерация
# Как Массивы в языку С


>>> A=[1,2,3,4,[5,6,7],'asd','q','w',"e"]
>>> A
[1, 2, 3, 4, [5, 6, 7], 'asd', 'q', 'w', 'e']	# Создали Список из Различных элементов (Объектов)

>>> A.append("end")
>>> A
[1, 2, 3, 4, [5, 6, 7], 'asd', 'q', 'w', 'e', 'end']	# Добавили Элемент (Только в конец)

>>> A.insert(0,"start")		# Добавили Элемент на позицию 0 (в начало)
>>> A
['start', 1, 2, 3, 4, [5, 6, 7], 'asd', 'q', 'w', 'e', 'end']

>>> B=list(range(-5,5))		# Создание Списка по Диапозону
>>> B
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

>>> A
['start', 1, 2, 3, 4, [5, 6, 7], 'asd', 'q', 'w', 'e', 'end']
>>> A.count("asd")		# Считает Количесво такого Элемента в Списке
1

>>> A.index("asd")		# Указывает Индекс элемента в Списке
6	

>>> A.remove("asd")		# Удаление Элемента по Значению
>>> A
['start', 1, 2, 3, 4, [5, 6, 7], 'q', 'w', 'e', 'end']

>>> L=[x**3 for x in A[1:4]]	# Создан Список из частей Списка возведенные в степень (Генератор)
>>> L
[1, 8, 27]


>>> for x in [1,2,3]:			# Работа с Циклами
...     print(x),
... 
1 2 3

>>> gen=[x*4 for x in "SPAM"]		# Работа с Генератором Списков
>>> gen
['SSSS', 'PPPP', 'AAAA', 'MMMM']	


>>> res = []
>>> for c in ‘SPAM’: 			# Эквивалент генератора списков
...	res.append(c * 4)
...
>>> res
[‘SSSS’, ‘PPPP’, ‘AAAA’, ‘MMMM’]


>>> list(map(abs, [-1, -2, 0, 1, 2])) 	
""" Мап создает Список через функцию то есть Маппинг последовательно применяет Абсолют к каждому элементу Списка а затем Лист создает новый Список"""
[1, 2, 0, 1, 2]


""" Функция map() 
Обрабатывает несколько последовательностей
""" 
>>> list1 = [7, 2, 3, 10, 12]
>>> list2 = [-1, 1, -5, 4, 6]
>>> map(lambda x, y: x*y, list1, list2)
""" Неименованная функция объявляет переменные, задает логику и прикручивает переменные, 
затем логика последовательно применяется к последовательностям (попарам) с помощью Маппинга"""
[-7, 2, -15, 40, 72]


# Срезы в Списках
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> P=matrix[2][2]
>>> P
9		# Срез Элемента Списка в Списке (так можно многоуровнево)


>>> L=[1,2,3,4,5,6,7,8]
>>> L[2:3]=["aaa", "bbb"]		# Замена части элементов Списка
>>> L
[1, 2, 'aaa', 'bbb', 4, 5, 6, 7, 8]

>>> L[-1]=[]				# Замена элемента на Пустой список
>>> L
[1, 2, 'aaa', 'bbb', 4, 5, 6, 7, []]

L.append(100)				# Добавление в Конец нового элемента Списка
>>> L
[1, 2, 'aaa', 'bbb', 4, 5, 6, 7, [], 100]

>>> L.insert(4, "ccc")			# Добавление элемента Списка по Индексу 
>>> L
[1, 2, 'aaa', 'bbb', 'ccc', 4, 5, 6, 7, [], 100]


>>> L.sort()				# Сортировка Списка и сохраняет так
>>> L
[1, 2, 4, 5, 6, 7, 100, [], 'aaa', 'bbb', 'ccc']

>>> L.sort(reverse=True)		# Сортировка Списка в Обратном порядке
>>> L
['ccc', 'bbb', 'aaa', [], 100, 7, 6, 5, 4, 2, 1]


""" Метод sorted - способен сортировать Любые последовательности, создает Новый список"""
>>> L = [‘abc’, ‘ABD’, ‘aBe’]
>>> sorted(L, key=str.lower, reverse=True) # Встроенная функция сортировки / Временно понижается регистр
[‘aBe’, ‘ABD’, ‘abc’]

>>> L = [‘abc’, ‘ABD’, ‘aBe’]
>>> sorted([x.lower() for x in L], reverse=True) # Элементы предварительно изменяются (временный Список)
[‘abe’, ‘abd’, ‘abc’]


>>> L
['ccc', 'bbb', 'aaa', [], 100, 7, 6, 5, 4, 2, 1]
>>> L.reverse()				# Таким вот образом reverse
>>> L
[1, 2, 4, 5, 6, 7, 100, [], 'aaa', 'bbb', 'ccc']


>>> L.extend([11,111,1111])	# Вставляние Нескольких элементов в Конец
>>> L
[1, 2, 4, 5, 6, 7, 100, [], 'aaa', 'bbb', 'ccc', 11, 111, 1111]


>>> L.pop()		# Удаление Последнего (по умолчанию) элемента Списка
1111
>>> L
[1, 2, 4, 5, 6, 7, 100, [], 'aaa', 'bbb', 'ccc', 11, 111]


>>> L.pop(3)		# Метод: Удаление элемента с Указанной позиции
5
>>> L
[1, 2, 4, 6, 7, 100, [], 'aaa', 'bbb', 'ccc', 11, 111]


[1, 2, 4, 6, 7, 100, [], 'aaa', 'bbb', 'ccc', 11, 111]
>>> del L[5:7]		# Функция: Удаление Среза элементов (6й и 7й)
>>> L
[1, 2, 4, 6, 7, 'aaa', 'bbb', 'ccc', 11, 111]

[1, 2, 4, 6, 7, 'aaa', 'bbb', 'ccc', 11, 111]
>>> del L[3]
>>> L
[1, 2, 4, 7, 'aaa', 'bbb', 'ccc', 11, 111]


"""  Словари  """

>>> S=dict(name="Yurii", firs_name="Ryndin")  # Создание Словаря
>>> S
{'firs_name': 'Ryndin', 'name': 'Yurii'}


>>> S.keys()		# Запрос Ключей
['firs_name', 'name']

>>> S["name"]		# Запрос параметра по ключу
'Yurii'


>>> S.values()
['Ryndin', 'Yurii']	# Запрос значений Словаря (Без Ключей)


>>> S.items()
[('firs_name', 'Ryndin'), ('name', 'Yurii')]	# Запрос всех Элементов Словаря


>>> S2
{'name': 'Lena', 'firstname': 'Zueva'}		# Есть Один Словарь
>>> S
{'firs_name': 'Ryndin', 'name': 'Yurii'}	# Есть Другой Словарь

>>> S.update(S2) 	# Словарь2 Вливается в Словарь1 заменяет Значения по Ключу
>>> S
{'firs_name': 'Ryndin', 'name': 'Lena', 'firstname': 'Zueva'} (name Yurii заменено)
>>> S2			# Словарь2 тоже остается
{'name': 'Lena', 'firstname': 'Zueva'}


>>> S["name"]="Yurii"		# Замена Значения по Ключу
>>> S
{'firs_name': 'Ryndin', 'name': 'Yurii', 'firstname': 'Zueva'}


>>> S.pop("firs_name")		# Удаление Значения по Ключу и Выдает Элемент на экран (del D["elem"])
'Ryndin'
>>> S
{'name': 'Yurii', 'firstname': 'Zueva'}


>>> D={x: x*2 for x in range(12)}	# Генератор Словаря Ключ:Значение
>>> D
{0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 10, 6: 12, 7: 14, 8: 16, 9: 18, 10: 20, 11: 22}


>>> D.items()
[('tri', 3), ('dva', 2), ('raz', 1)]

>>> list(D.keys())		# Выдало Список Ключей Словаря
['tri', 'dva', 'raz']

>>> D["dva"]=["eto","prosto", "cifra"]		# Переопределение Элемента Словаря по Ключу
>>> D
{'tri': 3, 'dva': ['eto', 'prosto', 'cifra'], 'raz': 1}

>>> del D["tri"]		# Удаление Элемента Ключа по Словарю
>>> D
{'dva': ['eto', 'prosto', 'cifra'], 'raz': 1}


>>> D["chetyre"]=["escho_element"]	# Добавление Нового Элемента ключ/значение
>>> D
{'dva': ['eto', 'prosto', 'cifra'], 'chetyre': ['escho_element'], 'raz': 1}


>>> D.get("chetyre")		# Похож на метод Items() но При отсутствии элемента не выдает Ошибку
['escho_element']


>>> D
{'dva': ['eto', 'prosto', 'cifra'], 'chetyre': ['escho_element'], 'raz': 1}
>>> for item in D: print item		# Так просто вызывается Список Ключей Словаря  
... 
dva
chetyre
raz

>>> M={}
>>> M[(1,2,3)]=88		# В Виде ключа задается Кортеж
>>> M[(4,5,6)]=99
>>> M
{(4, 5, 6): 99, (1, 2, 3): 88}


>>> M
{(4, 5, 6): 99, (1, 2, 3): 88}
>>> M.get((4,5,7))		# Проверка наличия Ключа (например, в виде Матрицы)
путое место
>>> M.get((4,5,6))
99 - значение


{‘name’: ‘mel’, ‘age’: 45} 	# Традиционное литеральное выражение

D = {}
D[‘name’] = ‘mel’
D[‘age’] = 45 			# Динамическое Присваивание по Ключам

dict(name=’mel’, age=45) 	# Форма именованных аргументов / Все Ключи должны быть Строки

dict([(‘name’, ‘mel’), (‘age’, 45)]) # Кортежи ключ/значение /Из Кода - в виде Последовательностей



>>> F=dict.fromkeys(['a','s','d','f'])	# Метод Создания Словаря (ключи задаются) Значение по умолчанию 						Ноне
>>> F
{'a': None, 's': None, 'd': None, 'f': None}

>>> F=dict.fromkeys(['a','s','d','f'], 2) # Значение Словаря Задается для всех Ключей 
>>> F
{'a': 2, 's': 2, 'd': 2, 'f': 2}



>>> D=list( zip( ["a","s","d"], [1,2,3] ) )	# Попоарно Зипаем Элементы Списков
>>> D
[('a', 1), ('s', 2), ('d', 3)]			# Зипнутый Новый Список с ПодКортежами

>>> D=dict(D)					# Создаем словарь из Зипнутого Списка
>>> D
{'a': 1, 's': 2, 'd': 3}


>>> S={k:v for (k,v) in zip( ['q', 'e', 'r'], [4,5,6] )}	# Новая конструкция - Генератор Словарей
>>> S
{'q': 4, 'r': 6, 'e': 5}


""" Примеры Генерации Словарей """
>>> D = {x: x ** 2 for x in [1, 2, 3, 4]} 	# Или: range(1, 5)
>>> D
{1: 1, 2: 4, 3: 9, 4: 16}

>>> D = {c: c * 4 for c in ‘SPAM’} 		# Цикл через итерируемый объект
>>> D
{‘A’: ‘AAAA’, ‘P’: ‘PPPP’, ‘S’: ‘SSSS’, ‘M’: ‘MMMM’}

>>> D = {c.lower(): c + ‘!’ for c in [‘SPAM’, ‘EGGS’, ‘HAM’]}	# Меняет Регистр, добавляет Элемент
>>> D
{‘eggs’: ‘EGGS!’, ‘ham’: ‘HAM!’, ‘spam’: ‘SPAM!’}


>>> D = dict.fromkeys([‘a’, ‘b’, ‘c’], 0) 	# Инициализация списком ключей
>>> D
{‘a’: 0, ‘c’: 0, ‘b’: 0}
>>> D = {k:0 for k in [‘a’, ‘b’, ‘c’]} 		# То же самое, но с помощью # генератора словаря
>>> D
{‘a’: 0, ‘c’: 0, ‘b’: 0}


""" Объекты Отображения Словарей в версии 3,0 """
""" В Вресии 3,0 Если меняется Словарь то автоматически меняются и Представления Словаря
 - Перезагружать не нужно, В версии 2,Х представления надо Перевызывать"""
>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
>>> K = D.keys()		# Создание Представлений об Словаре
>>> V = D.values()

>>> list(K) 			# Представления сохраняют оригинальный
[‘a’, ‘c’, ‘b’] 		# порядок следования ключей в словаре

>>> list(V)
[1, 3, 2]

>>> del D[‘b’]
>>> D
{‘a’: 1, ‘c’: 3} 		# Изменяет словарь непосредственно

>>> list(K)
[‘a’, ‘c’]

>>> list(V)
[1, 3] 				# Изменения в словаре отражаются на объектах представлений



""" Выборки и Сортировки в Словарях """
>>> D
{'a': 1, 's': 2, 'er': 25}

>>> Ks=D.keys()			# Выбока Ключей, их Сортировка, Генерация Кортежей из по Парам
>>> Ks.sort()
>>> for item in Ks: print(item, D[item])
... 
('a', 1)
('er', 25)
('s', 2)


>>> D
{'a': 1, 's': 2, 'er': 25}
>>> for item in sorted(D): print(item, D[item])	
""" С помощью sorted() можно Сортировать и обрабатывать Сам Словарь """  
... 
('a', 1)
('er', 25)
('s', 2)


""" Сравнивание Словарей < > == """
sorted(D1.items()) < sorted(D2.items()) 
	# То же, что и D1 < D2 в версии 2.Х


""" Проверка наличия Ключа в Словаре """
>>> ‘c’ in D
True
>>> ‘x’ in D
False

>>> if ‘c’ in D: print(‘present’, D[‘c’]) # Предпочтительнее в версии 3.0
...
present 3



>>> print(D.get(‘c’))
3
>>> print(D.get(‘x’))
None
>>> if D.get(‘c’) != None: print(‘present’, D[‘c’]) # Еще одна возможность - Метод get()
...
present 3
 

""" Кортежи - Упорядоченные Последовательности """
>>> S=tuple()
>>> S
()

>>> S=()	# То же
>>> S
()

>>> T=("as", "we", [1,2,3])
>>> T
('as', 'we', [1, 2, 3])

>>> T[2]		# Доступ по Индексу
[1, 2, 3]


>>> T.index("we")	# Извлечение Индекса по Значению
1


>>> T.count([])
0
>>> T.count([1])
0
>>> T.count([1,2,3])	# Счетчик указанного Элемента
1


>>> for item in T: print item,		# Итерация доступна
... 
as we [1, 2, 3]


>>> "as" in T		# Проверка in Доступна
True
>>> 2 in T[2]
True


""" Единственное Число в Кортеже - с запятой, """
>>> A=(1,)
>>> A+2
Traceback (most recent call last):
  File "<console>", line 1, in <module>
TypeError: can only concatenate tuple (not "int") to tuple
>>> A+(2,)
(1, 2)


""" Если Сортировать Кортеж, то сначала Приводим к списку+сортировка (метод sorted()) 
А затем можно опять в Кортеж"""
>>> A=("aa", "ss", "dd", "cc")
>>> A1=sorted(A)
>>> A1
['aa', 'cc', 'dd', 'ss']
>>> A1=tuple(A1)
>>> A1
('aa', 'cc', 'dd', 'ss')


A=(1,3,5,7,2,4,9)
>>> A1=sorted([item for item in A])
>>> A1
[1, 2, 3, 4, 5, 7, 9]


>>> A=("aa", ["ya", "ty"], 123, "ss")
>>> A[1][1]="oni"
>>> A
('aa', ['ya', 'oni'], 123, 'ss')	# Вложенные элементы Списков/Строк в Кортежах меняются


""" Файлы """
>>> myfile=open("myfile.txt", "w")	# Открыли/Создали Файл
>>> myfile.write("Hello Word\n")	# Перелади/Сохранили/Закрыли
>>> myfile.write("Good Bay  Word\n")
>>> myfile.close()

>>> myfile=open("myfile.txt", "r")	# Открыли/Прочли Построково
>>> myfile.readline()
'Hello Word\n'
>>> myfile.readline()
'Good Bay  Word\n'
>>> myfile.readline()
''					# Пустая Строка/Конец Файла


>>> open("myfile.txt").read()		# Прочитать Все Строки Файла		
'Hello Word\nGood Bay  Word\n'

>>> print(open("myfile.txt").read())	# Функция read() Форматирует Строки Файла
Hello Word
Good Bay  Word



# Упражнение
>>> X, Y, Z = 43, 44, 45		# Набор исходных Данных
>>> S="Spam"
>>> D={"a":1, "b":2}
>>> L=[1,2,3]

>>> F=open("datafile.txt", "w")		# Создание и Заполнение Файла
>>> F.write(S+"\n")
>>> F.write(" {}, {}, {}, \n".format(X, Y, Z))
>>> F.write( str(L) + "$" + str(D) + "\n" )
>>> F.close()

>>> chare=open("datafile.txt", "r").read()	# Печатание Всех строк Файла
>>> print(chare)
Spam
 43, 44, 45, 
[1, 2, 3]${'a': 1, 'b': 2}
>>> print(chare)
Spam
 43, 44, 45, 
[1, 2, 3]${'a': 1, 'b': 2}

>>> F=open("datafile.txt")		# Печатание первой строки с удалением Конца строки
>>> line=F.readline()
>>> line.rstrip()
'Spam'

>>> line=F.readline()
>>> line
' 43, 44, 45, \n'
>>> parts = line.split(", ")		# Извлечение Элементов Строки в Список и вывод 
>>> print(parts)
[' 43', '44', '45', '\n']

>>> int(parts[1])			# Для выполнения программ извлекаем Число из Списка
44


>>> parts=list(["43", "44", "45"])
>>> parts
['43', '44', '45']

>>> numbers=[int(C) for C in parts]	# Перевод Строк чисел в Список Интов Чисел
>>> numbers
[43, 44, 45]


>>> line=[ "[1,2,3,4]", "{'a':11, 's':22, 'd':33}", "Spam" ] # Создан Список Строк
>>> line
['[1,2,3,4]', "{'a':11, 's':22, 'd':33}", 'Spam']

>>> eval(line[0])		# Функция eval() переводит Строку в Объект (с набором методов) 
[1, 2, 3, 4]

""" Функция eval() - Преобразует Строки в Объекты (словари, списки, кортежи, множества, числа)""" 
""" Eval(ution) ??"""
>>> line
['[1,2,3,4]', "{'a':11, 's':22, 'd':33}", 'Spam']
>>> line.remove("Spam")		# Удаляем Строку, которая не конвертируется в Объект
>>> line
['[1,2,3,4]', "{'a':11, 's':22, 'd':33}"]

>>> objects=[eval(Data) for Data in line]	# Конвертация Строк в Объекты
>>> objects
[[1, 2, 3, 4], {'a': 11, 's': 22, 'd': 33}]


>> type(objects)		# Проверка
<type 'list'>
>>> type(objects[0])
<type 'list'>
>>> type(objects[1])
<type 'dict'>			#  2 Объекта - Список и Словарь

>>> type(line[1])
<type 'str'>
>>> type(line[0])		# А было 2 Строки	
<type 'str'>		


""" Модуль pickle - Более безопасный способ создать Объекты из Строк в байт-коде (не для выполнения) """

>>> D = {'a': 1, 'b': 2}

>>> F=open("datafile.pkl", "wb")
>>> import pickle
>>> pickle.dump(D, F)		# Кидаем Словарь в Файл в Виде байт-кода (можно прочесть только pickle)
>>> F.close()
>>> 
>>> F=open("datafile.pkl", "rb")
>>> E=pickle.load(F)		# Загужаем (Извлекаем) код который под Пиклом в Файле 
>>> E
{'a': 1, 'b': 2}

>>> open("datafile.pkl", "rb").read()	# Проверка что под Пиклом в Файле - Байт-Код
"(dp0\nS'a'\np1\nI1\nsS'b'\np2\nI2\ns."



""" Упакованные Двоичные Файлы """
""" Модуль struct """
>>> F = open(‘data.bin’, ‘wb’) 			# Открыть файл для записи в двоичном режиме
>>> import struct
>>> data = struct.pack(‘>i4sh’, 7, ‘spam’, 8) 	# Создать пакет двоичных данных (Запаковка) / 
						# Использован Спецификатор формата >i4sh
>>> data
b’\x00\x00\x00\x07spam\x00\x08’
>>> F.write(data) 				# Записать строку байтов
>>> F.close() 

>>> F = open(‘data.bin’, ‘rb’)
>>> data = F.read() 				# Получить упакованные двоичные данные
>>> data
b’\x00\x00\x00\x07spam\x00\x08’
>>> values = struct.unpack(‘>i4sh’, data) 	# Преобразовать (Распаковка) в объекты
>>> values
(7, ‘spam’, 8)


""" Менеджеры Контекста Модулей (Файлов)"""
""" Обертки, которые обеспечивают Закрытие модулей при выходе за пределы выполнения Логики кода"""
with open(r’C:\misc\data.txt’) as myfile: # Подробности в главе 33
for line in myfile:
...операции над строкой line...

""" то же самое но более очевидно"""
myfile = open(r’C:\misc\data.txt’)
try:
	for line in myfile:
	...операции над строкой line...
finally:
	myfile.close()


set()			# Изменяемые Vножества, как бибилотеки но без ключей  {}
frozenset()		# Неизменяемые Множества,   {}


""" Многоуровневая Вложенность - Списки Словари Кортежи """
>>> L = ['abc', [(1, 2), ([3], 4)], 5]
>>> L[0]
'abc'
>>> L[2]
5
>>> L[1]
[(1, 2), ([3], 4)]
>>> L[1][1]
([3], 4)
>>> L[1][1][1]
4
>>> L[1][1][0]
[3]
>>> L[1][1][0][0]
3


""" Копирование Объектов"""
>>> L = [1,2,3]
>>> D = {‘a’:1, ‘b’:2}

>>> A = L[:]		# Оба Метода создает копии Объектов, т.е. не переназначает Ссылки
>>> B = D.copy()

>>> A[1] = ‘Ni’
>>> B[‘c’] = ‘spam’

>>> L, D
([1, 2, 3], {‘a’: 1, ‘b’: 2})		# Первоначальные Объекты

>>> A, B
([1, ‘Ni’, 3], {‘a’: 1, ‘c’: ‘spam’, ‘b’: 2})	# Новые объекты - Копии первоначальных объектов

"""
Если необходима полная копия структуры произвольной глубины
вложенности, следует использовать стандартный модуль copy: добавьте ин-
струкцию import copy и вставьте выражение X = copy.deepcopy(Y), которое создаст
полную копию объекта Y со сколь угодно большой глубиной вложенности. Эта
функция выполняет рекурсивный обход объектов и  копирует все составные
части
"""


""" Сравнивание Объектов"""

>>> L1 = [1, (‘a’, 3)] 		# Разные объекты с одинаковыми значениями
>>> L2 = [1, (‘a’, 3)]
>>> L1 == L2, L1 is L2 		# Равны? Это один и тот же объект? // 2 Условия сразу :)
(True, False)


""" None - Хороший наполнитель для Списков """
>>> L = [None] * 100
>>>
>>> L
[None, None, None, None, None, None, None, ... ]



while True:				# Дает Цикл - Интересный метод (если строка заполняется то 							всегда True)
	reply = input(‘Enter text:’)
	if reply == ‘stop’: break	# break - Выходит из инструкции цикла
	print(reply.upper())


""" Проверка Объекта как Числа """
>>> S = ‘123’
>>> T = ‘xxx’
>>> S.isdigit(), T.isdigit()
(True, False)


while True:				# Вариант проверки Цикла Условиями
	reply = input(‘Enter text:’)
	if reply == ‘stop’:
		break
	elif not reply.isdigit( ):
		print(‘Bad!’ * 8)
	else:
		print(int(reply) ** 2)
print ‘Bye’


while True:				# Вариант проверки Цикла как Попытка/Исключение
	reply = input(‘Enter text:’)
	if reply == ‘stop’: break
	try:				# это условие проверки
		num = int(reply)	
	except:				# Это Исключение - если трай не сработало 
		print(‘Bad!’ * 8)
	else:				# эта часть Кода Выполнятеся если исключение не Возникло
	print(int(reply) ** 2)
print ‘Bye’


""" Логика Циклов """
while True:				# Начальное условие - 3 элемента if/elif/else
	reply = input(‘Enter text:’)	# В логиках оперируем переменной
	if reply == ‘stop’:
		break			# Завершает Цикл полностью
	elif not reply.isdigit():
		print(‘Bad!’ * 8)
	else:
		num = int(reply) 	# В логиках оперируем переменной
		if num < 20:		# Вложенное условие - 2 элемента if/else
			print(‘low’)
		else:
			print(num ** 2)
print(‘Bye’)				# По завершению Цикла



""" Присваивание - подробно"""
>>> A, B = nudge, wink # Присваивание кортежей
>>> A, B
# Что равносильно A = nudge; B = wink
(1, 2)

>>> [C, D] = [nudge, wink] # Присваивание списков
>>> C, D
(1, 2)


>>> nudge = 1
>>> wink = 2
>>> nudge, wink = wink, nudge 		# Кортежи: обмен значениями
>>> nudge, wink				# То же, что и T = nudge; nudge = wink; wink = T
(2, 1)


>>> (a, b, c) = “ABC” 			# Строка символов присваивается кортежу переменных
>>> a, c
(‘A’, ‘C’)


>>> string = ‘SPAM’
>>> a, b, c = string[0], string[1], string[2:] 		# Элементы и срез
>>> a, b, c
(‘S’, ‘P’, ‘AM’)

>>> a, b = string[:2]				# 2 Среза, Но первый по элементам
>>> c = string[2:]
>>> a, b, c
(‘S’, ‘P’, ‘AM’)		


>>> (a, b), c = string[:2], string[2:]		# Примерно То Же
>>> a, b, c
(‘S’, ‘P’, ‘AM’)


>>> red, green, blue = range(3)
>>> red, green, blue
(0, 1, 2)


>>> L=[1,2,3,4,5]
>>> while L:				# Цикл: пока в Теле L
...     front, L = L[0], L[1:]		# 2 присвоения из Списка/ Элемент и Срез
...     print (front, L)
... 
(1, [2, 3, 4, 5])
(2, [3, 4, 5])
(3, [4, 5])
(4, [5])
(5, [])


>>> seq = [1, 2, 3, 4]		
>>> a, b, c, d = seq			# Теперь понятная запись Присовения
>>> print(a, b, c, d)		
1 2 3 4


>>> a, *b = ‘spam’
>>> a, b
(‘s’, [‘p’, ‘a’, ‘m’])
>>> a, *b, c = ‘spam’		# Удовная Форма Присвоения в Питоне3
>>> a, b, c
(‘s’, [‘p’, ‘a’], ‘m’)


>>> a, b = seq[0], seq[1:]	# Традиционная Форма присвоения Срезом по Индексам
>>> a, b
(1, [2, 3, 4])

>>> a, b = seq[:-1], seq[-1]
>>> a, b
([1, 2, 3], 4)


>>> a=b=[]			# присовение в Изменяемых Объектах //  1 Объект - 2 Ссылки
>>> b.append(43)
>>> a,b
([43], [43])


>>> a = []			# Присвоение // 2 Объекта - 2 Отдельных Ссылки
>>> b = []
>>> b.append(42)
>>> a, b
([], [42])


X=X+Y			# Увеличение и Присвоение
X+=Y			# Тоже Самое // Увеличение Объекта на аргумент

X=X-Y			
X-=Y			# Уменьшение Объекта на аргумент

X=X**Y			
X**=Y			# Возведение объекта в Степень аргумента

>>> X=47
>>> Y=3
>>> X//=Y		# Деление Объекта на аргумент с округлением Вниз 
>>> X
15


L = L + [5, 6] 		# Конкатенация: более медленная
L
2, 3, 4, 5, 6]
L.extend([7, 8]) 	# Более быстрая, но изменяет сам объект // Добавление Нескольких элементов


L += [9, 10] 		# Выполняется как L.extend([9, 10])  // Меняется Сам Объект

>>> L = L + [3, 4]	# Конкатинация создает Новый Объект. Старый Объект остается для других Ссылок


""" Зарезервированные Имена """
""" False 	class 	finally 	is 	return
	None 	ontinue 	for 	lambda 	try
	True 	def 	from 	nonlocal 	while
	and 	del 	global 	not 	with
	as 	elif i	f 	or 	yield
	assert 	else 	import 	pass 	break 	except 	in 	raise """
• • Имена, начинающиеся с одного символа подчеркивания (_X), не импортиру-
ются инструкцией from module import *
• • Имена, имеющие два символа подчеркивания в  начале и  в конце (__X__),
являются системными именами, которые имеют особый смысл для интер-
претатора.
• • Имена, начинающиеся с двух символов подчеркивания и не оканчивающи-
еся двумя символами подчеркивания (__X), являются локальными («иска-
женными») для объемлющего класса 
• • Имя, состоящее из единственного символа подчеркивания (_), хранит ре-
зультат последнего выражения при работе в интерактивной оболочке.

http://www.python.org/dev/peps/pep-0008 - соглашение об использовании имен


stdout - Поток Стандартного Вывода // например метод print передает туда вывод 
место хранения - sys.stdout

""" Конструкция print() - Версия Питон 3"""
print([object, ...][, sep=’ ‘][, end=’\n’][, file=sys.stdout])
	sep - разделитель (по умолчанию - пробел)
	end - операция по завершения строки (по умолчанию \n перенос строки)
	file - файл, куда делается print (по умолчанию sys.stdout)

""" Конструкция Записи в Файл и Читания из Файла"""
>>> print(x, y, z, sep=’...’, file=open(‘data.txt’, ‘w’)) 	# Вывод в файл
>>> print(x, y, z)   						# Вывод в поток stdout
spam 99 [‘eggs’]
>>> print(open(‘data.txt’).read()) 				# Вывод содержимого текстового файла
spam...99...[‘eggs’]

>>> text = ‘%s: %-.4f, %05d’ % (‘Result’, 3.14159, 42)	# Но лучше форматировать Генератором Строки 
>>> print(text)
Result: 3.1416, 00042

""" Конструкция print() - Версия Питон 2"""
>>> x=23
>>> z=[12,]
>>> c="spam"
>>> print x,z,c, "...\n \n"
23 [12] spam ...
... 
...
>>> print >> open("myfile.txt", "w"), x,z,c, "...\n \n"		# Запись в Файл
>>> open("myfile.txt", "r").read()				# Чтение из Файла - Проверка
'23 [12] spam ...\n \n\n'

""" Логика print() """
>>> import sys
# Вывод более сложным способом
>>> sys.stdout.write(‘hello world\n’)
hello world


""" Перенаправление Потока Печати """
C:\misc> c:\python30\python
>>> import sys
>>> temp = sys.stdout 			# Сохранить для последующего восстановления

>>> sys.stdout = open(‘log.txt’, ‘a’) 	# Перенаправить вывод в файл в режиме "add"
>>> print(‘spam’) 			# Выведет в файл, а не на экран
>>> print(1, 2, 3) 
>>> sys.stdout.close() 			# Вытолкнуть буферы на диск

>>> sys.stdout = temp 			# Восстановить первоначальный поток
>>> print(‘back here’)
back here
>>> print(open(‘log.txt’).read())	# Вывести на экран Результаты более ранних обращений
...
spam
1 2 3

# Запись в Файл вывода print()
log = open(‘log.txt’, ‘a’)		# 3.0
print(x, y, z, file=log)		# Вывести в объект, напоминающий файл
print(a, b, c) 				# Вывести в оригинальный поток вывода

log = open(‘log.txt’, ‘a’)		# 2.6
print >> log, x, y, z			# Вывести в объект, напоминающий файл
print a, b, c 				# Вывести в оригинальный поток вывода


C:\misc> c:\python30\python
>>> log = open(‘log.txt’, ‘w’)
>>> print(1, 2, 3, file=log) 		# В 2.6: print >> log, 1, 2, 3
>>> print(4, 5, 6, file=log)
>>> log.close()

>>> print(7, 8, 9) 			# В 2.6: print 7, 8, 9
7 8 9
>>> print(open(‘log.txt’).read())
1 2 3
4 5 6

from __future__ import print_function

""" Вывод - Элементы против Кортежи """
C:\misc> c:\python26\python
>>> print(‘spam’) 			# 2.6: использование скобок в инструкции
spam
>>> print(‘spam’, ‘ham’, ‘eggs’) 	# В действительности – это объект кортежа!
(‘spam’, ‘ham’, ‘eggs’)

C:\misc> c:\python30\python
>>> print(‘spam’) 			# Синтаксис вызова функции print в 3.0
spam
>>> print(‘spam’, ‘ham’, ‘eggs’) 	# Вызов с нескольким аргументами
spam ham eggs

""" Оптимизация / Унификация Вывода """
>>> print(‘%s %s %s’ % (‘spam’, ‘ham’, ‘eggs’))
spam ham eggs						## Так лучше всего
>>> print(‘{0} {1} {2}’.format(‘spam’, ‘ham’, ‘eggs’))
spam ham eggs						## Так лучше всего

## Короче - стр.373 - Чудеса с print//sys.stdout



""" if и не только (ключи Словаря, get, in)- Организация Выбора (Ветвление)"""
if 	>> True 1
elif 	>> True 2
False 	>> else


x="kiler rubbit"			# Выбор по Условию   if(True)/elif(True)/else(False)
if x == "roger":
    print "how a Jessica?"
elif x == "bugs":
    print "whots up doc?"
else:
    print "Run away !! Run away !! "


>>> choice = "ham"			# Выбор по Ключу из Словаря по параметру
>>> dict_item = {'ham':23, 'buter':15, 'meat':45}
>>> item=dict_item[choice]
>>> item
23


>>> dict_item
{'buter': 15, 'ham': 23, 'meat': 45}
>>> item=dict_item.get('ham', 'This item is Epsent')	# Запрос Гетом (get) по Ключу, або Исключение
>>> item
23							# Есть - выдало Значение
>>> item=dict_item.get('humus', 'This item is Epsent')
>>> item
'This item is Epsent'					# Нет - выдало Исключение


>>> dict_item
{'buter': 15, 'ham': 23, 'meat': 45}

>>> choice='ham'			# Выбор путем in В Словаре (Множестве) по Ключу
>>> if choice in dict_item:
...     item = dict_item[choice]
... else:
...     item = "This item is Epsent"
... 
>>> item
23					# Есть Объект в Словаре

>>> choice = 'humus'
>>> if choice in dict_item:
...     item = dict_item[choice]
... else:
...     item = "This item is Epsent"
... 
>>> item
'This item is Epsent'			# Нет Объекта в Словаре
 

""" Логические Операторы """ 
X and Y
Истина, если оба значения X и Y истинны.
X or Y
Истина, если любое из значений X или Y истинно.
not X
Истина, значение X ложно (выражение возвращает значение True или False)

>>> 2== 2 or 3==3
True
>>> 2== 2 or 3==2
True
>>> 2== 2 and 3==2
False

>>> 2 or 3		# Логика Рекурсивно - Слева Направо
2
>>> 3 or 2
3

>>> 2 or 3
2			# рекурсивно - 1 объект уже Истина

>>> 2 and 3		# 2 объект также Истина
3

>>> [] or {}
{}			# 2 объект также Ложь

>>> [] and {}
[]			# 1 Объект уже Ложь

>>> 3 and []		 
[]			# Только 2 Объект Ложь


"""  if//else """
if X:
	A = Y
else:
	A = Z

A = Y if X  else Z 	# Тоже самое, но другая конструкция


>>> A='X' if 'spam' else 'Z'	# Истина - не пустая строка, потому арумент 1
>>> A
'X'
>>> A='X' if '' else 'Z'	# Ложь - пустая строка, потому аргумент 2
>>> A
'Z'


X = A or B or C or None		""" интересная конструкция - присвоит первое попавшее Истинное 		(непустое) значение слева//направо или None все пустые"""


if X:		# Простая проверка что объект Х не пустой? то есть True. аналог (if X!='')


__bool__ и __len__		# логическая природа объекта 1) 1/или 0, 2) имеет длинну//или нет



""" Циклы    while//for + range, zip, map , break, continue """

>>> x='spammy'		# Задаем переменную
>>> while x:		# Условие Истинная если объект не Пустая строка // или не 0
...    print x
...    x=x[1:]		# Урезаем Объект на 1 элемент в пределах Цикла
... 
spammy			# Результат
pammy
ammy
mmy
my
y


>>> x=0; y=10			# Заданы 2 переменные
>>> while x<y:			# Пока Условие Истинна
...     print ('spam  '*x)	# Выполняется Действие
...     x+=1			# И это действие тоже в пределах Цикла
... 

spam  				# Результат
spam  spam  
spam  spam  spam  
spam  spam  spam  spam  
spam  spam  spam  spam  spam  
spam  spam  spam  spam  spam  spam  
spam  spam  spam  spam  spam  spam  spam  
spam  spam  spam  spam  spam  spam  spam  spam  
spam  spam  spam  spam  spam  spam  spam  spam  spam 


""" break - Вон за пределы Цикла !! """

""" continue - Прошу на Заголовок (Начало) Цикла """

""" pass - пустая инструкция-заполнитель """

""" else - Если условие цикла Ложь, но !! добраться можно только без break """

""" pass None - братья как Пустая инструкция//Пустой Объект  foo():pass//x=None"""


>>> x=15
>>> while x:			# Пока Истинна (не 0 и не пустая строка)
...     x-=1			# Делаем урезание
...     if x%2 !=0: continue	# делаем проверку логики на Ложь, если Ложь - в начало Цикла
				(аналог "if x % 2 == 0:" без continue)
...     print('spam  '*x)	# Если Логику прошли то Делаем Принт, и опять в начало Цикла
... 

spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  # 14
spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  spam  # 12
spam  spam  spam  spam  spam  spam  spam  spam  spam  spam   #10
spam  spam  spam  spam  spam  spam  spam  spam   #8
spam  spam  spam  spam  spam  spam  #6
spam  spam  spam  spam  #4
spam  spam  #2
 

>>> while 1:
... name = input(‘Enter name:’)
... if name == ‘stop’: break		# Выкидывает из Цикла, Слудующие 2 строки не Выполняются
... age = input(‘Enter age: ‘)
... print(‘Hello’, name, ‘=>’, int(age) ** 2) 		# строку надо перевести в Число (int) целое


""" Цикл for """
for <target> in <object>: 	# Присваивает элементы объекта с переменной цикла
	<statements>
if <test>: break		# Выход из цикла, минуя блок else	
if <test>: continue		# Переход в начало цикла
else:				# Если не была вызвана инструкция ‘break’
	<statements>


>>> sum=0
>>> for item in [1,2,3,4]:
...     sum=sum+item
... 
>>> print sum			# Собрана Сумма по циклу из Списка
10
>>> for item in [1,2,3,4]:
...     sum=sum*item
... 
>>> print sum			# Собрано Произведение по циклу из Списка
240


""" for """
>>> D={'a':1, 'b':2, 'c':3, 'd':4}
>>> D
{'a': 1, 'c': 3, 'b': 2, 'd': 4}	# Есть Словарь: Пары ключ//значение

>>> L=list(D.items())			# Создаем Список из кортежей пар
>>> L
[('a', 1), ('c', 3), ('b', 2), ('d', 4)]

>>> for (key, value) in L:		# Проходим по Парам значений из Кортежей
...     print(key, '=>', value)
... 
('a', '=>', 1)		# Получаем Списки
('c', '=>', 3)
('b', '=>', 2)
('d', '=>', 4)


[('a', 1), ('c', 3), ('b', 2), ('d', 4)]
>>> for item in L:
...     x,y=item
...     print x,y
... 
a 1			# Список Кортежей распакован в Пары значений
c 3
b 2
d 4



>>> word1='sepultura'
>>> word2='pult'
>>> W=[]

>>> for item in word1:
...     if item in word2:	# Ищем совпадения объектом с Строках путем вложенности Условий
...        W.append(item)	# Наполняем Список Совпадениями как Объектами
... 
>>> W
['p', 'u', 'l', 't', 'u']
>>> W.sort()			# Сортируем по Алфавиту
>>> W
['l', 'p', 't', 'u', 'u']
>>> 


""" range for """
>>> lists=range(10), list(range(2,12)), list(range(2,22,3))

>>> lists
([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [2, 5, 8, 11, 14, 17, 20])	
	# Диапозон от 0			# указан Диапозон		# Указан Диапозон с Шагом


>>> L				# Самый Простой и Быстрый способ сгенерировать Множество
'asqswsesrsds'
>>> S=[item for item in L[::2]]
>>> S
['a', 'q', 'w', 'e', 'r', 'd']


>> L=[1,2,3,4,5,6]
>>> L
[1, 2, 3, 4, 5, 6]			# Есть Сисок Элементов

>>> for item in range(len(L)): 		# Задаем Логику Последовательности как проход по длинне Списка
...     L[item]*=3			# Задаем Логику Изменения Элементов Списка
... 
>>> L
[3, 6, 9, 12, 15, 18]


""" zip """
>>> L1=[1,2,3,4]
>>> L2=[5,6,7,8]
>>> L3=zip(L1, L2)			# Зипание
>>> L3
[(1, 5), (2, 6), (3, 7), (4, 8)]


>>> L3=[(x*y) for (x,y) in zip(L1,L2)]	# Зипание Нового Списка из Двух Списков (Логика любая)
>>> L3
[5, 12, 21, 32]


>>> L4=[9,10,11,12]
>>> zip(L1,L2,L4)			# Простое Зипание в Список Кортежей поэлементно
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]


>>> S1='qwer'; S2='asdfgh'		# Простое Зипание по размеру меньшего Списка (строки)
>>> zip(S1,S2)
[('q', 'a'), ('w', 's'), ('e', 'd'), ('r', 'f')]


""" map """	Устаревшая
>>> S1='qwer'; S2='asdfgh'		# Маппинг, Мапает и разные по Длинне Последовательности
>>> map(None,S1,S2)
[('q', 'a'), ('w', 's'), ('e', 'd'), ('r', 'f'), (None, 'g'), (None, 'h')]



""" zip - Как получить Словарь """

>>> item=['plump', 'potato', 'tomato', 'brokkoli']	# Есть 2 сочитающихся Списка
>>> price=[30, 5.5, 8.7, 15]

>>> L2={}
>>> for (x,y) in zip(item,price) : 	# Зипаем их по Правилу Наполнения Словаря
	L2[x]=y  
... 
>>> L2
{'tomato': 8.7, 'potato': 5.5, 'brokkoli': 15, 'plump': 30}


>>> L3=dict( zip(item, price) )		# Более простой способ Зипания Словаря (без for in)
>>> L3
{'tomato': 8.7, 'potato': 5.5, 'brokkoli': 15, 'plump': 30}



""" enumerate() - генерирует Элементы и их Индексы (Для Словарей например)"""
>>> L='spammy'
>>> S={}
>>> for (key,val) in enumerate(L):	# Генерации пары Индекс//Значение
...     S[key]=val			# Заполнение Словаря
... 
>>> S
{0: 's', 1: 'p', 2: 'a', 3: 'm', 4: 'm', 5: 'y'}


>>> A=enumerate(L)
>>> A
<enumerate object at 0x7ff6c69692d0>	# Показано что Создается спец генератор (индекс//значение)


""" Итерации и Генераторы (еще) """
>>> f=open('myfile.txt')		# фактически Итерация вывода строк Файла
>>> f.readline()
'x="kiler rubbit"\n'
>>> f.readline()
'if x == "roger":\n'
>>> f.readline()
'    print "how a Jessica?"\n'


>>> for line in open('myfile.txt'):	# Запускает Итерацию для Всех строк Открытого Файла
...     print( line.upper() )		# Использован метод // Все Заглавные символы
X="KILER RUBBIT"

IF X == "ROGER": ...


>>> f = open(‘script1.py’)
>>> while True:				# То же самое но с while // это очень Медленно
... 	line = f.readline()
... 	if not line: break
... 	print(line.upper(), end=’’)


>>> f					# Переменная(объект) Открытого файла 
<open file 'myfile.txt', mode 'r' at 0x7ff6c6a41f60>

>>> f.next()				# Метод next() тоже читает построчно Файл
"if 'rubbery' in 'shrubbery':\n"
>>> f.next()
'\tprint(x * 8)\n'
>>> f.next()
"\tx += 'NI'\n"


""" Встроенный Метод Итерации  iter//next"""
>>> L=[1,2,3.4]
>>> I=iter(L)
>>> L=[1,2,3.4]
>>> I.next()
1
>>> I.next()
2
>>> I.next()
3.4


>>> D={'a':1, 's':2, 'd':3, 'f':4}	# Итерация по Ключам уже встроена в Словари 
>>> I=iter(D)
>>> next(I)
'a'
>>> next(I)
's'
>>> next(I)
'd'
>>> next(I)
'f'


>>> for key in D.keys(): print key,	# Можно вызвать Итерацию по Ключам свзякой for//keys()
... 
a s d f


>>> for key in D: print key, 		# Можно еще проще Итерацию по Ключам Словарей  
... 
a s d f


""" Еще раз о enumerate() """
>>> E=(enumerate('spammy'))
>>> E
<enumerate object at 0x7f1b0bc4b0f0>	# Для вывода Итерации Объекта необходимо сделать Список
>>> list(E)
[(0, 's'), (1, 'p'), (2, 'a'), (3, 'm'), (4, 'm'), (5, 'y')]

# в for уже встроен метод Создание Объекта Итератором в Список 


""" Еще Генраторы Списков + Итераторы """
>>> L
[1, 2, 3.4]
>>> for i in range(len(L)): 		# for Создается Диапозон Прохода по элементам Списка 
	L[i]+=10
... 
>>> L
[11, 12, 13.4]


>>> L=[x*2 for x in L]			# Новая Конструкция - Гораздо проще
>>> L
[22, 24, 26.8]

"""
[ Логика для Элемента в Объекте (с использованием Итерации) ] - 
	общий Вид Генератора Списков (новый Список)
"""

>>> res = []				# Это Точное Представление Генератора Списка
>>> for x in L:
...
	res.append(x + 10)
...
>>> res
[21, 22, 23, 24, 25]


>>> f=open('myfile.txt')
>>> lines = [line.rstrip() for line in f]
>>> lines
['x="kiler rubbit"', 'if x == "roger":', '    print "how a Jessica?"', 'elif x == "bugs":', '    print "whots up doc?"', 'else:', '    print "Run away !! Run away !! "', '', '', "x = 'SPAM'", "if 'rubbery' in 'shrubbery':", '\tprint(x * 8)', "\tx += 'NI'", "\tif x.endswith('NI'):", '\t\tx *= 2', '\t\tprint(x)', '', '', '', '']
""" 
Печатание Строка за Строкой из файла в Список с усечением последнего литерала (\n) в каждой строке 
""" 


>>> lines = [line.upper().split() for line in open('myfile.txt') if line[0] is not None]
>>> lines
[['X="KILER', 'RUBBIT"'], ['IF', 'X', '==', '"ROGER":'], ['PRINT', '"HOW', 'A', 'JESSICA?"'], ['ELIF', 'X', '==', '"BUGS":'], ['PRINT', '"WHOTS', 'UP', 'DOC?"'], ['ELSE:'], ['PRINT', '"RUN', 'AWAY', '!!', 'RUN', 'AWAY', '!!', '"'], [], [], ['X', '=', "'SPAM'"], ['IF', "'RUBBERY'", 'IN', "'SHRUBBERY':"], ['PRINT(X', '*', '8)'], ['X', '+=', "'NI'"], ['IF', "X.ENDSWITH('NI'):"], ['X', '*=', '2'], ['PRINT(X)'], [], [], [], []]

"""
Содержимое Строк файла разбиты на элементы Подсписков split() и переведены в Верхний регистр upper() // Добавлено условие: Если первый символ строки не Пустой
"""

>>> lines = [line.upper().split() for line in open('myfile.txt') if line[0] == 'x']
>>> lines
[['X="KILER', 'RUBBIT"'], ['X', '=', "'SPAM'"]]

>>> lines = [line.upper().split() for line in open('myfile.txt') if line[0] is not 'x']
>>> lines
[['IF', 'X', '==', '"ROGER":'], ['PRINT', '"HOW', 'A', 'JESSICA?"'], ['ELIF', 'X', '==', '"BUGS":'], ['PRINT', '"WHOTS', 'UP', 'DOC?"'], ['ELSE:'], ['PRINT', '"RUN', 'AWAY', '!!', 'RUN', 'AWAY', '!!', '"'], [], [], ['IF', "'RUBBERY'", 'IN', "'SHRUBBERY':"], ['PRINT(X', '*', '8)'], ['X', '+=', "'NI'"], ['IF', "X.ENDSWITH('NI'):"], ['X', '*=', '2'], ['PRINT(X)'], [], [], [], []]



>>> [(x+y) for x in '12345' for y in 'asdfg']
['1a', '1s', '1d', '1f', '1g', '2a', '2s', '2d', '2f', '2g', '3a', '3s', '3d', '3f', '3g', '4a', '4s', '4d', '4f', '4g', '5a', '5s', '5d', '5f', '5g']
"""
В Генераторах Списков могут указыватся сколько угодно источников Элементов Логики
"""


""" Еще раз Повторим: zip() - Зипает (Объединяет) Элементы объектов в Виде Подсписков Списка"""
>>> zip( open('myfile.txt'), open('myfile.txt') )
[('x="kiler rubbit"\n', 'x="kiler rubbit"\n'), ('if x == "roger":\n', 'if x == "roger":\n'), ('    print "how a Jessica?"\n', '    print "how a Jessica?"\n'), ('elif x == "bugs":\n', 'elif x == "bugs":\n'), ('    print "whots up doc?"\n', '    print "whots up doc?"\n'), ('else:\n', 'else:\n'), ('    print "Run away !! Run away !! "\n', '    print "Run away !! Run away !! "\n'), ('\n', '\n'), ('\n', '\n'), ("x = 'SPAM'\n", "x = 'SPAM'\n"), ("if 'rubbery' in 'shrubbery':\n", "if 'rubbery' in 'shrubbery':\n"), ('\tprint(x * 8)\n', '\tprint(x * 8)\n'), ("\tx += 'NI'\n", "\tx += 'NI'\n"), ("\tif x.endswith('NI'):\n", "\tif x.endswith('NI'):\n"), ('\t\tx *= 2\n', '\t\tx *= 2\n'), ('\t\tprint(x)\n', '\t\tprint(x)\n'), ('\n', '\n'), ('\n', '\n'), ('\n', '\n'), ('\n', '\n')]

""" Еще раз повторим: enumerate() - Элементы Списка преобразует в Словарь Ключ(индекс)//Значение"""
>>> enumerate( open('myfile.txt') )
<enumerate object at 0x7f1b0bc4b140>
>>> list(enumerate( open('myfile.txt') ) )
[(0, 'x="kiler rubbit"\n'), (1, 'if x == "roger":\n'), (2, '    print "how a Jessica?"\n'), (3, 'elif x == "bugs":\n'), (4, '    print "whots up doc?"\n'), (5, 'else:\n'), (6, '    print "Run away !! Run away !! "\n'), (7, '\n'), (8, '\n'), (9, "x = 'SPAM'\n"), (10, "if 'rubbery' in 'shrubbery':\n"), (11, '\tprint(x * 8)\n'), (12, "\tx += 'NI'\n"), (13, "\tif x.endswith('NI'):\n"), (14, '\t\tx *= 2\n'), (15, '\t\tprint(x)\n'), (16, '\n'), (17, '\n'), (18, '\n'), (19, '\n')]


""" Повторим: sorted() - Метод 2 в 1 - Сортирует как sort() + Возвращает Списов в виде Отдельныхъ элементов а Не вложенных кортежей (все отдельно) """
>>> sorted( open('myfile.txt') )
['\t\tprint(x)\n', '\t\tx *= 2\n', "\tif x.endswith('NI'):\n", '\tprint(x * 8)\n', "\tx += 'NI'\n", '\n', '\n', '\n', '\n', '\n', '\n', '    print "Run away !! Run away !! "\n', '    print "how a Jessica?"\n', '    print "whots up doc?"\n', 'elif x == "bugs":\n', 'else:\n', "if 'rubbery' in 'shrubbery':\n", 'if x == "roger":\n', "x = 'SPAM'\n", 'x="kiler rubbit"\n']


""" другие Методы под итерацией"""
any(), all(), sum(), max(), min(), reduce() - будут позже


>>> any(['',''])		# Возвращает Тру если хотябы 1 элемент Списка Тру
False
>>> any(['11',''])
True

>>> all(['11',''])		# Возвращает Тру если все элементы Списка Тру
False
>>> all(['',''])
False
>>> all(['111','222'])
True

>>> max(open('myfile.txt'))	# Забавно
'x="kiler rubbit"\n'
>>> min(open('myfile.txt'))
'\t\tprint(x)\n'
>>> sum(open('myfile.txt'))


""" Между Строками операции Вставки Символов """
>>> '##'.join(open('myfile.txt'))
'x="kiler rubbit"\n## if x == "roger":\n##    print "how a Jessica?"\n## elif x == "bugs":\n##     print "whots up doc?"\n## else:\n##     print "Run away !! Run away !! "\n## \n## \n## x = \'SPAM\'\n##
if \'rubbery\' in \'shrubbery\':\n##\tprint(x * 8)\n##\tx += \'NI\'\n##\tif x.endswith(\'NI\'):\n##\t\tx *= 2\n##\t\tprint(x)\n##\n##\n##\n##\n'


>>> set(open('myfile.txt'))	# Интересно - Множества
set(["if 'rubbery' in 'shrubbery':\n", '\t\tprint(x)\n', '\n', "x = 'SPAM'\n", 'if x == "roger":\n', 'elif x == "bugs":\n', '\t\tx *= 2\n', '\tprint(x * 8)\n', '    print "how a Jessica?"\n', "\tx += 'NI'\n", "\tif x.endswith('NI'):\n", '    print "whots up doc?"\n', 'else:\n', '    print "Run away !! Run away !! "\n', 'x="kiler rubbit"\n'])

>>> {line for line in open('myfile.txt')}	# Те же Множества
set(["if 'rubbery' in 'shrubbery':\n", '\t\tprint(x)\n', '\n', "x = 'SPAM'\n", 'if x == "roger":\n', 'elif x == "bugs":\n', '\t\tx *= 2\n', '\tprint(x * 8)\n', '    print "how a Jessica?"\n', "\tx += 'NI'\n", "\tif x.endswith('NI'):\n", '    print "whots up doc?"\n', 'else:\n', '    print "Run away !! Run away !! "\n', 'x="kiler rubbit"\n'])


""" Еще раз zip() - Зипаем Кортежи в новые подкортежи Списка """
>>> X=(2,3)
>>> Y=(8,9)
>>> zip(X,Y)			# Упаковка
[(2, 8), (3, 9)]

>>> A, B = zip(*zip(X,Y))	# Распаковка - 2 отдельных Кортежа
>>> A, B
((2, 3), (8, 9))


""" Итерация в range() """  """ Позволяет создавать Множества цепочек итераторов из 1 объекта """
>>> R=range(3)				# Сам Объект range() - не Итерируемый Объект
>>> next(R)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: list object is not an iterator

>>> T1=iter(R)				# Но с его помощью Создаются Итерируемые списки
>>> T1
<listiterator object at 0x7f4569be8350>

>>> next(T1)			# Одно и тоже
0
>>> T1.next()			# Одно и тоже
1
>>> T1.next()
2
>>> T1.next()


""" Итерация в zip map filter - Поддерживают только одну цепочку итератора """


""" Итерация в Словарях: методы keys, values, items """
>>> D=dict(a=2, b=4, c=6)		# Создаем Словарь по Понятиям :)
>>> D
{'a': 2, 'c': 6, 'b': 4}

>>> K=D.keys()				# Метод создает Список из Ключей
>>> K
['a', 'c', 'b']
>>> next(K)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: list object is not an iterator	# Объект Списка еще не имеет Итератор

>>> I=iter(K)
>>> I
<listiterator object at 0x7f4569be83d0>		# iter() создает спец.Список - Итератор

>>> next(I)				# пошли Итераторы
'a'
>>> next(I)
'c'
>>> next(I)
'b'


>>> D
{'a': 2, 'c': 6, 'b': 4}
>>> for item in D.values(): print(item)		# В Генераторе Выражений Итерация Проходит Автоматом
... 						# Созданы Значения
2
6
4
>>> for item in D.values(): print(item,)	# Созданы Кортежи из Одного Элемента
... 
(2,)
(6,)
(4,)


>>> for (x,y) in D.items(): print (x,y) 	# Для двух элементов Метода items()
... 
('a', 2)
('c', 6)
('b', 4)


>>> I_D=iter(D)			# Словари поддерживают Итерацию по Ключам
>>> I_D
<dictionary-keyiterator object at 0x7f4569bf20a8>
>>> next(I_D)
'a'
>>> next(I_D)
'c'
>>> next(I_D)
'b'


>>> for k in sorted(D): print (k, D[k],),	# Итерация просто по обращению к Словарю
... 
('a', 2) ('b', 4) ('c', 6)


""" В пользовательские классы можно добавить поддержку итераций с  помо-
щью методов перегрузки операторов __iter__ или __getitem__.
В частности, реализация пользовательских итераторов с помощью классов по-
зволяет обеспечить возможность использования произвольных объектов в лю-
бых итерацонных контекстах, с которыми мы познакомились здесь. """


""" Оформление Документации """

>>> dir([])
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 
	'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

>>> dir({})
['__class__', '__cmp__', '__contains__', '__delattr__', '__delitem__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 
	'clear', 'copy', 'fromkeys', 'get', 'has_key', 'items', 'iteritems', 'iterkeys', 'itervalues', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values', 'viewitems', 'viewkeys', 'viewvalues']

>>> dir(())
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
	 'count', 'index']

>>> dir('')
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 
	'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']


module.class.method.__doc__	# Способ Извлечения Строки документации отдельного Метода(сласса и т.д)


>>> dict.__doc__.split('\n')	# Дает описание Метода (разделиттель строк отсекается - удобно)
['dict() -> new empty dictionary', "dict(mapping) -> new dictionary initialized from a mapping object's", '    (key, value) pairs', 'dict(iterable) -> new dictionary initialized as if via:', '    d = {}', '    for k, v in iterable:', '        d[k] = v', 'dict(**kwargs) -> new dictionary initialized with the name=value pairs', '    in the keyword argument list.  For example:  dict(one=1, two=2)']


>>> help(sys.path)	# help()	из модуля PyDoc - расширенная документация по Объектам python



""" Пример  help()"""
>>> help({})

get(...)
 |      D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.
 |  
 |  has_key(...)
 |      D.has_key(k) -> True if D has a key k, else False
 |  
 |  items(...)
 |      D.items() -> list of D's (key, value) pairs, as 2-tuples
 |  
 |  iteritems(...)
 |      D.iteritems() -> an iterator over the (key, value) items of D
 |  
 |  iterkeys(...)
 |      D.iterkeys() -> an iterator over the keys of D
 |  
 |  itervalues(...)
 |      D.itervalues() -> an iterator over the values of D
 |  
 |  keys(...)
 |      D.keys() -> list of D's keys
 |  
 |  pop(...)
 |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
 |      If key is not found, d is returned if given, otherwise KeyError is raised
 |  
 |  popitem(...)
 |      D.popitem() -> (k, v), remove and return some (key, value) pair as a
 |      2-tuple; but raise KeyError if D is empty.
 |  
 |  setdefault(...)
 |      D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D
 |  
 |  update(...)
 |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
 |      If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
 |      If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
 |      In either case, this is followed by: for k in F: D[k] = F[k]
 |  
 |  values(...)
 |      D.values() -> list of D's values
 |  
 |  viewitems(...)
 |      D.viewitems() -> a set-like object providing a view on D's items
 |  
 |  viewkeys(...)
 |      D.viewkeys() -> a set-like object providing a view on D's keys
 |  
 |  viewvalues(...)
 |      D.viewvalues() -> an object providing a view on D's values



""" Функции """

""" 
Функция - это блок Логики, которой можно дать обработку Входные значения много раз, получить Вывод.

Функцию запрашивают по Имени.

Входные данные задаются в скобках после имени функции.

Ооператоры функций: def   return   global   nonlocal   yield   lambda

Для Функций важно - область видимости.

def - Создает Объект(Функцию) и присваивает Имя.

lambda (неименованная функция) - Создает Объект и возвращает его Результат.

return - Передает Результат выполнения Функции Вызывающей программе. Программа ждет на return как результат. Если Ретурна в функции нет - то выполняется все последовательно и на выходе None.

yield - похоже на return, но после возврата Результатат вызывающей программе запоминает положение, когда был произведен возврат.

global - присваивает переменной статус глобальной для модуля, по умолчанию переменные в функции являются локальными и с уществуют только при выполнении функции

nonlocal - ... для статуса переменной в области видимости объемлющей функции, это новая концепция создания объемлющей функции (проще чем глобальные)
"""

def func(): ... 		# Создает объект функции
func() 				# Вызывает объект
func.attr = value 		# Присоединяет атрибут к объекту


>>> def times(x,y):		# назвали Функцию и Параметры в Заголовке Функции
...     return x*y		# Задали Логику на Выход
... 
>>> times(10,20)		# Вызвали Функцию и задали Объекты параметров, что в заголовке Функции
200

# Сохранение Результата Функции - Путем присвоения Переменной
x=times(10,20)


# 1) Логика Функции
def intersect(arg1, arg2):		# Имя Функции и требуемые Параметры
	res=[]
	for x in arg1:			# Логика
		if x in arg2:
			res.append(x)
	return res			# Вывод результата

# 2) Манипуляции в Консоли по Вызову и Наполнению Функции
>>> import myfile			# Импорт Модуля (Файла)
>>> string1='abrakadabra'		# Задача двух Параметров
>>> string2='abbiturient'
>>> dir(myfile)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'intersect']  

>>> from myfile import intersect	# Импорт Функции из Файла (Модуля)
>>> intersect(string1, string2)		# Выполнение Функции и Вывод Результата
['a', 'b', 'r', 'a', 'a', 'a', 'b', 'r', 'a']

>>> str1=[1,2,3,4,5]
>>> str2=(2,4,6,8)
>>> intersect(str1, str2)	# Проявляется Полиморфизм - Список сравнивается с Кортежем
[2, 4]

""" Важно - res  x  arg1  arg2 - Локальные переменные в файле - Названы только внутри Функции  - Доступны только Внутри функции и Существуют только при работе Функции """


""" Области Видимости """

1) Если перевенная внутри def - то Локальная область видимости
2) за пределами действия def - Глобальная Переменная, даже если в пределах Модуля (Файла), видна во всех местах модуля (файла) даже на локальном уровне
3) Нелокальная Область видимости (Средняя)
4) Всроенные переменные (модуль builtins)

Вызов Функции инициирует создание Объекта, одним из разделов есть Создаваемая Область Видимости для переменных в пределах функции

nonlocal - если значение Локальной Переменной надо передать в объемлющую переменную def (Python 3.0)

global - если Значение Локальной Переменной нужно передать в глобальную область видимости Модуля (Файла)


""" Встроенные Переменные - все в одном модуле __builtin__ - все Глобальные """
>>> import __builtin__
>>> dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 
'False', 
'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 
'None', 
'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 
'True', 
'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError',
 '_', 
'__debug__', '__doc__', '__import__', '__name__', '__package__', 

'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']		# это ВСЕ встроенные (они глобальные) переменные-функции

>>> __builtin__.zip		# Представление Встроенной функции zip 
<built-in function zip>


""" global Инструкция"""

# было
>>> x=10			# задали Глобальную Х 
>>> def foo():
...     x=20			# задали Локальную Х
...     return x		# Явно вывели Локальную Х
... 
>>> foo()
20
>>> x				# Но в Приоритете Глобальная Х
10

# стало
>>> x=10
>>> def foo():
...     global x		# Локальную Х назначили Глобальной
...     x=20
...     return x
... 
>>> foo()			# Явно вывели Локальную Х	
20
>>> x				# Вывели Гбольную Х которая "выросла" из Локальной
20

globals()		# Модуль выдаст все Глобальные Переменные

locals() 		# Модуль выдаст все Локальные Переменные


# first.py		# Лучше делать связь между модкулями Явной передачей функций - удобно и Хороший тон
X = 99
def setX(new):
global X
X = new			# Первый Файл - для изменения глобальной переменной через функцию - требуется 				явный вызов функции во втором модуле 	

# second.py
import first
first.setX(88)		# Второй модуль - Явный вызов функции и присовение Значения

>>> import sys
>>> import myfile	# Можно увидеть а также использовать содержимое Активных Модулей
>>> sys.modules
{'copy_reg': <module 'copy_reg' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/copy_reg.pyc'>, 'encodings': <module 'encodings' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/encodings/__init__.pyc'>, 'site': <module 'site' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site.pyc'>, '__builtin__': <module '__builtin__' (built-in)>, '__main__': <module '__main__' (built-in)>, 'encodings.encodings': None, 'abc': <module 'abc' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/abc.pyc'>, 'posixpath': <module 'posixpath' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/posixpath.pyc'>, '_weakrefset': <module '_weakrefset' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/_weakrefset.pyc'>, 'errno': <module 'errno' (built-in)>, 'encodings.codecs': None, '_abcoll': <module '_abcoll' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/_abcoll.pyc'>, 'types': <module 'types' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/types.pyc'>, '_codecs': <module '_codecs' (built-in)>, '_warnings': <module '_warnings' (built-in)>, 'genericpath': <module 'genericpath' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/genericpath.pyc'>, 'stat': <module 'stat' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/stat.pyc'>, 'zipimport': <module 'zipimport' (built-in)>, 'encodings.__builtin__': None, 'warnings': <module 'warnings' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/warnings.pyc'>, 'UserDict': <module 'UserDict' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/UserDict.pyc'>, 'encodings.utf_8': <module 'encodings.utf_8' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/encodings/utf_8.pyc'>, 'sys': <module 'sys' (built-in)>, 'codecs': <module 'codecs' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/codecs.pyc'>, 'readline': <module 'readline' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-dynload/readline.so'>, 'os.path': <module 'posixpath' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/posixpath.pyc'>, 'signal': <module 'signal' (built-in)>, 'linecache': <module 'linecache' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/linecache.pyc'>, 
'myfile': <module 'myfile' from 'myfile.py'>, 
'posix': <module 'posix' (built-in)>, 'encodings.aliases': <module 'encodings.aliases' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/encodings/aliases.pyc'>, 
'exceptions': <module 'exceptions' (built-in)>, 
'os': <module 'os' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/os.pyc'>,
 '_weakref': <module '_weakref' (built-in)>}



""" Вложенные Области Видимости """
def f1():			# Объемлющая Функция
	X = 88			# НонЛокальная переменная
	def f2():		# Вложенная функция, Живет только при вызове Объемлющей Функции 
		print(X)
	return f2 

action = f1()
action()	# результат будет 88 так как Вложенная Функция f2 запусткается при вызове объемлющей функции f1 и берет значение нонлокальной переменной Х



x=10				# файл mtfile

def foo1():
	x=20			# Нонлокальная Переменная
	def foo2():
		
		x+=2
		print x
	x+=3	
	print x

>>> import myfile		# При импорте файла Видим области видимости 
>>> dir(myfile)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'foo1', 'x']
""" Видим глобальную переменную Х в foo1() - Вложенную функцию foo2() не видем"""

>>> myfile.x
10
>>> myfile.foo1()
23



""" Фабричная Функция // Замыкание - Кратко """

>>> def marcer(N):		# Объемлющая и Вложенная функции - принемают Внешние аргументы
...     def action(X):
...         return X**N
...     return action
... 
>>> f=marcer(4)			# При Инициации Нового Аргумената Объемлющей функции создается 					отдельная область памяти // Своя логика работы
>>> d=marcer(5)
>>> f(5)	
625				# 5**4
>>> d(5)
3125				# 5**5


# Прием - Сохраняем Глобальную область видимости в НонЛокальную область Видимости
>>> def foo1():
...     x=100
...     def foo2(x=x):
...         print x
...     foo2()
... 
>>> foo1()
100

# Чтобы избежать Вложенности функций в функции (а это лучше) надо писать связанные Функции, выполняя логику последовательно и Привязываю Логику одной функции к другой функции: Пример: 
>>> def f1():
...	x = 88
... 	f2(x)		# Привязали логику Второй функции к Первой функции (можно заранее)
...
>>> def f2(x):
... 	print(x)
...
>>> f1()
88


""" Вложенные области Видимости и lambda // Неназванная функция """
>>> def foo1():
...     x=4
...     action=(lambda n: x**n)		# Странно Правда?  // Потому что Автоматически то. что написано 					вручную ниже // x для lambda - значение по умолчанию
...     return action
... 
>>> x=foo1()
>>> print x(3)				# Результат

def func():
    x = 4
    action = (lambda n, x=x: x ** n) 	# Передача x вручную // А вот почему - Нонлокальная видимость 						передается в локальную видимость теперь Автоматически
    return action


""" Поиск переменной в объемлющей функции по цепочке (f1()...) - так происходит, не важна глубена вложенности """
>>> def f1():
...     x=100
...     def f2():
...         def f3():
...             print(x)
...         f3()
...     f2()
... 
>>> f1()
100

""" Зацикленная функция // Фабричная функция - еще раз"""
>>> def tester(start):
... 	state = start 			# В каждом вызове сохраняется свое значение state
... 	def nested(label):
... 		nonlocal state 		# Объект state находится
... 		print(label, state) 	# в объемлющей области видимости
... 		state += 1 		# Изменит значение переменной, объявленной как nonlocal
...	return nested
...
>>> F = tester(0)
>>> F(‘spam’)
# Будет увеличивать значение state при каждом вызове
spam 0
>>> F(‘ham’)
ham 1
>>> F(‘eggs’)
eggs 2
"""
Как обычно, мы можем вызвать фабричную функцию tester множество раз,
и каждый раз в памяти будет создаваться отдельная копия переменной state.
Объект state, находящийся в  объемлющей области видимости, фактически
прикрепляется к  возвращаемому объекту функции nested  – каждый вызов
функции tester создает новый, независимый объект state, благодаря чему изме-
нение state в одной функции не будет оказывать влияния на другие. 
- Это Все что надо знать о Фабричной ф-ции
"""


""" Сохранение значений в global переменной"""
>>> def tester(start):
...     global state
...     state = start
...     def nested(label):
...         global state
...         print (label, state)
...         state+=1
...     return nested
... 
>>> F=tester(0)
>>> F('spam')
('spam', 0) 		# Сохранено значение в глобальной переменной - Вызов 1 (Как Словарь)
			
>>> F('egge')
('egge', 1)		# сохранено значение в глобальной переменной - Вызов 2

>>> F.func_globals
{'tester': <function tester at 0x7fabc8d010c8>, '__builtins__': <module '__builtin__' (built-in)>, 'F': <function nested at 0x7fabc8d01050>, '__package__': None, 'state': 2, '__name__': '__main__', '__doc__': None}

>>> F('asd')
('asd', 2)
>>> F.func_globals
{'tester': <function tester at 0x7fabc8d010c8>, '__builtins__': <module '__builtin__' (built-in)>, 'F': <function nested at 0x7fabc8d01050>, '__package__': None, 'state': 3, '__name__': '__main__', '__doc__': None}



""" Создание экземпляра Класса - Впервые - метод сохранения данных """
>>> class tester:			# Создали класс
...     def __init__(self, start):	# Метод создания (инициации) Экземпляра класса
...         self.state=start		# "Своя переменная" наследует входящую переменную - Новый объект
...     def nested(self,label):
...         print(label,self.state)	# Явное обращение к Созданному объекту (self как global)
...         self.state+=1		# Допуститмы Изменения Объекта как global 
... 
>>> F=tester(0)			# Первый Объект
>>> F.nested('spam')
('spam', 0)
>>> F.nested('ham')
('ham', 1)

>>> G=tester(42)		# Новый Объект / новый счетчик
>>> G.nested('toast')
('toast', 42)
>>> G.nested('brod')
('brod', 43)

>>> F.nested('milk')		# Опять первый объект / счетчик продолжается
('milk', 2)

>>> F				# Объект F - наследник от __main__.tester
<__main__.tester instance at 0x7fabc8d09248>

>>> type(F)
<type 'instance'>

>>> dir(F)			# Доступные методы: функция nested  и  state как Экземпляр Класса
['__doc__', '__init__', '__module__', 'nested', 'state']

>>> F.__dict__			# Инфо в Объекте Класса как Словарь 
{'state': 3}

>>> F.__init__			# Метод в Классе
<bound method tester.__init__ of <__main__.tester instance at 0x7fabc8d09248>>


""" Метод __call__ - Вместро внутренней функции в Классе метод вызывает Интсрукцию"""
>>> class tester:
... 	def __init__(self, start):
... 		self.state = start
... 	def __call__(self, label): 	# При создании экземпляра Класса (вместо ф-ции nested)
... 		print(label, self.state)
... 		self.state += 1
...
>>> H = tester(99)
>>> H(‘juice’)
juice 99
>>> H(‘pancakes’)
pancakes 100


""" Через Атрибуты Функций """ 
>>> def tester(start):
... 	def nested(label):
... 		print(label, nested.state) 	# nested – объемлющая область видимости
						# nested.state - Атрибут Функции
... 		nested.state += 1 		# Изменит атрибут, а не значение имени nested
... 		nested.state = start 		# Инициализация после создания функции
... 	return nested
...
>>> F = tester(0)
>>> F(‘spam’) 			# F – это функция ‘nested’
spam 0 				# с присоединенным атрибутом state
>>> F(‘ham’)
ham 1

>>> F.state 			# Атрибут state доступен за пределами функции
2

>>> G = tester(42) 		# G имеет собственный атрибут state,
>>> G(‘eggs’) 			# отличный от одноименного атрибута функции F
eggs 42

>>> F(‘ham’)
ham 2


""" Аргументы Функций """


""" Вид Файла и двух Функций, вложенных одна в другую """
>>> import myfile
>>> dir(myfile)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'foo1', 'x']
>>> myfile.foo1
<function foo1 at 0x7fabc8d01398>
>>> myfile.foo1()
<function foo2 at 0x7fabc63f56e0>



""" Логика Фыполения Функций """
>>> def cha (a,b):		# Функции работают с Переменными !!! Обрабатывают их Значения !!!
...     a=2
...     b[0]='spam'
... 
>>> X=1
>>> L=[1,2]
>>> cha(X,L)			# Функции отданы в работу 2 Переменные со значениями

>>> X
1				# Функция обработала параметр a и изменила знвачение Х

>>> L
['spam', 2]			# Функция обработала параметр b и изменила его первый объект


""" Функции - Имитация Выходных параметров """
>>> def multiple(x,y):
...     x=2
...     y=['spam', 3]
...     return x,y		# задана Логика функции и Выход значений параметров
... 
>>> X=3; Y=['egge', 5]		# Внешние значения по Именам переменных

>>> X, Y = multiple(X,Y)	# Функция Кортежем выдает значения по Именам переменных
>>> X, Y			# Внешние объекты изменились
(2, ['spam', 3])


""" Заполнение Функций """
func(*args) Вызывающая программа // Все объекты в указанной последовательности передаются как отдельные позиционные аргументы

func(**kwargs) Вызывающая программа // Все пары ключ/значение в указанном словаре передаются как
отдельнименованные аргументы

def func(*name) Функция // Определяет и объединяет все дополнительные аргументы в кортеж

def func(**name) Функция // Определяет и объединяет все дополнительные именованные аргументы в словарь

При использовании формы *name все дополнительные позиционные аргументы объединяются в  кортеж, а  при использовании формы **name все дополнительные именованные аргументы объединяются в  словарь.

>>> def foo(item, name='value', *args, **kwargs):	# Последовательность Заполнения Функции
...     pass
... 
>>> dir(foo)
['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']		# Структура (методы) пустой функции
>>> foo.func_defaults
('value',)


>>> def foo(**kwargs): print(kwargs)		# Логика Функции - Заполнение Словаря
...
>>> foo(name='Yurii', age=40, job='dev')
{'job': 'dev', 'age': 40, 'name': 'Yurii'}	# Выдает Словарь


>>> def foo(*args): print(args)			# Логика Функции - Заполнение Кортежа
... 
>>> foo(1,2,3,'spam', 'ham')
(1, 2, 3, 'spam', 'ham')			# Выдает Кортеж


>>> def foo(a,b, *args, **kwargs): print (a,b,args,kwargs) 	# Сборное Наполнение Функции
... 
>>> foo(1, 'spam', 2, 3,'ham', name='Yurii', age=40)		# Выдача Аргументов, Кортежа, Словаря
(1, 'spam', (2, 3, 'ham'), {'age': 40, 'name': 'Yurii'})



""" *args """
>>> def foo(a,s,d,f): print (a,s,d,f)		# создали Функцию - принимает/выдает 4 аргумента
... 
>>> args=(3,4)
>>> args+=('spam', 'ham')
>>> args
(3, 4, 'spam', 'ham')				# создали Переменную - кортеж = 4 элемента

>>> foo(*args)					# Пихаем все Аргументы Переменной в Функцию (*)
(3, 4, 'spam', 'ham')



>>> args={'a':1, 'b':2, 'c':3, 'd':4}
>>> args['d']=5
>>> args
{'a': 1, 'c': 3, 'b': 2, 'd': 5}		# Создаем Переменную в виде Словаря

>>> foo(*args)					# Пихаем в Функцию Ключи Словаря
('a', 'c', 'b', 'd')

>>> foo(**args)					# В версии Питон3,0 тоже должно пихатся целый Словарь


>>> def foo(*args, **kwargs): print(args, kwargs)	# Универсальная Забористая/Выдающая Функция
... 
>>> foo(1, *(2,3), **{'a':4})				# результат Забора/Выдачи
((1, 2, 3), {'a': 4})			


""" Метод apply - устаревший """
func(*pargs, **kargs) 		# Новейший синтаксис вызова: func(*sequence, **dict)
apply(func, pargs, kargs) 	# Устаревшая функция: apply(func, sequence, dict)	


>>> def foo(*args, **kwargs): print (args, kwargs)	# Задается Логика наполнения Функции
... 
>>> args=(1,2,3,4)
>>> kwargs={'a':'spam', 's':5}			# Переменные - Кортеж и Словарь

>>> apply(foo, args, kwargs)
((1, 2, 3, 4), {'a': 'spam', 's': 5})		# Заполняем Функцию - Старый метод (apply)

>>> foo(*args, **kwargs)			# Заполняем Функцию - Новый метод (*,**)
((1, 2, 3, 4), {'a': 'spam', 's': 5})


""" Возможности * """
def foo(a,*b,c)		# аргумент с - последний агрумент и может быть только именованный, * - по сути коржеж из разних эл-тов, набор произвольных Аргументов

def foo (a,*, b,c) 	# аргументы b c - последние Аргументы и могут быть только именноваными, * - произвольный набор Аргументов 

# Передача именнованых аргументов может использоваться как параметры насроек, Труе по обязательным элементам и прочее.

""" Примеры Наполнения Функции - вычесление Мин.значения"""

>>> def min(*args):				# Самое компактное
...     return sorted(args)[0]
... 
>>> min(-2,-20,5, 30)
-20


>>> def min(*args):			# То же самое: 
...     f=list(args)			# Создаем список принятых элементов
...     f.sort()			# Соритируем список по возрастанию
...     return f[0]			# Выдаем первый (минимальный) элемент
... 
>>> min(-2,-20,5, 30)
-20


>>> def foo(first, *rest):		# То же самое / Через первый элемент как База сравнения
...     for item in rest:
...         if item < first:		# циклически ищем минимальное значение
...             first = item
...     return first
... 
>>> foo(-2,-20,5, 30)
-20

>>> import myfile				# Если сохранить в Файл то вызвать как import
>>> foo(-50,50,-100,True, False, 'spam')	# А зетем видимой функции закинуть значения
-100


# пример на работу с множеством аргументов
def interset(*args):				# Файл myfile.py с Новой Логикой
	resoult=[]
	for item in args[0]:
		for other_items in args[1:]:
			if item not in other_items: 
				break
			else:
				resoult.append(item)
	return resoult

>>> reload(myfile)				# Перегружаем файл из-за новой Логики
<module 'myfile' from 'myfile.py'>
>>> dir(myfile)					# Доступные объекты Файла
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'interset']

>>> from myfile import interset			# Испортируем функцию
>>> interset('spam', 'scram', 'sam')		# Передаем Функции параметры в работу
['s', 's', 'a', 'a', 'm', 'm']


# Пример именованных аргументов
from tkinter import *				# Импорт Графического модуля tkinter
widget = Button(text=”Press me”, command=someFunction)
# создает новую кнопку и определяет текст на кнопке и функцию обрат-
# ного вызова с помощью ключевых аргументов text и command.

sorted(iterable, key=None, reverse=False)	# встроенная Функция sorted применяет именованные параметры по умолчанию или принимает именованные вручную
sorted(*item, reverse=True)

>>> T=[1,3,5,7,2,4,6]
>>> sorted(T, reverse=True)		# Например меняем Именнованный параметр у встроенной ф-ции
[7, 6, 5, 4, 3, 2, 1]


# Функция должна выполнять одну задачу
# Дао Функции это аргументы и return
# Меньше глобальных переменных
# Между модулями - функции доступа - а не прямое изменение переменных, Все модули - макс автономны


""" Функции и Рекурсия """  Функция запрашивает Сама Себя
>>> def mysum(L):
...     if not L:
...         return 0
...     else:
...         return L[0]+mysum(L[1:])	# Функция выдает первый Элемент и запрашивает Сама себя по срезу параметров, меньшему на один параметр - Трудно Понять !!
... 
>>> mysum([1,2,3,4,5,6])
21


>>> def mysum(L):
...     return 0 if not L else L[0] + mysum(L[1:])	# То же но через Трехместный Оператор 
... 
>>> mysum([1,2,3,4,5,6])
21


>>> def mysum(L):					# То Же Самое но Другой оператор
...     return L[0] if len(L) == 1 else L[0] + mysum(L[1:])
... 
>>> mysum([1,2,3,4,5,6])
21
>>> mysum(('s','p','a','m'))			# Такая конструкция позволяет суммировать Любые Объекты 
'spam'


>>> def mysum(L):
... 	if not L: return 0
... 	return nonempty(L) 	# Вызов функции, которая вызовет эту функцию
... 
>>> def nonempty(L):
... 	return L[0] + mysum(L[1:]) # Косвенная рекурсия через Другую Функцию, которая Вызывает Первую
...
>>> mysum([1.1, 2.2, 3.3, 4.4])
11.0


""" Циклы (while // for) вместо Рекурсии !! """

>>> L=[1,2,3,4,5]
>>> sum=0
>>> for item in L: sum+=item		# Очень просто через for: все Быстро через Итератор и Цикл
... 
>>> sum
15

# но тут Рекурсия обязательно - Пока Понять Сложно !!
[1, [2, [3, 4], 5], 6, [7, 8]] 		# С такими сложными Вложенными списками циклы могут не справиться. Тут только рекурсия поможет.
def sumtree(L):
	tot = 0
	for x in L: 				# Обход элементов одного уровня
		if not isinstance(x, list):
			tot += x 		# Числа суммируются непосредственно
		else:
			tot += sumtree(x) 	# Списки обрабатываются рекурсивными вызовами
	return tot

L = [1, [2, [3, 4], 5], 6, [7, 8]] 	# Произвольная глубина вложения
print(sumtree(L)) 			# Выведет 36


""" Гибкость Функций как Объектов""" 
>>> def foo1(a):		# Задана Простая Логика Функции 
...     b='spam'
...     return b*a
... 
>>> foo1(3)
'spamspamspam'

>>> foo1.count=0		# Функции присвоен Внешний атрибут (вне кода), ему задано значение на Хронение
>>> foo1.count+=1
>>> foo1.count
1
>>> dir(foo1)
['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
'count',		# Это Внешний Атрибут Сохранен за Функцией
 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']

>>> foo1.func_name		# Атрибут Функции - дает Имя Функции
'foo1'
>>> foo1.func_globals		# Атрибут Функции - дает Все доступные Глобальные переменные
{'mysum': <function mysum at 0x7f15843bd1b8>, 'f': ['def', 'foo(first,', '*rest):', 'for', 'item', 'in', 'rest:', 'if', 'item', '<', 'first:', 'first', '=', 'item', 'return', 'first', 'list=list(first,', 'rest)', 'print', "('", ':', "',", 'list)'], 'interset': <function interset at 0x7f15843bd398>, 'min': <function min at 0x7f15843bd230>, '__builtins__': <module '__builtin__' (built-in)>, 'sum': 15, 'args': (1, 2, 3, 4), 'L': [1, 2, 3, 4, 5], '__package__': None, 'sys': <module 'sys' (built-in)>, 'item': 5, 'myfile': <module 'myfile' from 'myfile.py'>, 'T': [1, 3, 5, 7, 2, 4, 6], 'kwargs': {'a': 'spam', 's': 5}, '__name__': '__main__', 'path': ['', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python27.zip', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/plat-linux2', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-tk', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-old', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-dynload', '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7', '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/plat-linux2', '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/lib-tk', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages'], 'foo': <function foo at 0x7f15843bd050>, 'foo1': <function foo1 at 0x7f15843bd2a8>, '__doc__': None}
>>> foo1.func_defaults

>>> foo1.func_dict		# Атрибут Функции - дает закрепленный за Функцией Словарь
{'count': 1}


""" Анонимные Функции lambda """
lambda argument1, argument2,... argumentN : Выражение, использующее аргументы	# Конструкция

Предназначена для очень простых операций. выполняемых одним выражение (без if), могут быть вложенными функциями которые возвращают результат действия над аргументами

>>> s=lambda z,x,c: z+x+c	# Пример, как обячная Функция принимает аргументы и делает логику с Ними
>>> s(2,4,6)
12


>>> s=lambda z='111',x='222',c='333': z+x+c	# Аргументы могут быть Именованными
>>> s('555')				 	# имена аргументов могут меняться
'555222333'

>>> s('555', '666')
'555666333'


# файл myfile
def knights():
	title='Sir'
	action=(lambda x: title + '  ' + x)
	return action

>>> reload(myfile)
<module 'myfile' from 'myfile.py'>
>>> myfile.knights()
<function <lambda> at 0x7f15843bd488>	# Вложенная функция lambda  в функции knights()
>>> from myfile import knights
>>> A=knights()				# Создали Объект Функции
>>> A('Yurii')				# Передали в Объект Функции параметр для lambda
'Sir  Yurii'


>>> L=[lambda x: x**2,			# Полученный Аргумент сразу преобразуется Функцией
...    lambda x: x**3,
...    lambda x: x**4]

>>> for item in L: print(item(5),)	# Вывод каждый элемент в кортеж
... 
(25,)
(125,)
(625,)
>>> for item in L: print(item(5))	# Вывод каждый элемент - значение
... 
25
125
625
>>> for item in L: print(item(5)),	# Вывод в ряд
... 
25 125 625


def f1(x): return x ** 2
def f2(x): return x ** 3
def f3(x): return x ** 4 		# Именованные Функции

L = [f1, f2, f3] 			# Создали Список из Объектов Функций

for f in L:
	print(f(2)) 			# Запуск цикла Пердачи аргумента Функциям для lambda



>>> lower = (lambda x, y: x if x < y else y)	# Конструкция a if b / else c
>>> lower(‘bb’, ‘aa’)
‘aa’



>>> def action(x):
...     return (lambda y: x+y)		# Создаем Функцию в Функции
... 
>>> act=action(99)			# Объект наследует Объемлющую функцию // передаем х/сохраняет
>>> act			
<function <lambda> at 0x7f851a29c1b8>

>>> act(2)				# Обращаемся к Вложенной функции // передаем значение для y
101
>>> act(4)
103
>>> act(5)
104
>>> act
<function <lambda> at 0x7f851a29c1b8>



""" map - Работа с Последовательностями - Функциональное программирование ФП"""
Функция map применяет указанную функцию к  каждому элементу последовательности и возвращает список, содержащий результаты всех вызовов функции.

>>> def foo(x): return (x+15)		# Логика Функции
... 
>>> res=map(foo, [1,2,3,4])		# Даем Функции Последовательность // Мапаем
>>> res
[16, 17, 18, 19]

>>> L=[1,2,3,4,5]			# Мапаем
>>> res=map(foo, L)
>>> res
[16, 17, 18, 19, 20]

Функция map ожидает получить в  первом аргументе функцию, поэтому здесь часто можно встретить lambda-выражения

>>> foo
<function foo at 0x7f851a29c230>
>>> map(foo, (1,2,3,4))			# Передается Кортеж
[16, 17, 18, 19]
>>> map(foo, {1,2,3,4})			# Передается Множество
[16, 17, 18, 19]


>>> pow(3,4)				# Это встроенная функция возведения в Степень (пример)
81
>>> map(pow, [1,2,3], [4,5,6])		# map обрабатывает две последовательности по функции //2**5
[1, 32, 729]


""" filter - Функциональное программирование ФП """
>>> L=filter(lambda x: x>0, range(-5,5))	# Отберает последовательность по Условию Функции (True)
>>> L
[1, 2, 3, 4]

>>> L=filter(None, range(-5,5))		# Все True, 0 - False
>>> L
[-5, -4, -3, -2, -1, 1, 2, 3, 4]


""" reduce - Функциональное программирование ФП """
Функция последовательно возвращает объект и последовательно опять применяет к нему функцию добавляя элемент из последовательности

>>> reduce(lambda x,y: x+y, [3,4,5])
12


""" Итераторы и Генераторы """

# Генераторы Списков
>>> Ord=[]
>>> for item in 'spam':			# Создание Списка через аппенд каждого элемента строки
...     Ord.append(ord(item))
... 
>>> Ord
[115, 112, 97, 109]

>>> Ord=map(ord, 'spam')		# То же самое проще через маппинг
>>> Ord
[115, 112, 97, 109]

>>> [ord(x) for x in 'spam']		# А вот настоящий Генератор списка, Итерация через For
[115, 112, 97, 109]
>>> (ord(x) for x in 'spam')
<generator object <genexpr> at 0x7f851a2379b0>	# Информация


# Добавление Проверки Логики  if
>>> [x for x in range(5) if x % 2 == 0]
[0, 2, 4]

>>> list(filter((lambda x: x % 2 == 0), range(5)))	# То же
[0, 2, 4]


# Две логики в Генераторе Списка
>>> [x ** 2 for x in range(10) if x % 2 == 0]		
[0, 4, 16, 36, 64]

>>> list(map((lambda x: x**2), filter((lambda x: x % 2 == 0), range(10))))	# То же
[0, 4, 16, 36, 64]


# Отдельная итерация для каждого аргумента
>>> res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]
>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]

>>> res = []
>>> for x in [0, 1, 2]:			# Аналог - Вложенный цикл
... 	for y in [100, 200, 300]:
... 		res.append(x + y)
...
>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]

# Генератор Списка с итерацией и конкатинацией элементов Строк
>>> [x+y for x in 'spam' for y in 'cosmopoliten']
['sc', 'so', 'ss', 'sm', 'so', 'sp', 'so', 'sl', 'si', 'st', 'se', 'sn', 'pc', 'po', 'ps', 'pm', 'po', 'pp', 'po', 'pl', 'pi', 'pt', 'pe', 'pn', 'ac', 'ao', 'as', 'am', 'ao', 'ap', 'ao', 'al', 'ai', 'at', 'ae', 'an', 'mc', 'mo', 'ms', 'mm', 'mo', 'mp', 'mo', 'ml', 'mi', 'mt', 'me', 'mn']


# Генератор Списка с итерацией, картежем и проверкой на True
>>> [(x,y) for x in range(5) if x%2==0 for y in range(7) if y%2==1]
[(0, 1), (0, 3), (0, 5), (2, 1), (2, 3), (2, 5), (4, 1), (4, 3), (4, 5)]


>>> res = []				# То же самое Логикой Цикла
>>> for x in range(5):
... 	if x % 2 == 0:
... 		for y in range(5):
... 			if y % 2 == 1:
... 				res.append((x, y))
...
>>> res
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]


# Генератор Списка и Матрицы
>>> L=[[1,2,3], 
	[4,5,6], 
	[7,8,9]]
>>> [row[2] for row in L]		# Так просто
[3, 6, 9]

>>> [L[i][i] for i in range(len(L))]	# Срез по диагонали Матрицы
[1, 5, 9]


# Логика обработки двух матриц
>>> [M[row][col] * N[row][col] for row in range(3) for col in range(3)]		# Это уже разрыв Мозга:)
[2, 4, 6, 12, 15, 18, 28, 32, 36]
>>> [[M[row][col] * N[row][col] for col in range(3)] for row in range(3)]
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]


>>> open(‘myfile’).readlines()
[‘aaa\n’, ‘bbb\n’, ‘ccc\n’]		#  как отсечь \n при чтении строк файла ?

>>> [line.rstrip() for line in open(‘myfile’).readlines()]	# А вот как
[‘aaa’, ‘bbb’, ‘ccc’]

# Операция Извлечения Столбца
>>> list_tu=[('Lena', 'Run', '40'), ('Yurii', 'Ryndin', '39')]	# Список из кортежей

>>> [age for (name, lastname, age) in list_tu]			# Извлекаем Столбец по присовен Имени
['40', '39']
>>> [name  for (name, lastname, age) in list_tu]
['Lena', 'Yurii']

>>> map(lambda (name,lastname, age): age, list_tu)		# То же с помощью Меппинга
['40', '39']


""" Функции - генераторы - yield """ наверное в переводе близко "выход продукта"
Функции-генераторы при приостановке автоматически сохраняют информацию о своем состоянии, под которым
понимается вся локальная область видимости, со всеми локальными переменными, которая становится доступной сразу же, как только функция возобновляет работу.
Главное отличие функций-генераторов от обычных функций состоит в том, что функция-генератор поставляет значение, а не возвращает его – инструкция yield приостанавливает работу функции и  передает значение вызывающей программе, при этом сохраняется информация о  состоянии, необходимая, чтобы возобновить работу с  того места, где она была приостановлена.


>>> def gensq(N):
...     for item in range(7):
...         yield item**3		# Функция - Генератор с оператором yield

>>> for item in gensq(6):		
...     print (item,' // '),
... 
(0, ' // ') (1, ' // ') (8, ' // ') (27, ' // ') (64, ' // ') (125, ' // ') (216, ' // ')

>>> x= gensq(5)			# Вызов функции-генератора Создает Объект-генератор (iter + next)
>>> x
<generator object gensq at 0x7f09e3d07190>

>>> dir(x)
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', 
'__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 
'next', 
'send', 'throw']


>>> for x in [n**2 for n in range(5)]:	# То же самое но yield лучше так как не делает сразу весь массим а выводит значение поэлементно, при этом освобождается память, важно при больших массовах
... print(x, end=’ : ‘)


iter -> next -> send - это yield 	# Концепция


""" Выражения-Генераторы к Генераторам Списков """
>>> [x**3 for x in range(5)]		# Генератор списка:  в []
[0, 1, 8, 27, 64]

>>> (x**3 for x in range(5))		# Выражение - генератор в ()
<generator object <genexpr> at 0x7f09e3d07280>

>>> list(x**3 for x in range(5))	# Все вместе: Выражение-генератор -> Генератор Списка
[0, 1, 8, 27, 64]


>>> G=(x**3 for x in range(5))		# Делаем Объект-Генератор
>>> G
<generator object <genexpr> at 0x7f09e3d07280>		# Объекты-Генераторы имеют метод next() 
>>> next(G)
0
>>> next(G)
1
>>> next(G)
8
>>> next(G)
27
>>> next(G)
64
>>> next(G)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration


>>> for num in (x**3 for x in range(5)):	# Цикл for + Выражение-Генератор
...     print(num, '->', num/2.00)
... 
(0, '->', 0.0)
(1, '->', 0.5)
(8, '->', 4.0)
(27, '->', 13.5)
(64, '->', 32.0)


# еще раз функция-генератор - экономит память
>>> def timesfour(S):
...     for item in S:
...         yield item*4
... 
>>> D=timesfour('collaps')		# Создаем Объект-Генератор - Наследник ? (это у классов)
>>> D
<generator object timesfour at 0x7f09e3c9aaf0>
>>> list(D)
['cccc', 'oooo', 'llll', 'llll', 'aaaa', 'pppp', 'ssss']

>>> D.__iter__				# Встроенные методы - Обертки
<method-wrapper '__iter__' of generator object at 0x7f09e3c9aaf0>
>>> D.next
<method-wrapper 'next' of generator object at 0x7f09e3c9aaf0>
>>> D.next()
'cccc'
...

""" Опять zip()""" - зипает последовательности. усекая их по меньшей последовательности
>>> a='asdfgh'
>>> b='qwer'
>>> list(zip(a,b))
[('a', 'q'), ('s', 'w'), ('d', 'e'), ('f', 'r')]
>>> list(zip(a))
[('a',), ('s',), ('d',), ('f',), ('g',), ('h',)]


""" Опять map()""" - Применяет Функцию на Последовательность
>>> list( map(abs, [-4,-3,-1,-2,0,1,2,3,4]) )
[4, 3, 1, 2, 0, 1, 2, 3, 4]

>>> list( sorted(map(abs, [-4,-3,-1,-2,0,1,2,3,4])) ) 	# Применили 2 метода (функции) к Списку
[0, 1, 1, 2, 2, 3, 3, 4, 4]


>>> def myfoo(foo, *args):		# Шаблон для Зипанья последовательностей по Заданой Ф-ции
...     res=[]
...     for args in zip(*args):		# Сначала Зипаем аргументы Последовательностей
...         res.append(foo(*args))	# Затем применяем Ф-цию к Зип Последовательностям
...     return res
... 
>>> myfoo(abs, [-20, -15, -10, 0, 4, 6])
[20, 15, 10, 0, 4, 6]
>>> myfoo(pow, [1,2,3], [5,6,7])
[1, 64, 2187]


def myfoo(foo, *seqs):		# То же самое через Генератор Списков
	return [func(*args) for args in zip(*seqs)]

# С использованием генераторов: yield и (...)
def mymap(func, *seqs):
	res = []
	for args in zip(*seqs):
		yield func(*args)

def mymap(func, *seqs):
	return (func(*args) for args in zip(*seqs))


>>> S=[1,2,3,4]

>>> S.pop(0)		# Отсекает Элемент по Индексу
1
>>> S
[2, 3, 4]


""" Собственная функция zip"""
>>> def myzip(*args):
...     iters=map(iter, args)			# использованы встроенные методы map zip
...     while iters:
...         res=[next(i) for i in iters]	# использован встроенный метод next
...         yield tuple(res)
... 
>>> myzip('asd', 'fgh')
<generator object myzip at 0x7ffb5fafdfa0>
>>> print myzip('asd', 'fgh')
<generator object myzip at 0x7ffb5fafdf50>
>>> list(myzip('asd', 'fgh'))
[('a', 'f'), ('s', 'g'), ('d', 'h')]


>>> def myzip(*args):
...     iters=map(iter, args)
...     while iters:
...         res=[next(i) for i in iters]
...         return tuple(res)		
... 
>>> list(myzip('asd', 'fgh'))
['a', 'f']


""" Итерация Строк из Файлов """
>>> import myfile
>>> myfile
<module 'myfile' from 'myfile.pyc'>
>>> for line in open('myfile.py'):
...     print line
... 
def knights():

	title='Sir'

	action=(lambda x: title + '  ' + x)

	return action


""" Генератор Множеств // Генератор Словарей """
>>> [x * x for x in range(10)] 		# Генератор списков: конструирует список
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 	# подобно вызову list(generator expr)
>>> (x * x for x in range(10))
<generator object at 0x009E7328> 	# Выражение-генератор: воспроизводит
					# элементы. Скобки часто необязательны
>>> {x * x for x in range(10)} 		# Генератор множеств, новинка в 3.0
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36} 	# {x, y} – литерал множества в 3.0
>>> {x: x * x for x in range(10)} 	# Генератор словарей, новинка в 3.0
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

>>> {x * x for x in range(10)}
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36} 	# Генератор
>>> set(x * x for x in range(10))
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36} 	# Генератор и конструктор типа
>>> {x: x * x for x in range(10)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
>>> dict((x, x * x) for x in range(10))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}


>>> [(x,y) for x in [1,2,3,4] if x<4 for y in [5,6,7] if y>5]	# итерация списка с условиями
[(1, 6), (1, 7), (2, 6), (2, 7), (3, 6), (3, 7)]

>>> {(x,y) for x in [1,2,3,4] if x<4 for y in [5,6,7] if y>5}	# То же - множества
set([(2, 7), (2, 6), (1, 6), (3, 6), (1, 7), (3, 7)])


>>> I=['spam', 'ham', 'apple']		# Как очень просто набрать Словарь из параметров
>>> P=[23,45,67]
>>> {x:y for x in I for y in P}
{'apple': 67, 'ham': 67, 'spam': 67}	# Не сортируется


>>> {x.upper():x*3 for x in ('spam', 'ham', 'spammy', 'dolly') if x[0]=='s'}
{'SPAMMY': 'spammyspammyspammy', 'SPAM': 'spamspamspam'}


""" модуль time // файл mytimer.py // Хронометраж выполнения функций"""

>>> import sys, mytimer			# Сама логика тайминга сохранена в файле mytimer.py

>>> import timeseqs			# Результат выполнения логики файла timeseqs.py, этот файл импортирует логику файла mytimer.py и применяет ее к логики описанных в файле функций чтобы их сравнить

2.7.9 (default, Apr  9 2015, 19:58:11)		# Результат Сравнения функций  
[GCC 4.8.2]
---------------------------------
forLoop  : 3.10473 => [0...9999]
---------------------------------
listComp : 1.64562 => [0...9999]
---------------------------------
mapCall  : 1.15128 => [0...9999]
---------------------------------
genExpr  : 2.24621 => [0...9999]
---------------------------------
genFunc  : 2.25115 => [0...9999]

# Пока не стоит особо увлекатсься таймингом выполенния и оптимизации функций, это важно в больших серьезным проктом в которые пока на раннем этапе развития не будет доступа, это материал для проработки на потом на высоком уровне. Но знать что это есть - надо.

""" Но! : Первый шаг на пути к  оптимизации программ на языке Python – это отказаться от всякой оптимизации! 
Основное внимание должно уделяться удобочитаемости и  простоте программного кода, и только потом код можно будет оптимизировать, если это действительно необходимо."""


""" Новый метод timeit """
>>> def foo():			# Функция для теста
...     return {x:y for x in ('spam', 'ham', 'apple') for y in (23,45,67)}
... 

>>> from timeit import timeit	# Новый метод тестирования скорости Функций (по умолчанию 1 млн.циклов)

>>> timeit (foo)		# Применение Метода к Функции
2.374166965484619
>>> timeit (foo, number = 10000)	# Результат при заданом количестве Циклов
0.0464780330657959
>>> timeit (foo, number = 100000)
0.28846311569213867
>>> timeit (foo, number = 100000)	# Видны флуктуации	
0.2773399353027344
>>> timeit (foo, number = 1000000)
2.4170279502868652


from timeseqs import * 	# Импортируем доступные Функции из файля (для теста)
>>> dir(timeseqs)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'elapsed', '
forLoop', 'genExpr', 'genFunc', 'listComp', 'mapCall', 
'mytimer', 'reps', 'repslist', 'result', 'sys', 'test']

>>> timeit(forLoop, number=1000)	# Запускаем Тест для функций, берем малое количество циклов
3.100804090499878
>>> timeit(listComp, number=1000)
1.7164177894592285
>>> timeit(mapCall, number=1000)
1.2071709632873535
>>> timeit(genExpr, number=1000)
2.256711006164551
>>> timeit(genFunc, number=1000)
2.28187894821167


""" Локальные имена в функциях определяются Статически, то есть в момент дефа или импорта функции. Есди к тому моменту Локальной переменной нет значения, то присваивается глобальное видимое функции - и это надо учитывать.
Пока не назначил локальную переменную на нее лучше не ссылаться"""

>>> def selector():
... 	print(X) 	# Переменная еще не существует! (Выдаст Ошибку)
... 	X = 88		# X классифицируется как локальная переменная
... 			# То же самое происходит при “import X”, “def X”...


>>> X = 99			# Глобальная переменная
>>> def selector():
... 	import __main__		# Импортировать вмещающий модуль (если нужна глобальная переменная)
... 	print(__main__.X)	# Квалифицированное обращение к глобальной версии


>>> def selector():
... 	global X		# Принудительное назначение переменной глобальной
... 	print(X)
... 	X = 88


""" Значения Функций по умолчанию """
def saver(x=[]):	# Создается объект - пустой список, внем значения по умолчанию
	x.append(1)	# добавляется к объекту по умолчанию//заданному
	print(x) 	# Объект списка сохраняется
			# При каждом вызове изменяется один и тот же объект!

>> saver([2])		# Значение по умолчанию не используется, есть заданное значение
[2,1 ]

>> saver()		# Вызов значения по умолчанию
[1]
>> saver()		# Список заполняется при каждом вызове значениями по умолчанию
[1,1]


>>> def saver(x=None):
... 	if x is None: 	# Аргумент отсутствует? 	
		x = []	# Создается все время объект пустого списка
	x.append(1)
	print(x)

>> saver([2])
[2,1]

>> saver()
[1]			# Список по умолчанию не накапливается А все время создается новый
>> saver()
[1]


>> def saver():
	saver.x.append(1)	# Задаем логику значения по умолчанию, но сам объект не создаем
	print(saver.x)

>> saver.x=[]			# Принудительно создаем объект функции по умолчанию
>> saver()
[1]				# Наполняем объект по умолчанию по логике функции

>> saver()
[1, 1]				# Продолжаем наполнять объект по умолчанию


""" Функции без возврата результата """
>>> def proc(x):
... 	print(x)		# Нет возвращаемого значения, возвращается None 



""" Модули """	import from  imp.reload  __name__  __all__  
# Глобальная область видимости
# Пространство имен, Замкнутые пакеты имен

# доступные модули находятся в   sys.modules

>>> for item in sys.modules:		# например так вызвать
...     print item, sys.modules[item]
 
>>> list(sys.modules.keys())		# А лучше так вызвать Импортир.модули
['tokenize', 'heapq', 'copy_reg', 'sre_compile', '_collections', 'locale', '_sre', 'functools', 'encodings', 'site', '__builtin__', 'gc', '__main__', 'operator', 'encodings.encodings', 'timeseqs', '_heapq', 'timeit', 'abc', 'posixpath', '_weakrefset', 'errno', 'encodings.codecs', 'sre_constants', 'imp', '_abcoll', 'collections', 'types', '_codecs', 'opcode', '_warnings', 'genericpath', 'stat', 'zipimport', 'encodings.__builtin__', 'string', 'warnings', 'UserDict', 'inspect', 'encodings.utf_8', 'repr', 'sys', 'codecs', 're', 'readline', 'os.path', 'strop', '_functools', '_locale', 'thread', 'keyword', 'signal', 'traceback', 'mytimer', 'pydoc', 'linecache', 'itertools', 'posix', 'encodings.aliases', 'time', 'exceptions', 'sre_parse', 'pkgutil', 'os', '_weakref', 'token', 'dis']


""" Добавление пути к папке с модулями (моими)"""
>>> sys.path.append('/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles')
>>> import myfile
>>> myfile
<module 'myfile' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.py'>


""" Функция reload(file)""" - перезагружает модули
>>> reload(myfile)
<module 'myfile' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.pyc'>
>>> reload(mytimer)
<module 'mytimer' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/mytimer.pyc'>

>>> reload(timeseqs)			# Перезагружает и запускает модуль
2.7.9 (default, Apr  9 2015, 19:58:11) 
[GCC 4.8.2]
---------------------------------
forLoop  : 3.41174 => [0...9999]
---------------------------------
listComp : 1.70130 => [0...9999]
---------------------------------
mapCall  : 1.15421 => [0...9999]
---------------------------------
genExpr  : 2.26340 => [0...9999]
---------------------------------
genFunc  : 2.26565 => [0...9999]
<module 'timeseqs' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/timeseqs.py'>



""" Файлы / Модули  import/from"""

>>> import myfile
>>> myfile
<module 'myfile' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.py'>
>>> myfile.printer("Hallo Yurii")	# Способ применения Функции как аргумента Модуля(файла)
Hallo Yurii


>>> from myfile import printer
>>> printer
<function printer at 0x7ff64e4860c8>
>>> printer("Hallo Elena")		# Способ Прямого вызова Функции
Hallo Elena

>>> from myfile import *		# Вызывает все объекты Модуля (классы, функции)


>>> reload(myfile)			# Перезагружает (переимпортирует) Модуль
Hallo					# Добавлена операция в модуль Принт слова
<module 'myfile' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.py'>
>>> myfile.spam				# добавлена Глобальная переменная в Модуль
2


>>> from myfile import x,y
>>> x
10
>>> y
[20, 30]				# значения Переменных из Модуля

>>> x=20				# Переназначаем значения
>>> y[0]=40
 
>>> x					# локально в Интерпретаторе изменения
20
>>> y
[40, 30]

>>> myfile.x				# объект не поменялся
10
>>> myfile.y
[40, 30]				# объект поменялся


# Модули - это Пространства Имен 
# Хорошая конструкция - import modul // modul.metod     
# но и это хорошо - import mod // from mod import metod - - но можеть перекрывать пространства имен
# Во время импорта модуля создается пустой объект со всеми атрибутами модуля, проходя весть код

"Импортированный Объект Модуля "
>>> dir(myfile)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'printer', 'spam', 'x', 'y']


"Импортированный Объект Модуля - все параматры" - Фактически Это Структура Создаваемых Объектов
>>> myfile.__dict__			# В виде Словаря атрибутов
{'printer': <function printer at 0x7ff64e486230>, 'spam': 4, '__builtins__': {'bytearray': <type 'bytearray'>, 'IndexError': <type 'exceptions.IndexError'>, 'all': <built-in function all>, 'help': Type help() for interactive help, or help(object) for help about object., 'vars': <built-in function vars>, 'SyntaxError': <type 'exceptions.SyntaxError'>, 'unicode': <type 'unicode'>, 'UnicodeDecodeError': <type 'exceptions.UnicodeDecodeError'>, 'memoryview': <type 'memoryview'>, 'isinstance': <built-in function isinstance>, 'copyright': Copyright (c) 2001-2014 Python Software Foundation.
Copyright (c) 2000 BeOpen.com.
All Rights Reserved.
Copyright (c) 1995-2001 Corporation for National Research Initiatives.
All Rights Reserved.
Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.
All Rights Reserved., 'NameError': <type 'exceptions.NameError'>, 'BytesWarning': <type 'exceptions.BytesWarning'>, 'dict': <type 'dict'>, 'input': <built-in function input>, 'oct': <built-in function oct>, 'bin': <built-in function bin>, 'SystemExit': <type 'exceptions.SystemExit'>, 'StandardError': <type 'exceptions.StandardError'>, 'format': <built-in function format>, 'repr': <built-in function repr>, 'sorted': <built-in function sorted>, 'False': False, 'RuntimeWarning': <type 'exceptions.RuntimeWarning'>, 'list': <type 'list'>, 'iter': <built-in function iter>, 'reload': <built-in function reload>, 'Warning': <type 'exceptions.Warning'>, '__package__': None, 'round': <built-in function round>, 'dir': <built-in function dir>, 'cmp': <built-in function cmp>, 'set': <type 'set'>, 'bytes': <type 'str'>, 'reduce': <built-in function reduce>, 'intern': <built-in function intern>, 'issubclass': <built-in function issubclass>, 'Ellipsis': Ellipsis, 'EOFError': <type 'exceptions.EOFError'>, 'locals': <built-in function locals>, 'BufferError': <type 'exceptions.BufferError'>, 'slice': <type 'slice'>, 'FloatingPointError': <type 'exceptions.FloatingPointError'>, 'sum': <built-in function sum>, 'getattr': <built-in function getattr>, 'abs': <built-in function abs>, 'exit': Use exit() or Ctrl-D (i.e. EOF) to exit, 'print': <built-in function print>, 'True': True, 'FutureWarning': <type 'exceptions.FutureWarning'>, 'ImportWarning': <type 'exceptions.ImportWarning'>, 'None': None, 'hash': <built-in function hash>, 'ReferenceError': <type 'exceptions.ReferenceError'>, 'len': <built-in function len>, 'credits':     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
    for supporting Python development.  See www.python.org for more information., 'frozenset': <type 'frozenset'>, '__name__': '__builtin__', 'ord': <built-in function ord>, 'super': <type 'super'>, '_': None, 'TypeError': <type 'exceptions.TypeError'>, 'license': See http://www.python.org/2.7/license.html, 'KeyboardInterrupt': <type 'exceptions.KeyboardInterrupt'>, 'UserWarning': <type 'exceptions.UserWarning'>, 'filter': <built-in function filter>, 'range': <built-in function range>, 'staticmethod': <type 'staticmethod'>, 'SystemError': <type 'exceptions.SystemError'>, 'BaseException': <type 'exceptions.BaseException'>, 'pow': <built-in function pow>, 'RuntimeError': <type 'exceptions.RuntimeError'>, 'float': <type 'float'>, 'MemoryError': <type 'exceptions.MemoryError'>, 'StopIteration': <type 'exceptions.StopIteration'>, 'globals': <built-in function globals>, 'divmod': <built-in function divmod>, 'enumerate': <type 'enumerate'>, 'apply': <built-in function apply>, 'LookupError': <type 'exceptions.LookupError'>, 'open': <built-in function open>, 'quit': Use quit() or Ctrl-D (i.e. EOF) to exit, 'basestring': <type 'basestring'>, 'UnicodeError': <type 'exceptions.UnicodeError'>, 'zip': <built-in function zip>, 'hex': <built-in function hex>, 'long': <type 'long'>, 'next': <built-in function next>, 'ImportError': <type 'exceptions.ImportError'>, 'chr': <built-in function chr>, 'xrange': <type 'xrange'>, 'type': <type 'type'>, '__doc__': "Built-in functions, exceptions, and other objects.\n\nNoteworthy: None is the `nil' object; Ellipsis represents `...' in slices.", 'Exception': <type 'exceptions.Exception'>, 'tuple': <type 'tuple'>, 'UnicodeTranslateError': <type 'exceptions.UnicodeTranslateError'>, 'reversed': <type 'reversed'>, 'UnicodeEncodeError': <type 'exceptions.UnicodeEncodeError'>, 'IOError': <type 'exceptions.IOError'>, 'hasattr': <built-in function hasattr>, 'delattr': <built-in function delattr>, 'setattr': <built-in function setattr>, 'raw_input': <built-in function raw_input>, 'SyntaxWarning': <type 'exceptions.SyntaxWarning'>, 'compile': <built-in function compile>, 'ArithmeticError': <type 'exceptions.ArithmeticError'>, 'str': <type 'str'>, 'property': <type 'property'>, 'GeneratorExit': <type 'exceptions.GeneratorExit'>, 'int': <type 'int'>, '__import__': <built-in function __import__>, 'KeyError': <type 'exceptions.KeyError'>, 'coerce': <built-in function coerce>, 'PendingDeprecationWarning': <type 'exceptions.PendingDeprecationWarning'>, 'file': <type 'file'>, 'EnvironmentError': <type 'exceptions.EnvironmentError'>, 'unichr': <built-in function unichr>, 'id': <built-in function id>, 'OSError': <type 'exceptions.OSError'>, 'DeprecationWarning': <type 'exceptions.DeprecationWarning'>, 'min': <built-in function min>, 'UnicodeWarning': <type 'exceptions.UnicodeWarning'>, 'execfile': <built-in function execfile>, 'any': <built-in function any>, 'complex': <type 'complex'>, 'bool': <type 'bool'>, 'ValueError': <type 'exceptions.ValueError'>, 'NotImplemented': NotImplemented, 'map': <built-in function map>, 'buffer': <type 'buffer'>, 'max': <built-in function max>, 'object': <type 'object'>, 'TabError': <type 'exceptions.TabError'>, 'callable': <built-in function callable>, 'ZeroDivisionError': <type 'exceptions.ZeroDivisionError'>, 'eval': <built-in function eval>, '__debug__': True, 'IndentationError': <type 'exceptions.IndentationError'>, 'AssertionError': <type 'exceptions.AssertionError'>, 'classmethod': <type 'classmethod'>, 'UnboundLocalError': <type 'exceptions.UnboundLocalError'>, 'NotImplementedError': <type 'exceptions.NotImplementedError'>, 'AttributeError': <type 'exceptions.AttributeError'>, 'OverflowError': <type 'exceptions.OverflowError'>}, '__file__': '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.pyc', '__package__': None, 'x': 10, 'y': [20, 30], '__name__': 'myfile', '__doc__': None}



""" Перезагрузка Модуля """
# импорт модуля за пускает его код только один раз за сессию, а затем только показывает информацию 
# о модуле, а reload перезапускает выполнение кода, при этом может расширить область имен.
>>> reload(myfile)			# Перезадали содержимое файла и перезагркзили его (модуль)
starting to load...
done loading.
<module 'myfile' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.py'>

>>> dir(myfile)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'func', 'klass', 'name', 'printer', 'spam', 'sys', 'x', 'y']
или
>>> myfile.__dict__.keys()
['printer', 'name', 'spam', '__builtins__', '__file__', '__package__', 'sys', 'klass', 'func', 'x', 'y', '__name__', '__doc__'] 		# в Объекте Модуля остались старые Атрибуты + Новые (Пространство Имен)
>>> myfile.x
10
>>> myfile.y
[20, 30]

<module 'sys' (built-in)>		# В Объекте (Пространстве Имен) выдны параметры объектов
>>> myfile.klass
<class myfile.klass at 0x7ff64e480188>
>>> myfile.func
<function func at 0x7ff64e486320>

>>> myfile.__name__			# Имя Модуля
'myfile'			

>>> myfile.__file__			# Имя Файла откуда импорт был
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myfile.py'
>>> 

# Версия Питон3
import imp
from imp import reload
imp.reload()


>>> dir(changer)		# Задали функцию и переменную в Файле
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'message', 'printer']
>>> changer.printer()
First Version			# Старое значение переменной message
>>> changer.printer()

>>> reload(changer)		# Перезагрузили файл // Обновился Модуль (Объект) // Новые значения
<module 'changer' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/changer.py'>
>>> changer.printer()
('reloaded: ', 'Last Version')
>>> 

"""
Возможность повторной загрузки позволяет программам обеспечивать высокодинамичные интерфейсы. Например,
Python часто используется как язык для создания сценариев настройки в  крупных системах  – пользователи могут настраивать программные продукты под свои нужды за счет создания небольших встраиваемых сценариев на языке Python, не пересобирая весь продукт целиком (или вообще не имея исходных текстов программ). Возможность внедрения сценариев на языке Python в таких системах сама по себе привносит динамические особенности.
"""


""" Импорт Пакетов """

# Каталог == Пакет == Папка

# Пространство имен Пакета = Имена Подпапок + имена Файлов

>>> import sys
>>> sys.path
['', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python27.zip', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/plat-linux2', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-tk', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-old', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/lib-dynload', '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7', '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/plat-linux2', '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/lib-tk', '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages', 
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles', 
		# путь где головная дирректория (директория 0 уровня)
'/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages']
>>> import dir1.mod1	#путь к директории(Пакету) и файлу в ней (в директории нужен пустой __init__.py)
3
2
3
1
2
3
>>> dir(dir1)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'mod1', 'mod2', 'mod3']
	# Пространства Имен Директории (Пакета) в т.ч. имена Файлов (моделей) 

>>> dir1.__dict__
{'mod1': <module 'dir1.mod1' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/mod1.pyc'>, 
'mod2': <module 'dir1.mod2' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/mod2.pyc'>, 
'mod3': <module 'dir1.mod3' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/mod3.pyc'>, 
'__builtins__': {'bytearray': <type 'bytearray'>, 'IndexError': <type 'exceptions.IndexError'>, 'all': <built-in function all>, 'help': Type help() for interactive help, or help(object) for help about object., 'vars': <built-in function vars>, 'SyntaxError': <type 'exceptions.SyntaxError'>, 'unicode': <type 'unicode'>, 'UnicodeDecodeError': <type 'exceptions.UnicodeDecodeError'>, 'memoryview': <type 'memoryview'>, 'isinstance': <built-in function isinstance>, 'copyright': Copyright (c) 2001-2014 Python Software Foundation.
All Rights Reserved.
...
'__file__': '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/__init__.pyc', 
'__package__': None, 
'__path__': ['/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1'],
 '__name__': 'dir1', 
'__doc__': None}




>>> dir1.__path__			# Путь к Дерритории (Пакету)
['/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1']

>>> dir1		# Пакет оказывается модуль от Инита
<module 'dir1' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/__init__.pyc'>


>>> dir1.mod1
<module 'dir1.mod1' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/mod1.pyc'>
>>> from dir1 import mod1
>>> mod1				# Модуль один как не спроси / но с ипортом файла 
<module 'dir1.mod1' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/mod1.pyc'>


>>> import dir1.dir2.mod
>>> from dir1.dir2.mod import z		# Взять переменную z из файла mod (dir1\dir2\mod.py)
>>> z
4


# Принцип перезагрузки кода в файлах __init__.py  mod.py
>>> reload(dir1)
dir1 init
<module 'dir1' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/__init__.pyc'>
>>> reload(dir1.dir2)
dir2 init
<module 'dir1.dir2' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/dir2/__init__.pyc'>
>>> reload(dir1.dir2.mod)
in mod.py
<module 'dir1.dir2.mod' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/dir1/dir2/mod.pyc'>

>>> dir1.dir2.y				# вызов переменой из инит файла в дирректории
2
>>> dir1.dir2.mod.z			# вызов переменной из файла mod.py
4


>>> from dir1.dir2 import mod		# Позволяет сократить многократный вызов переменной
>>> mod.z
4

""" Правильный import // from """
from . import spam		# синтаксис Импортирования Модуля из текущего (рабочего) каталога
from .spam import name		# импортирование Атрибута из импортированного Модуля текущего каталога
# при этом системные пути поиска path игнорируются


from . string import name1, name2	# Явный импорт объектов Модуля который в папке Текущего проекта
# так в версии Питон3, если без точки то ищет по пути в sys.path, но не в локальной папке  


# правильный импорт с использование путей в sys.path
from system.section.mypkg import string 	# sys.path содержит только system

from . import string		# Тот же вариант в Питоне3
# Синтаксис импортирования относительно текущего пакета


""" Чтобы получить возможность импортировать, например, A.B.C, каталог A должен находиться в одном из каталогов, перечисленных в пути поиска модулей sys.path, B должен быть подкаталогом пакета в каталоге A, а C должен быть модулем или другим компонентом в каталоге B, доступным для импортирования. """


""" Управление операции import """
__all__ = [“Error”, “encode”, “decode”] 	# Экспортируются только эти имена методом import *

# или назвать глобальную переменную в модуле _X - import *  ее не увидит.
# в файле __init__.py  - __all__=[]  можно задать имена субмодулй не реагирующих на import *



"""  метод   if __name__ == '__main__': """
# Если файл запускается как главный файл программы, атрибуту __name__ на запуске присваивается значение “__main__”.
# Если файл импортируется, атрибуту __name__ присваивается имя модуля, под которым он будет известен клиенту (то есть создается объект файла)

# файл changer.py
__all__=['message']

print('I am ', __name__)

message="The New Version"

def printer():
	print ("reloaded: ", message)

if __name__=='__main__':
	printer()

# его запуск как основной программы а не импорта
(studentsdb)ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python changer.py
('reloaded: ', 'The New Version')
# срабатывает две последние строки файла - при условии что файл находится в корневой папке проекта .../src/studentsdb$

""" 
Главный, Запускающий модель имеет атрибут '__main__', остальные все модули и пакеты - это импорты.
"""

# файл changer.py
print('I am ', __name__)		# добавили Инструкцию в Файл

>>> reload(changer)
('I am ', 'changer')			# При импорте и вызове (библиотека) дает __name__=='__name__'

(studentsdb)ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python changer.py
('I am ', '__main__')			# При запуска как главная программа дает __name__=='__main__'
('reloaded: ', 'The New Version')



""" import // from // as """ - конструкция импорт // как - действует только внутри модуля
import reallylongmodulename as name		# переводит длинное имя модуля в короткое 
name.func() 					# Использовать короткий псевдоним

from module1 import utility as util1		# Псевдоним объектов для избежания Затерания 
from module2 import utility as util2
util1(); util2()

import dir1.dir2.mod as mod			# Псевдоним модулю с длинным путем инициации
mod.func()


M.name				# Доступ к атрибуту в модуле М
M.__dict__[‘name’]		# То же самое через Словарь имен атрибутов 
sys.modules[‘M’].name		# то же самое через Список доступных модулей Интерпритатора
getattr(M, ‘name’)		# То же самое через 


# вот пример с Модулем changer.py в котором Переменная   __all__=['message']
>>> reload(changer)			
('I am ', 'changer')
<module 'changer' from 'changer.pyc'>
>>> changer
<module 'changer' from 'changer.pyc'>

>>> changer.__all__
['message']					##

>>> changer.__dict__['__all__']
['message']

>>> sys.modules['changer'].__all__
['message']

>>> getattr(changer, '__all__')			##
['message']




""" Классы   ООП """
## Для ООП необходима Иерархия Наследования - и это Классы.
#  Мы разлагаем программный код на составляющие, чтобы уменьшить его избыточность, и  пишем новые программы, адаптируя имеющийся программный код, а не изменяя его.

# Класс - Это множество экземпляров и свое пространство имен
# Наследование - это создание экземпляра Класса (наследование), возможна его расширение возможностей (адаптация)

# Сеперклассы (базовые) --> Подклассы (дочерние/адаптированы)

# Атрибут ищется по всему дереву Класса снизу вверх (от подкласса к суперсклассу) и слева направо

class C2:	# СуперКласс	// по новому стилю наследует от (object)	
class C3:	# СуперКласс
class C1(C2, C3): 	# Класс - Наследник (Эксземпляр)

I1 = C1()		# Экземпляр Класса (инстанс)
I2 = C1()		# Экземпляр Класса (Инстанс)


""" Класс // Создание """ 
>>> class C1(object):		# Создали Класс // По новому стилю наследуется от object
...     def setname(self, who):
...         self.name=who
... 
>>> I1=C1()			# создали Наследник (I1) Класса (C1)
>>> isinstance(I1, C1)		# проверка что это Наследник
True

>>> I1.setname('Yurii')		# задали Наследнику значение параметра name
 
>>> I1
<__main__.C1 object at 0x7f984b2b0450>	# Для Наследника мейном есть Класс-родитель

>>> C1
<class '__main__.C1'>			# Класс C1 является Суперклассом (__main__)

>>> print (I1.name)		# Вывели значение параметра из Наследника (I1) класса (C1) 
Yurii

>>> dir(C1)	# В Классе как Родителе есть только атрибут/функция setname
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'setname']

>>> dir(I1)	# В наследнике Класса создается и хранится параметр name + остальные имена
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'setname']

# file myclass
class C1(object):			# В модуле создается класс C1
	def __init__(self, who):	# метод self срабатывает автоматом в Наследнике класса
		self.name = who		# В Наследнике создается переменная name // входит как who 


>>> reload(myclass)
<module 'myclass' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myclass.py'>
>>> myclass
<module 'myclass' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myclass.py'>

>>> dir(myclass)
['C1', '__builtins__', '__doc__', '__file__', '__name__', '__package__']  # Пространство Имен Модуля

>>> myclass.C1
<class 'myclass.C1'>

>>> I1=myclass.C1('Yurii')		# Создаем Объект/Наследник через класс с задачей параметра (в инит)

>>> I1
<myclass.C1 object at 0x7f984b2b0650>	# у Наследника есть путь к Классу-Родителю

>>> dir(I1)				# Пространство Имен у Наследника - есть инициированный параметр name
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name']

>>> print I1.name			# Вывод параметра Наследника(Инстанса)
Yurii


""" !!! Используя классы, мы программируем, адаптируя написанное программное обеспечение, вместо того, чтобы изменять существующий программный код или писать новый код в каждом новом проекте. """

# Фреймворк - это Готвая Библиотека СуперКлассов - Бери / Наследуйся / Создавай Инстансы !!!

# Программирование в мире ООП Python – это лишь вопрос сборки уже отлаженного программного кода и настройки его путем написания своих собственных подклассов


# логика СуперКласса в файле myclass.py
class FirstClass(object):
	
	def setdata(self, value):
		self.data = value

	def display(self):
		print (self.data)


>>> from myclass import FirstClass	# Импорт Сласса в Интерпретатор
>>> FirstClass
<class 'myclass.FirstClass'>

>>> x=FirstClass()	# Создаем 2 Инстанса Класса, Пока они пустые, Это просто Пространства Имен
>>> y=FirstClass()
>>> x,y
(<myclass.FirstClass object at 0x7f984b2b0850>, <myclass.FirstClass object at 0x7f984b2b07d0>)

>>> x.setdata("Its my Class")		# Применяем первую функцию Класса - задаем переменные
>>> y.setdata(1123.456)

>>> x.display()				# Применяем вторую переменную Класса
Its my Class
>>> y.display()
1123.456

>>> x.data='Ryndin Yurii'	# Можно напрямую переназначить значение Атрибута Инстанса
>>> x.display()
Ryndin Yurii

# логика ПодКласса в файле myclass.py
class SecondClass(FirstClass):		# Наследует пространство имен от СуперКласса/Родителя
	def display(self):		# переназначение метода display
		print('Current value = %s ' % self.data)


>>> reload(myclass)		# Загружаем Второй Класс - Наследник первого
<module 'myclass' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myclass.py'>
>>> dir(myclass)
['C1', 'FirstClass', 'SecondClass', '__builtins__', '__doc__', '__file__', '__name__', '__package__']
>>> from myclass import SecondClass

>>> z=SecondClass()		# Создаем объект в ПодКлассе
>>> z.setdata(123456)		# при вызове метод setdata находится в Классе/Родителе
				# Значение сохраняется в объекте ПодКласса

>>> z.display()			# метод переназначен в Классе/Наследнике (ПодКласс)
Current value = 123456

# но метод display в Родительском классе тоже сохранился 
>>> x.display()
Ryndin Yurii


""" Присвоение Имен Классам / Обращение к Классам """
import person		# Классы полюбому в модулях(файлах). Есть правило имя Класса - с Большой буквы
x = person.Person()

from person import Person	# Или через импортирование Класса из Модуля
x=Person()



# логика ПодКласса в файле myclass.py
class ThirdClass(SecondClass):
	def __init__(self, value):
		self.data = value		# Переназначение data при Ините Третьего ПодКласса

	def __add__(self, other):
		return ThirdClass(self.data+other)	# Логика нового Инстанса при добавлении к 									Первому Инстансу (self==a)

	def __str__(self):			# Логика Строки при вызове самого Объекта Инстанса
		return '[ThirdClass: %s]' % self.data

	def mul(self, other):			# Обычная Функция переназначения данных Инстанса
		self.data*=other


>>> a=ThirdClass("abc")		# Задали значение data при Ините третьего ПодКласса
>>> a.display()			# Метод из второго ПодКласса  
Current value = abc

>>> print a
[ThirdClass: abc]		# Вызод Инстанса третьего ПодКласса дает Строку методом __str__

>>> b=a+'xyz'			# Инстанс(а) добавляется за счет метода __add__ - Создан новый Инстанс 
>>> b.display()
Current value = abcxyz 		# Значение нового Инстанса(в)
>>> print a						
[ThirdClass: abc]		# Первый Инстант(а) без изменений

>>> print b
[ThirdClass: abcxyz]		# Вызов второго Инстанса выдасть строку за счет __str__


>>> a.mul(3)			# За счет обычной Функции перезадается значение Первого Инстанса(а)
>>> a				# Функция определена в Третьем ПодКлассе (только для Инстансев)
<myclass.ThirdClass object at 0x7f984b2b0dd0>
>>> print a
[ThirdClass: abcabcabc]

>>> b.mul(4)			# За счет обычной Функции перезадается значение Второго Инстанса(а)
>>> print b
[ThirdClass: abcxyzabcxyzabcxyzabcxyz]
>>> b
<myclass.ThirdClass object at 0x7f984b2b0e10>


class rec(object): pass		# Класс с путным пространством Имен - ничего

>>> myclass.rec
<class 'myclass.rec'>
>>> from myclass import rec
>>> rec
<class 'myclass.rec'>

>>> rec.name='Yurii'	# Задаем объекту Класса Атрибуты - Интерактивно // В Классе все еще пуст0
>>> rec.age='40'

>>> rec
<class 'myclass.rec'>
>>> print rec
<class 'myclass.rec'>			# путь к СуперКлассу

>>> print rec.name
Yurii
>>> print rec.age			# Объект Класса сохраняет значения Атрибутов
40

>>> x=rec()				# Задаем Инстансы СуперКласса
>>> y=rec()
>>> x
<myclass.rec object at 0x7f984b242290>
>>> y
<myclass.rec object at 0x7f984b2b0850>

>>> x.name, y.name			# Инстатсы имеют путь к атрибутам Класса
('Yurii', 'Yurii')

>>> x.name='Lena'			# Перезадаем значение Атрибута в Инстансе Класса
>>> print (x.name, rec.name, y.name)	# Вывод значений Атрибутов по цепочке объектов Класса 
('Lena', 'Yurii', 'Yurii')


""" __dict__ - Словарь Пространства имен Объекта """
>>> rec.__dict__	# Это Класс - в нем Много Имен 
dict_proxy ({'__module__': 'myclass', 'name': 'Yurii', 'age': '40', '__dict__': <attribute '__dict__' of 'rec' objects>, '__weakref__': <attribute '__weakref__' of 'rec' objects>, '__doc__': None})

>>> x.__dict__		# Это Инстанс Класса - в нем мало Имен, в основном отсылка на имена Класса
{'name': 'Lena'}

>>> rec.__dict__.keys()		# Запомнить - Срез Ключей из Словаря
['__module__', 'name', 'age', '__dict__', '__weakref__', '__doc__']


""" __class__ - Ссылка на Класс/Родитель """
>>> x.__class__
<class 'myclass.rec'>
>>> rec.__class__
<type 'type'>


""" __bases__ - Ссылка в виде кортежа ни СуперКласс объекта """

>>> ThirdClass.__bases__
(<class 'myclass.SecondClass'>,)

>>> SecondClass.__bases__
(<class 'myclass.FirstClass'>,)

>>> FirstClass.__bases__
(<type 'object'>,)

>>> object.__bases__		# Выше - Цепочка из СуперКлассов Снизу/Вверх
()



>>> def upperName(self):
...     return self.name.upper()	# Создание Внешней Функции для преобразования строки
... 
>>> rec.foo=upperName			# Назначение Классу функции как переменной
>>> 
>>> x.foo()				# Инстанс (весть) наследует метод Класса от внешней функции для объекта name (обертка?)
'LENA'

>>> print x
<myclass.rec object at 0x7f984b242290>
>>> print x.name			
Lena

>>> rec.foo(x)				# Или так: Метод Класса с параметром в виде Инстанса (точно обертка)
'LENA'



""" Классы и Словари """
>>> class rec: pass		# Задали Класс без Инструкций
... 
>>> rec.name='Yurii'		# Задали параметры Класса в Словарь 
>>> rec.age=40
>>> rec.job='dev'

>>> rec
<class __main__.rec at 0x7f984b2ab188>

>>> rec.__dict__		# Прямо вызвали Словарь Класса
{'job': 'dev', 'age': 40, '__module__': '__main__', '__doc__': None, 'name': 'Yurii'}


>>> pers1=rec()			# Лучше создавать Инстанс Класса и с ним работать
>>> pers1
<__main__.rec instance at 0x7f984b241248>

>>> pers1.name='Lena'
>>> pers1.age=39
>>> pers1.job='econom'
>>> pers1.__dict__		# Наполнили Инстанс атрибутами, сохранены как Словарь
{'job': 'econom', 'age': 39, 'name': 'Lena'}


""" Полноценный Класс - Создание // Использование """
# файл myclass
class Person(object):
	def __init__(self, name, job, age):	# через self Инстанс принимает 3 аргумента
		self.name=name
		self.job=job
		self.age=age
	def info(self):				# через self Класс принимает логику выдачи параметров (задаются в ИТстансе). инстанс потом наследует эту логику вывода
		return (self.name, self.job, self.age)

>>> reload(myclass)
<module 'myclass' from '/home/ryndin/data/work/virtualenvs/studentsdb/lib/python2.7/site-packages/myfiles/myclass.pyc'>

>>> pers1=myclass.Person('Yurii', 'dev', 40)	# Создание Инстанса от Класса с параметрами
>>> pers2=myclass.Person('Lena', 'econom', 39)

>>> pers1.__dict__				# Вызов Словаря Инстанса - Там значения
{'age': 40, 'job': 'dev', 'name': 'Yurii'}
>>> pers2.__dict__
{'age': 39, 'job': 'econom', 'name': 'Lena'}

>>> pers1.info() 			# Вызов Инстансем метода из Класса с параметрами Инстанса
('Yurii', 'dev', 40)
>>> pers2.info()
('Lena', 'econom', 39)


""" Юникод - в начало каждого файла Питон """
# -*- coding: utf-8 -*-



""" Продвинутое создание Классов """
# self - Все берет в себя (накапливает как атрибут) где есть метод self / и Все передвет Инстансу

# __init__ - метод перегрузки оператора, инициирует создание Инстанса Класса и его начальных атрибутов

# __str__ - второй по чвастоте испоьзования оператор перегрузки, запускает логику когда Инстанс выводится в Строку для Вывода
# например без метода вызов Инстанса (sue) - <__main__.Person object at 0x7f05a3b47890>
# С методом выдов Инстанса (sue) дает строку (как задумали):  [Person: Sue Ryndina, 12100.0]


# файл person.py
# -*- coding: utf-8 -*-

# СуперКласс
class Person(object): 		# создание Экземпляра Класса
	def __init__(self, name, job=None, pay=0):
		self.name=name	 # self.neme - это атрибут экземпляра Класса
		self.job=job
		self.pay=pay

	# обработка Экземпляра Класса
	def lastName(self):	 	# внедрили метод(функцию) в Класс - Инкапсуляция
		return self.name.split()[-1]

	def giveRaise(self, percent):	 # Еще один Метод в Классе - пересчет параметра pay
		self.pay=float(self.pay*(1+percent))

	# Метод генерации Форматированной Строки при Ввызове Инстанса
	def __str__(self):					
		return ('[Person: %s, %s]' % (self.name, self.pay) )


# Модернизация в новый СубКласс // наследование логики от Суперкласса+Модернизация
class Manager(Person):
	def __init__(self, name, pay):	# модернизируем метод Инит для ПодКласса
		Person.__init__(self, name, 'mngr', pay)	# Вызываем метод Класса и задаем по умолчанию значение job='mngr'

	def giveRaise(self, percent, bonus=0.10):	# задаем новую логику расчета Функции (новый параметр)
		Person.giveRaise(self, percent+bonus)	# Нк копируем, а Обращаемся к Старой логике и делаем составной параметр


class Department(object):	# Создаем СуперКласс с методами для всего Департамента
	def __init__(self, *args):
		self.members = list(args) 	# При инициации Инстанса принимаем Аргументы для заполнения списка 

	def AddMembers(self, person):		# предусмотрен Метод добавления Объекта в Список
		self.members.append(person)

	def giveRaises(self, percent):		# предусмотрен метод для Каждого объекта в Списке имен Департамента 
		for pers in self.members:
			pers.giveRaise(percent)

	def showAll(self):	# предусмотрен Метод принта всех Объектов из списка имен Класса Департмент
		for pers in self.members:
			print pers


# test
if __name__ == '__main__':
	print ('--'*10)
	bob=Person('Bob Ryndin')	# это новое пространство имен, новая копия объекта и путей
	sue=Person('Sue Ryndina', job='dev', pay=10000)		# значения атрибутов перезадаются

	print(bob.name, bob.pay) 	# Инстанс и значение параметра при Ините
	print(sue.name, sue.pay)
	print ('--'*10)

	print('%s  %s ' % (bob.name, bob.pay) )		# Форматирование Строк дает результат без скобок(2 варианта)
	print('{0}  {1}'. format (sue.name, sue.pay) )
	print ('--'*10)

	print(bob.name.split() )
	print(sue.pay)
	print ('--'*10)

	print ('%s  %s' % (bob.lastName(), sue.lastName()) )
	sue.giveRaise(.10)		# Применение метода Класса к Инстансу sue
	print (sue.pay)			# Вызоп парамкетра Инстанса
	print ('--'*10)
	print sue                   # метод __str__ при вызове Инстанса - выдает Форматированную Строку 
	print ('--'*10)

	tom=Manager('Tom Jones', 50000)	# Создан Экземпляр СубКласса, параметры как в СуперКлассе
	tom.giveRaise(0.10)		# Функции СубКласса передано значение
	print (tom.lastName())		# Логика от Суперкласса
	print tom 			# Вызов инстанса (запускается __str__)
	print ('--'*10)

	print ('-'*5, 'For All Three Person', '-'*5)
	for item in (bob, sue, tom):	# применяем for как Итератор вырвжения к последовательности
		item.giveRaise(0.10)	# Функция выберается из СубКласса или СуперКласса к разным Инстансам
		print item		# вызывает метод __str__
	print ('--'*10)

	development = Department(bob, sue)	# Делаем Инстанс дял СуперКласса Департмент (задаем 2 персонажа по умолчанию)
	development.AddMembers(tom)		# Используем метод наполнения Интанса объектом персонажа
	development.giveRaises(0.10)		# Вызываем метод 
	development.showAll()			# вызываем метод печати всех Имен Списка Департамента


# вывод person.py как отдельно исполняемой программы
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python person.py
--------------------
('Bob Ryndin', 0)
('Sue Ryndina', 10000)
--------------------
Bob Ryndin  0 
Sue Ryndina  10000
--------------------
['Bob', 'Ryndin']
10000
--------------------
Ryndin  Ryndina
11000.0
--------------------
[Person: Sue Ryndina, 11000.0]
--------------------
Jones
[Person: Tom Jones, 60000.0]
--------------------
('-----', 'For All Three Person', '-----')
[Person: Bob Ryndin, 0.0]
[Person: Sue Ryndina, 12100.0]
[Person: Tom Jones, 72000.0]
--------------------
[Person: Bob Ryndin, 0.0]
[Person: Sue Ryndina, 13310.0]
[Person: Tom Jones, 86400.0]


# вывод person.py в интерактивной оболочке интерпретатора
Python 2.7.9 (default, Apr  9 2015, 19:58:11) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.

>>> import person
>>> dir(person)
['Manager', 'Person', '__builtins__', '__doc__', '__file__', '__name__', '__package__']

>>> person.Manager
<class 'person.Manager'>
>>> dir(person.Manager)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'giveRaise', 'lastName']


# полезные методы вывода Инфо об Инстансах/Классах
instance.__class__	__name__	__bases__
object.__dict__ 	keys()		items()		

>>> reload(person)
<module 'person' from 'person.py'>
>>> from person import Person

>>> bob=Person('Bob Smith')

>>> print bob
[Person: Bob Smith, 0]

>>> bob.__class__
<class 'person.Person'>

>>> bob.__class__.__name__
'Person'

>>> list(bob.__dict__.keys())
['pay', 'job', 'name']


>>> for key in bob.__dict__: 
	print(key, '==>', bob.__dict__[key])
... 
('pay', '==>', 0)
('job', '==>', None)
('name', '==>', 'Bob Smith')

>>> for key in bob.__dict__: print(key, '==>', getattr(bob,key))
# сравните - метод  getattr  похоже выдает имена атрибутов Инстанса
... 
('pay', '==>', 0)
('job', '==>', None)
('name', '==>', 'Bob Smith')


""" Хринилище Объектов """ - похоже что устаревшее
# Методы    pickle(маринование)    dbm    shelve(отложить в долгий ящик)

# файл makedb.py

# -*- coding: utf-8 -*-

from person import Person, Manager		# Наследуем логику классов

bob=Person('Bob Smith')				# Создаем входные данные для инстансов Классов
sue=Person('Sue Jones', job='dev', pay=10000)
tom=Manager('Tom jones', 50000)

import shelve				# берем логику модуля "маринования"
db=shelve.open('persondb')		# логика создания переменной как открытого текущего файла
for object in (bob, sue, tom):		# логика присвоения переменной значений по ключу имен параметров инстансов
	db[object.name]=object		
db.close()				# логика закрытия//сохранения переменной

# Данные сохранились в свзяке двух файлов в рабочей дирректории (persondb.dat+persondb.dir) 
# такие Хранилища не поддерживают возможность выполнения запросов, например, на языке SQL, и испытывают недостаток дополнительных возможностей, которыми обладают развитые базы данных (такие как обработка транзакций), однако объекты, находящиеся в хранилище, способны использовать всю широту возможностей языка Python после того, как они будут извлечены обратно - наверное устаревший механизм.

>>> glob.glob('person*')
['person.py', 'persondb.dat', 'persondb.dir', 'person.pyc', 'persondb.bak'] # вся свзяка файлов

>>> print(open('persondb.dir')).read()	# сохраненная база в файле от файла person.py
'Tom jones', (1024, 153)
'Sue Jones', (512, 151)
'Bob Smith', (0, 137)

""" метод glob """
>>> import glob			# Позволяет найти файлы по имени в рабочей папке
>>> glob.glob('person*')
['person.py', 'persondb.dat', 'persondb.dir', 'person.pyc', 'persondb.bak']


# такой себе Клиент Базы данных
>>> reload(shelve)		# перезагрузка/импорт модуля
<module 'shelve' from '/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/shelve.pyc'>

>>> db=shelve.open('persondb')	# переменная как объект открытого файла
>>> len(db)
3

>>> list(db.keys())		# список ключей Объекта
['Tom jones', 'Sue Jones', 'Bob Smith']

>>> bob=db['Bob Smith']		# переменная как объект из переменной базы данных
>>> bob				# путь наследования объекта
<person.Person object at 0x7f94ba105ed0>
>>> print bob			# данные объекта из переменной
[Person: Bob Smith, 0]

>>> for item in db: print(item, '==>', db[item])
... 
('Tom jones', '==>', <person.Manager object at 0x7f94ba3753d0>)
('Sue Jones', '==>', <person.Person object at 0x7f94ba3753d0>)
('Bob Smith', '==>', <person.Person object at 0x7f94ba3753d0>)

>>> for item in sorted(db): print(item, '==>', db[item])
... 
('Bob Smith', '==>', <person.Person object at 0x7f94ba105e90>)
('Sue Jones', '==>', <person.Person object at 0x7f94ba105e90>)
('Tom jones', '==>', <person.Manager object at 0x7f94ba105e90>)


# файл updatedb.py - Файл логики обновсления базы данным без прямого импорта Классов. поскольку в самих экземплярах базыданных сохранены атрибуты Классов и пространство имен

import shelve  			# импорт модуля работы с БД 
db = shelve.open(‘persondb’)	# переменная в виде экземпляра открытого файла

for key in sorted(db):		# логика вызова элкментов БД по ключам
	print(key, ‘\t=>’, db[key])
sue = db[‘Sue Jones’]		# выбор элемента из БД в переменную
sue.giveRaise(.10)		# применение метода Класса к переменной (добавить премию)
db[‘Sue Jones’] = sue		# передача значения в элемент БД
db.close()			# Сохранение БД


""" Графический интерфейс пользователя - module  tkinter """

""" веб-сайты   Django   TurboGears   Pylons   web2Py   Zope    Google Upp Engine  """

""" 
Веб-Сайт может быть локальным, и это просто программа. в нем Просто есть перимущества: Работа через ВебБраузер, дает удобную разметку HTML, оформление строк CSS  Bootstrup, использование других языков и технологий JavaScript AJAX  и прочее.
"""

""" Веб Службы. Позволяют анализ информации в ответах от веб-сайта. SOAP   XML-RPC  и др. в основном это сторонние устанавливаемые пакеты """


""" Базы Данных (вместо shelve) - реляционные Базы Данных:  SQLite   MySQL  PostgreSQL  Oracle  """


""" 
Механизмы Объектно-Реляционных Отображений (ORM)  - (object-relational mapping, ORM)  - SQLObject и SQLAlchemy  
"""



""" Еще об Инструкции  class  """
Атрибут == Переменная (атрибут класса, атрибут инстанса), self - это всегда атрибут Инстанса

# instance.method(args...) == class.method(instance, args...) - методы внутри def - как функции
# Методы могут вызываться любым из двух способов – через экземпляр или через сам класс. Например, метод printer может быть вызван с использованием имени класса, при этом ему явно требуется передать экземпляр в аргументе self:
>>> NextClass.printer(x, ‘class call’) 		# Прямой вызов метода класса
class call

>>> x.message
‘class call’
# Вызов метода, который производится через экземпляр и через имя класса, оказывает одинаковое воздействие при условии, что при вызове через имя класса передается тот же самый экземпляр. По умолчанию, если попытаться вызвать метод без указания экземпляра, будет выведено сообщение об ошибке


# Если в конструкторе подкласса необходимо гарантировать выполнение действий, предусматриваемых конструктором суперкласса, необходимо явно вызвать метод __init__ через имя класса:
class Super:
	def __init__(self, x):
...программный код по умолчанию...

class Sub(Super):
	def __init__(self, x, y):
		Super.__init__(self, x)		# Основа для расширения методов ПодКлассов 
...адаптированный код...

I = Sub(1, 2)


""" Специализация наследование Классов """

# файл myfile
class Super:
	def method(self):		# определили логику метода Класса
		print(‘in Super.method’)

class Sub(Super):
	def method(self):		# Переопределили логику метода(этого же) в ПодКлассе
		print(‘starting Sub.method’)		# вывод1
		Super.method(self)	# Добавили логику метода в СуперКлассе (тоже)  # вывод2
		print(‘ending Sub.method’)		# вывод3


>>> import myfile		# операции в Консоли
>>> dir(myfile)
['Sub', 'Super', '__builtins__', '__doc__', '__file__', '__name__', '__package__']

>>> x=myfile.Super()			# Создали Инстанс СуперКласса
>>> x
<myfile.Super object at 0x7f94ba105f50>

>>> y=myfile.Sub()			# Создали Инстанс ПодКласса
>>> y
<myfile.Sub object at 0x7f94ba115450>

>>> x.method()				# Вызвали метод СуперКласса
in Super.method

>>> y.method()				# Вызвали метод ПодКласса
starting Sub.method
in Super.method
end Sub.method 



""" Взаимодействие Классов  """

# файл myfile.py
class Super(object):			# Создан СуперКласс
	def method(self):		# Метод СуперКласса (все в self для Инстансев)
		print('in Super.method')
	def deligate(self):		# Метод СуперКласса с выемкой метода из ПодКласса через self
		self.action()

class Inheritor(Super):			# ПодКласс - логика пустая
	pass

class Replacer(Super):			# ПодКласс - модернизирует метод под себя
	def method(self):
		print('in Replacer.method')

class Extender(Super):			# ПодКласс - модернизация метода под себя
	def method(self):
		print('starting Extender.method')
		Super.method(self)	# Коприрование метода из СуперКласса (вложение в метод)
		print('ending Extender.method')

class Provider(Super):		# ПодКласс - новый метод (через self примен в логике СуперКласса)
	def action(self):
		print('in Provider.action')

if __name__ == '__main__':
	for klass in (Inheritor, Replacer, Extender):	# Итерация по Классам
		print('-'*10)
		print('\n' + klass.__name__ + '...')
		klass().method()			# вызов "Класс+method" (значения по умолчанию)
	print('-'*10)
	print('Provider ...')
	x=Provider()			# Создание Инстанса ПодКласса
	x.deligate()			# Для Инстанса вызов метода из СуперКласса !! (наследование - поиск имени метода дал резульат в СуперКлассе)




""" Абстрактные Класса - введение коротко"""
# ABCMeta,   @abstractmethod  -  импорт из  abc

>>> import abc		# Отсюда МетаКласс и АбстрактМетод
>>> dir(abc)
['ABCMeta', 'WeakSet', '_C', '_InstanceType', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'abstractmethod', 'abstractproperty', 'types']

# файл meta_abstract.py
# -*- coding: utf-8 -*-

from abc import ABCMeta, abstractmethod		# импорт Метакласа и метода АбстактМетод (декоратор)

class Super(object):
	__metaclass__=ABCMeta		# Создание СуперКласса с переназначением МетаКласса
	def delegate(self):		# логика метода класса
		self.action()		# Вложена второй метод Класса (к исполнению)

	@abstractmethod
	def action(self):		# Логика второго метода класса (обернут в АбстрактМетод - Метод обязателен к переопределению в Подклассе, иначе весь СуперКласс работать не будет) - такая Заглушка
		pass

class Sub(Super):			# метод с оберткой АбстрактМетод переопределен в ПодКлассе
	def action(self):
		print 'spam'


>>> import meta_abstract
>>> from meta_abstract import *
>>> dir(meta_abstract)
['ABCMeta', 'Sub', 'Super', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'abstractmethod']		# Видны МетаКласс, СуперКласс, ПодКласс и обертка АбстрактМетод

>>> x=meta_abstract.Super()		# При создании Инстанса от Суперкласса - не работает - заглушен
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class Super with abstract methods action

>>> x=meta_abstract.Sub()		# Создание Инстанса от ПодКласса - методы в СуперКлассе разблокированы
>>> x
<meta_abstract.Sub object at 0x7f94ba115890>

>>> x.delegate()			# Вызов метода СуперКласса через Инстанс - работает !!
spam



""" «Дзен» пространств имен в Python """

# файл  myfile.py -- все понятно о пространствах имен 
X=11				# глобальная переменная модуля (myfile.X)

def foo():
	print X			# доступ к Глобальной переменной модуля через Ф-цию

def goo():
	X=22			# Локальная переменная внутри Ф-ции в Модуле ()
	print X

class C():
	X=33			# атрибут Класса (C.X)
	def moo(self):
		X=44		# Локальная переменная в Методе Класса
		self.X=55	# атрибут Экземпляра (instance.X)


if __name__ == '__main__':
	print ('-'*10)
	print X			# Локальная переменная модуля
	foo()			# переменная функции foo - ссылка на глобальную модуля
	goo()			# Переменная функции goo - локальная внутри функции
	print X			# не меняется - глобальная переменная модуля
	print ('-'*10)

	obj=C()			# создаем Экземпляр
	print obj		# Печать Инстанса как Метод Класса
	print ('-'*10)

	obj.moo()		# через инстанс вызвать атрибут Класса
	print obj.moo		# Печать атрибута Класса через Инстанс
	print C.X		# Печать локальной переменной Класса
	print ('-'*10)

	print C.moo.X		# Вызов напрямую локальной переменной метода Класса - не сработает
	print goo.X		# Вызов напрямую локальной переменной функции - не сработает
	print ('-'*10)

""" Локальные переменные функций не существуют без явного вызова и выполнения самих функций """

# Результат при Выполнении:
>>> exec(open('myfile.py').read())
----------
11				# Локальная переменная модуля
11				# переменная функции foo - ссылка на глобальную модуля
22				# Переменная функции goo - локальная внутри функции
11				# не меняется - глобальная переменная модуля
----------
<__main__.C instance at 0x7f95b998f7e8>		# Печать Инстанса как Метод Класса
----------
<bound method C.moo of <__main__.C instance at 0x7f95b998f7e8>> # Печать атрибута Класса через Инстанс
33
----------
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 36, in <module>
AttributeError: 'function' object has no attribute 'X'



""" строка документирования __doc__ """

# файл myfile.py
# -*- coding: utf-8 -*-

""" I am: myfile.__doc__"""

def foo(args):
	""" I am myfile.foo.__doc__"""
	pass

class Spam:
	""" I am Spam.__doc__ or myfile.Spam.__doc__"""
	def method(self, arg):
		"""I am Spam.method.__doc__ or self.method.__doc__"""
		pass

# Выполнение:
>>> reload(myfile)
<module 'myfile' from 'myfile.py'>
>>> dir(myfile)
['Extender', 'Inheritor', 'Provider', 'Replacer', 'Spam', 'Super', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'foo']

>>> myfile.__doc__			# Четыре вывода Строк документирования
' I am: myfile.__doc__'

>>> myfile.foo.__doc__
' I am myfile.foo.__doc__'

>>> myfile.Spam.__doc__
' I am Spam.__doc__ or myfile.Spam.__doc__'

>>> myfile.Spam.method.__doc__
'I am Spam.method.__doc__ or self.method.__doc__'



""" Перегрузка Оператора __getitem___ (перевод: получить элемент)""" + срезы

>>> class Indexer():
...     def __getitem__(self, index):
...         return index**2
... 
>>> X=Indexer()
>>> X[2]		# Срабатывает Встроенный метод X.__getitem__(i) 
4
>>> dir(Indexer)
['__doc__', '__getitem__', '__module__']


>>> for i in range(5): print X[i], 	# Вызывает __getitem__(X, i) в каждой итерации
... 
0 1 4 9 16


>>> class Indexer():		# Создали Класс с логикой получения Элемента по индексу
...     def __getitem__(self, index):
...         print ('getitem: ', index)
...         return self.data[index]
...     data=[2,3,4,5,6,7]
... 
>>> X=Indexer()			# Создали Инстанс Класса


>>> X[1]			# Просто получили Элемент из списка по индексу
('getitem: ', 1)
3

>>> X[1:]
('getitem: ', slice(1, 9223372036854775807, None))	# Пролучили срез (используется инструкция slice)
[3, 4, 5, 6, 7]

>>> X[1:2]
('getitem: ', slice(1, 2, None))		# Вызов среза задейтсвует инструкцию slice
[3]
>>> X[:-1]

>>> X[::2]
('getitem: ', slice(None, None, 2))
[2, 4, 6]


""" Перегрузка Оператора __setitem___ (перевод: утсановить элемент)""" + срезы
def __setitem__(self, index, value): 	# Реализует присваивание
... 					# по индексу или по срезу
	self.data[index] = value	# Приcваивание по индексу или по срезу


""" Перегрузка Оператора __iter___  + ___next__"""

""" Интерпретатор Python будет вызывать метод __next__ объекта итератора для получения элементов до
тех пор, пока не будет возбуждено исключение StopIteration. Если метод __iter__ отсутствует, интерпретатор переходит на использование схемы с применением метода __getitem__ и начинает извлекать элементы по индексам, пока не будет возбуждено исключение IndexError. """


# Напомним себе Итерацию через генератор Списка с применением логики Функции
>>> def squares(start, stop):
...     for i in range(start, stop+1):
...         yield i**2
... 

>>> [i for i in squares(2,22)]		# Синтаксис Генерации списка через итерацию и yield
[4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484]


# Еще лучше через Генератор Выражения - там и глогика задается и Диапозон
>>> [item**2 for item in range(2,22)]
[4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441]


""" итерации в итерациях """
>>> item=[1,2,3,4]
>>> for x in item:
...     for y in item:
...         print x*y,
... 
1 2 3 4 2 4 6 8 3 6 9 12 4 8 12 16


>>> S='asdfghj'
>>> for item in S[::2]:		# ограничиваем область итерации Срезом (каждый 2й элемент)
...     for item2 in S[::2]:
...         print item+item2,
... 
aa ad ag aj da dd dg dj ga gd gg gj ja jd jg jj		# только для  a d g j



""" Проверка на вхождение  __contains__   __iter__   __getitem__  """
# нихера не понял


""" __getattr__    """
# Проверяет наличие ссылки на Имя атрибута интерактивно не присваивая значения переменным и инстансам

# файл myfile.py
class Empty(object):
	
	def __getattr__(self, attrname):	# Принимает значение от Инстанса и проверяет наличи 							# Имени атрибута
		if attrname == 'age':
			return 50
		else:
			raise AttributeError, attrname 

# выполнение:
>>> dir(myfile)
['Empty', 'Iters', 'Squares', '__builtins__', '__doc__', '__file__', '__name__', '__package__']

>>> X=myfile.Empty()			# Создание Инстанса

>>> X.name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "myfile.py", line 9, in __getattr__
    raise AttributeError, attrname
AttributeError: name			# Не такого имени атрибута в Инстансе - выдает ошибку

>>> X.age	
50					# Есть такое имя в Инстансе = выдает Ретурн логики



"""   __setattr__  """
# При меняет логику к задаваемым атрубутам Инстанса

# файл myfile.py
class AttrControl(object):
	
	def __setattr__(self, attr, value):
		if attr == 'age':
			self.__dict__[attr] = value	# Только так надо наполнять Атрибуты Селфа- 
							# Через словарь "имя : значение"
		else:
			raise AttributeError, attr + 'not allowed'

# Выполнение:
>>> dir(myfile)
['AttrControl', 'Empty', 'Iters', 'Squares', '__builtins__', '__doc__', '__file__', '__name__', '__package__']
>>> X=myfile.AttrControl()		# Создали Инстанс Класса
>>> X.age=40				# задали Атрибут имя//значение
>>> X.age
40					# получили значение существующего Атрибута

>>> X.ages				# Запросили несуществующий атрибут - ошибка 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'AttrControl' object has no attribute 'ages' 



"""  __repr__ и __str__  Строковое представление объектов  """

# файл myfile.py
class Adder(object):
	def __init__(self, value=0):		# Логика для создания Инстатнса
		self.data = value
	def __add__ (self, other):		# Логика для добавления к Инстансу
		self.data += other

class AdderRepr(Adder):
	def __repr__(self):
		return 'AdderRepr(%s)' % (self.data)	# В наследованном классе - логики вывода 								# строки при запросе Инстанса

# Выполнение:
>>> dir(myfile)
['Adder', 'AdderRepr', .... , '__builtins__', '__doc__', '__file__', '__name__', '__package__']

>>> X=myfile.Adder()
>>> X
<myfile.Adder object at 0x7f4b9b6ada10>		# Строка презентации Инстанса

>>> X+2						# срабатывает метод __add__
>>> X
<myfile.Adder object at 0x7f4b9b6ada10>

>>> X=myfile.AdderRepr(2)			# Создается Инстанс ПодКласса (все наследует)
>>> X
AdderRepr(2)					# Строка презентации Инстанса (через __repr__)

>>> X+1						# Срабатывает __add__ в ПодКлассе
>>> X
AdderRepr(3)

>>> print X
AdderRepr(3)

>>> str(X), repr(X)				# Аналогичные встроеные методы
('AdderRepr(3)', 'AdderRepr(3)')


""" 
Встроенные функции print и str (а также ее внутренний эквивалент, который используется функцией print) сначала пытаются использовать метод __str__. Вообще этот метод должен возвращать строковое представление объекта в удобном для пользователя виде.
этот метод __repr__ должен возвращать строку, которая могла бы использоваться как программный код для воссоздания объекта или содержать информацию, полезную для разработчиков. Проще говоря, метод __repr__ используется везде, за исключением функций print и str, если определен метод __str__. Однако, если метод __str__ отсутствует, операции вывода будут использовать метод __repr__, но не наоборот – в остальных случаях, например, функцией автоматического вывода в интерактивной оболочке всегда используется только метод __repr__; попытка использовать метод __str__ даже не предпринимается 
Метод __str__ только для объектов верхнего уровня – вложенные объекты по-прежнему могут выводиться с  применением их методов __repr__ или метода по умолчанию
"""


""" __add__  __radd__  """

# файл myfile.py
class Commuter():

	def __init__(self, value):
		self.value=value
	
	def __add__(self, other):
		print ('add', self.value, other)
		return self.value+other
	
	def __radd__(self, other):
		print ('radd', self.value, other)
		return other + self.value

# выполнение:
>>> reload(myfile)
<module 'myfile' from 'myfile.py'>

>>> x=myfile.Commuter(88)		# создание Инстансов из СуперКласса
>>> y=myfile.Commuter(99)

>>> x+1					# вызов метода __add__ // экземпляр + неэкземпляр
('add', 88, 1)
89

>>> 1+y			# вызов метода __radd__ - // неэкземпляр + экземпляр
('radd', 99, 1)
100

>>> x+y			# экземпляр + экземпляр
('add', 88, <myfile.Commuter instance at 0x7f4b9b6b4fc8>)
('radd', 99, 88)
187



""" метод   __iadd__ """ (инстанс едд)
# резульат метода дает не просто выход а модификацию самого значения Экземпляра !

>>> class Number():
...     def __init__(self, val):	# Логика создания Инстанса (1 внешее значение)
...         self.val=val
...     def __iadd__(self, other):	# Логика модификации Инстанса (за счет внешн значения)
...         self.val+=other		# прирощение
...         return self			# вывод Инстанса
... 
>>> x=Number(11)		# Создание Инстанса

>>> x+=2 			# Прирощение Инстанса
>>> x
<__main__.Number instance at 0x7f4b9b6b4ef0>
>>> x.val			# Значение Атрибута Инстанса
13
>>> x+=3			# Опять Прирощение
>>> x.val			# Опять значение Атрибута
16



""" Метод  __call__  """
# метод вызывается при обращении к Инстансу как к Функции. т.е. принимает параметры как Функция 
# *args,  **kwargs,  значения по умолчанию, именованные значения,  a=None  и прочее

>>> class Callee(object):
...     def __call__(self, *args, **kwargs):
...         print ('Called: ', args, kwargs)
... 
>>> C=Callee()					# Создан Инстанс класса - принял логику Функции

>>> C(1,2,3,'spam', 'ham', name='Yurii', age=40)	# Реализация логики Функции в Инстансе
('Called: ', (1, 2, 3, 'spam', 'ham'), {'age': 40, 'name': 'Yurii'})


# Имитация поведения Функции
>>> class Prod():
...     def __init__(self, value):		# Логика Инстанса - принимакет 1 аргумент
...         self.value=value
...     def __call__(self, other):		# Логика Инстанса как Функции - принимает 1 аргумент
...         return self.value*other		# вывод рузкльтата как функции
... 

>>> C=Prod('spam')			# Создание Инстанса + 1 аргумент
>>> C(3)				# передача Инстансу как Функции 1 аргумент
'spamspamspam'


# Рейтинг Популярности Методов
1) __init__
2) __str__   __repr__
3) __call__


"""
Магические методы сравнения

В Питоне уйма магических методов, созданных для определения интуитивного сравнения между объектами используя операторы, а не неуклюжие методы. Кроме того, они предоставляют способ переопределить поведение Питона по-умолчанию для сравнения объектов (по ссылке). Вот список этих методов и что они делают:

    __cmp__(self, other) - метод "сравнение в принципе" выдает False//True (устарел, в Питон3 - нет)
    Самый базовый из методов сравнения. 
Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). 
__cmp__ должен вернуть отрицательное число, если self < other, ноль, если self == other, и положительное число в случае self > other.
 
Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в __cmp__. 
Но __cmp__ может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперерируют одним критерием.

    __eq__(self, other)
    Определяет поведение оператора равенства, ==.

    __ne__(self, other)
    Определяет поведение оператора неравенства, !=.

    __lt__(self, other)
    Определяет поведение оператора меньше, <.

    __gt__(self, other)
    Определяет поведение оператора больше, >.

    __le__(self, other)
    Определяет поведение оператора меньше или равно, <=.

    __ge__(self, other)
    Определяет поведение оператора больше или равно, >=.
"""


# Пример: Логика Сравнения больше/меньше
>>> class C:
...     data='spam'
...     def __gt__(self, other):	# Если аргумент Инстанс больше чем Неинстанс
...         return self.data>other	
...     def __lt__(self, other):	# Если аргумент Инстанс меньше чем Неинстанс
...         return self.data<other
... 
>>> X=C()		# создание Инстанса
>>> print(X>'ham')	# Логика Инстанс>НеИнстанса, запускает сравнение где результат True
True
>>> print(X<'ham')	# Логика Инстанс<НеИнстанса, запускает сравнение где результат False
False


# Пример: универсальный метод сравнения __cmp__ + метод cmp()
>>> class CMP():
...     data='spam'
...     def __cmp__(self, other):	# Универсальный метод сравнения
...         return cmp(self.data, other)
... 
>>> X=CMP()		# Создание Инстанса

>>> X>'ham'		# Результаты
True
>>> X<'ham'
False
>>> X==23
False
>>> X=='spam'
True
>>> X!=23
True



""" встоенные методы __bool__(Питон3)  __nonzero__(Питон2)   __len__ """
# Оба метода вызыватся первыми при запросе объекта, то есть стравнивают сначала есть ли в объекте булевая логики или она может быть переопределена с помощью __bool__, если булевой логики нет то выявляется есть ли в объекте длинна методом __len__

# В Питоне2   __nonzero__  вместо  __bool__   !!

>>> class Truth:
...     def __bool__(self): return 0
...     def __len__(self): return 0
... 
>>> X=Truth()

>>> X.__bool__
<bound method Truth.__bool__ of <__main__.Truth instance at 0x7f50ef437170>>
>>> X.__len__
<bound method Truth.__len__ of <__main__.Truth instance at 0x7f50ef437170>>
>>> if X: print 'xxx'
... 
>>> if not X: print 'xxx'
... 
xxx

# запоминаем что пустой объект тоже является Тру по умолчанию

# метод __bool__ только для Питона3
>>> class C(object):
...     def __bool__(self):
...         print 'in bool'
...         return False
... 
>>> X=C()
>>> bool(X)
True
>>> if X: print 99
... 
99		# в Питоне2 метод __bool__ игнорируется, Объект как Правда по умолчанию


# метод __nonzero__  страбатывает в Питоне2
>>> class C(object):
...     def __nonzero__(self):
...         print 'in bool'
...         return False
... 
>>> X=C()
>>> bool(X)
in bool
False
>>> if X: print 99
... 
in bool		# срабатывает __nonzero__ - объект Не есть Правда



""" метод __del__ """
# В противоположность методу __init__ вызывается атоматически когда происходит сборщик мусора в отнощшении объекта, то есть когда объект теряет последнюю ссылку на него. При этом методом _del__ можно изменить логику действия при сборке мусора по объекту

>>> class Persona:
...     def __init__(self, name='unknown'):		# Логика создания Инстанса
...         print 'Hallo', name
...         self.name=name
...     def __del__(self):				# Логика действий при Удалении Инстанса
...         print 'Goodbye', self.name
... 
>>> yurii=Persona('Yurii')		# Создан Инстанс     (__init__)
Hallo Yurii

>>> lena=Persona('Lena')		# Создан еще Инстанс отдельный (__init__)
Hallo Lena

>>> yurii=Persona('Lena')	# Переобпределен Объект (потеряна старая ссылка) __init__+__del__
Hallo Lena
Goodbye Yurii
# Этот метод __del__ удобно использовать для реализации некоторых заключительных действий (таких как завершение соединения с сервером).




""" Шаблоны Проектирования в ООП  на Python """

# Наследование   Композиция   Делегирование   Фабрики
# Объектная модель в языке Pythonдостаточно проста, поэтому основное мастерство владения ООП заключается в умении комбинировать классы в программе для достижения поставленных целей.

# файл myfile.py
# -*- coding: utf-8 -*-

class Employee(object):
	def __init__(self, name, salary=0):
		self.name=name
		self.salary=salary

	def giveRaise(self, percent):
		self.salary=self.salary+(self.salary*percent)

	def work(self):
		print self.name, "does stuff"

	def __repr__(self):
		return "< Employee:  name=%s, salary=%s >" % (self.name, self.salary)


class Chef(Employee):
	def __init__(self, name):
		Employee.__init__(self, name, 50000)
	
	def work(self):
		print self.name, "makes food"


class Server(Employee):
	def __init__(self, name):
		Employee.__init__(self, name, 40000)	

	def work(self):
		print self.name, "interfaces with customer"	
			

class PizzaRobot(Chef):
	def __init__(self, name):
		Chef.__init__(self, name)	

	def work(self):
		print self.name, "makes Pizza"


if __name__ == '__main__':
		print('-'*10)
		bob=PizzaRobot('bob')  # создаеми Инстанс с присвоение значения Параметра
		print(bob)
		bob.work()		# Для Инстанса вызываем свой метод 
		bob.giveRaise(0.20)	# Для Инстанса вызываем метод СуперКласса (вверх по ветке)
		print bob 
		print('-'*10)

		for klass in Employee, Chef, Server, PizzaRobot:  # запускаем Итерацию набора Логики для Интсанса от всех Классов
			obj=klass(klass.__name__)
			obj.work()		# 2 метода есть у всех

		print('-'*10)
	

# выполнение:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
----------
< Employee:  name=bob, salary=50000 >
bob makes Pizza
< Employee:  name=bob, salary=60000.0 >
----------
Employee does stuff
Chef makes food
Server interfaces with customer
PizzaRobot makes Pizza
----------
# Когда выполняется программный код самопроверки, включенный в состав модуля, создается робот по приготовлению пиццы с именем bob, который наследует атрибуты трех классов: PizzaRobot, Chef и Employee. Например, при попытке вывести экземпляр bob вызывается метод Employee.__repr__, а прибавка зарплаты производится методом Employee.giveRaise, потому что этот метод обнаруживается в процессе поиска в дереве наследования именно в этом классе

# Классы могут представлять практически любые объекты и  взаимоотношения между ними, которые можно выразить словами; для этого просто замените имена существительные классами, глаголы  – методами, и  вы получите первый черновой набросок проекта.

# Связка двух файлов, пример:

# файл№1 myfile.py
# -*- coding: utf-8 -*-

class Employee(object):
	def __init__(self, name, salary=0):
		self.name=name
		self.salary=salary

	def giveRaise(self, percent):
		self.salary=self.salary+(self.salary*percent)

	def work(self):
		print (self.name, "does stuff")

	def __repr__(self):
		return "< Employee:  name=%s, salary=%s >" % (self.name, self.salary)


class Chef(Employee):
	def __init__(self, name):
		Employee.__init__(self, name, 50000)
	
	def work(self):
		print (self.name, "makes food")


class Server(Employee):
	def __init__(self, name):
		Employee.__init__(self, name, 40000)	

	def work(self):
		print (self.name + " interfaces with customer")	
			

class PizzaRobot(Chef):
	def __init__(self, name):
		Chef.__init__(self, name)	

	def work(self):
		print (self.name, "makes Pizza")

# файл№2 pizzashop.py
# -*- coding: utf-8 -*-

from myfile import PizzaRobot, Server

class Customer():
	def __init__(self, name):
		self.name = name

	def order(self, server):
		print self.name, "order from ", server

	def pay(self, server):
		print self.name, "pays for item to ", server


class Owen():
	def bake(self):
		print ("oven bakes")


class PizzaShop():
	def __init__(self):
		self.server = Server("Pat")
		self.chef = PizzaRobot("bob")
		self.owen = Owen()

	def order(self, name):
		customer = Customer(name)
		customer.order(self.server)
		self.chef.work()
		self.owen.bake()
		customer.pay(self.server)


if __name__ == '__main__':
	print ('-'*15)
	scene = PizzaShop()
	scene.order('Homer')
	print ('-'*15)
	scene.order('Shaggy')
	print ('-'*15)


# Выполнение:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python pizzashop.py
---------------
Homer  ordef from  < Employee:  name=Pat, salary=40000 >
('bob', 'makes Pizza')
oven bakes
Homer  pays for item to  < Employee:  name=Pat, salary=40000 >
---------------
Shaggy  ordef from  < Employee:  name=Pat, salary=40000 >
('bob', 'makes Pizza')
oven bakes
Shaggy  pays for item to  < Employee:  name=Pat, salary=40000 >
---------------

# class PizzaShop() - это конструктор, он включает в себя 2 других класса которые импортируются из другого класса, и 2 класса которые созданы в данном файле - путем создания в объекте переменных. При этом доступны все методы по ветке классов и значенния переменных из Селфа.



""" Объекты-Обертки """

>>> class Wrapper:				# Класс-Обертка
...     def __init__(self, obj):		# Создавая Инстанс принимает внешний атрибут	
...         self.wrapped=obj
...     def __getattr__(self, attrname):	# При создании Инстанса активирует метод вызова 							имени Атрибута из Инстанса
...         print 'Trace: ', attrname
...         return getattr(self.wrapped, attrname)	# метод получения Имени Атрубута из Объекта
... 
>>> x=Wrapper([1,2,3,4])	# Создавая Инстанс принимает объект
>>> x.append(5)			# Инстанс принимает Атрибут со значеним и автоматически инициируется (__getattr__) метод вызова имени Атрибута
Trace:  append			# вывод принта
 


""" Искажение имен в класса """

# класс С атрибут __item  ==>  _C__item  - уникальное искаженное имя - псевдо/частные атрибуты

# class.method.self.__X ==> _class__X

class C1:
	def meth1(self): self.__X = 88
	def meth2(self): print(self.__X) # Теперь X - мой атрибут
					# Превратится в _C1__X		-- уникальное имя
class C2:
	def metha(self): self.__X = 99
	def methb(self): print(self.__X) # И мой тоже
					# Превратится в _C2__X		-- уникальное имя
class C3 (C1, C2): pass			# избегается конфликт имен при наследовании более 1 класса
					# чтобы имя Х не перекрывалось в одном Инстансе
I = C3() 				# В I два имени X (создание Инстанса - 2 имени атрибутов)
I.meth1(); I.metha()
print(I.__dict__)
I.meth2(); I.methb()

# выполнение:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
{'_C2__X': 99, '_C1__X': 88}
88
99

>>> import myfile
>>> dir(myfile)
['C1', 'C2', 'C3', '__builtins__', '__doc__', '__file__', '__name__', '__package__']


"""  Связанные / несвязанные методы Класса 
- об self как атрибуте Инстанса куда привязаны аргументы  """
# файл myfile.py
# -*- coding: utf-8 -*-

class Selfless(object):
	def __init__(self, data):		# self выступает как объект Инстанса, к нему липнет
		self.data = data

	def selfless(arg1, arg2):		# просто несвязанная функция внутри Класса
		return arg1 + arg2

	def normal(self, arg1, arg2):		# Связанная с Инстансем функция через self
		return self.data + arg1 + arg2

# выполнение:
>>> from myfile import Selfless		# Из модуля импортируем класс 

>>> X=Selfless(2)			# Создаем Инстанс класса - принимает один аргумент в self
>>> X
<myfile.Selfless object at 0x7f50ef42fb50>

>>> X.normal(3,4)		# У Инстанса вызываем свзязанную с self функцию - принимает 							два аргумента
9

>>> Selfless.normal(X,3,4)	# У Инстанса вызываем свзязанную с self функцию - принимает 							два аргумента + вручную указываем на Инстанс
9
>>> Selfless.selfless(3,4)	# В Питоне2 не сработает, в Питоне2 сработает как Несвязанная с Селфом Функция и выдаст 3+4 = 7

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unbound method selfless() must be called with Selfless instance as first argument (got int instance instead)	# В Питоне2 пишет ошибку как несвязанный метод - требует self первым

""" 
Благодаря этому изменению в версии 3.0 отпала необходимость использовать декоратор @staticmethod, описываемый в следующей главе, для оформления методов, которые не принимают аргумент self, вызываются только через имя класса и  никогда не вызываются относительно экземпляра,  – такие методы
действуют как обычные функции, не получая аргумент с экземпляром """

# Пример применения свзязанных(self) методов класса

# -*- coding: utf-8 -*-

class Numbers(object):
	def __init__(self, base):	# Инициирующий метод с входным одним параметром
		self.base = base

	def double(self):		# Связанный метод (из self) с логикой над self
		return self.base * 2

	def triple(self):
		return self.base * 3

x=Numbers(2)			# Создание Инстанса с входным параметрм (для импорта)
y=Numbers(4)
z=Numbers(6)

if __name__ == '__main__':
	x=Numbers(2)			# Создание Инстанса с входным параметрм (для __main__)
	y=Numbers(4)
	z=Numbers(6)

	act=[x.double, y.double, y.triple, z.double]

	for item in act:		# Обычный генератор списка
		print item()


# выполнение:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
4
8
12
12

>>> from myfile import Numbers
>>> dir(myfile)
['C1', 'C2', 'C3', 'Numbers', 'Selfless', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'x', 'y', 'z']

>>> bound=myfile.x.double		# Создание Инстанса как модуль+Инстанс Класса+метод
>>> bound.__self__			# self инстанса впринципе есть
<myfile.Numbers object at 0x7f50ef42fed0>
>>> bound.__func__
<function double at 0x7f50ef4309b0>
>>> bound.__self__.base			# один Параметр Селфа Инстанса
2
>>> bound()				# Выполнение всей логики Инстанса (return self.base * 2)
4


""" Способы Вызова Методов Объектов """

def square(arg):
	return arg ** 2 		# 1) Вызов Простой функции (def или lambda) - по имени

class Sum:
	def __init__(self, val): 	# 1) При создании Инстанса требует Аргумент1 
		self.val = val
	def __call__(self, arg):	# 2) при Вызове инстанса требует Аргумент2	
		return self.val + arg

class Product:
	def __init__(self, val): 	# 1) При создании Инстанса требует Аргумент1
		self.val = val
	def method(self, arg):		# 2) В Инстансе можно вызвать Метод по имени
		return self.val * arg

sobject = Sum(2)			# Инстанс
pobject = Product(3)			# Инстанс

actions = [square, sobject, pobject.method]	# Вызов Функции // Вызов Инстанса // Вызов Метода Инс

>>> for act in actions:			# Передача Аргумента объекту всех трех видов 
	print(act(5))




""" Универсальный Примесный Класс (Как второй Суперкласс для ПодКласса)"""

# Как пример для вывода расширенной информации об Интстансе и его методах при Принте или str() 
# Файл listinstance.py
class ListInstance(object):

	"""
	Использует функцию dir() для получения списка атрибутов самого экземпляра
	и атрибутов, унаследованных экземпляром от его классов; в Python 3.0
	выводится больше имен атрибутов, чем в 2.6, потому что классы нового стиля
	в конечном итоге наследуют суперкласс object; метод getattr() позволяет
	получить значения унаследованных атрибутов, отсутствующих в self.__dict__;
	реализует метод __str__, а не __repr__, потому что в противном случае
	данная реализация может попасть в бесконечный цикл при выводе связанных
	методов!
	"""	

	def __str__(self):
		return '<Instance of %s , address %s :\n %s>' % (
			self.__class__.__name__,  # Имя класса экземпляра
			id(self), 		# Адрес экземпляра
			self.__attrnames()) 	# Список пар name=value

	def __attrnames(self):
		result = ''
		for attr in dir(self):			# Передать экземпляр функции dir()
			if attr[:2] == '__' and attr[-2:] == '__': 	# Пропустить
				result += '\tname %s=<>\n' % attr 	# внутренние имена
			else:
				result += '\tname %s=%s\n' % (attr, getattr(self, attr))
		return result


# Выполнение:
>>> from myfile import Numbers		# Импортируем другой СуперКласс из Другого Модуля
>>> class Klass(Numbers, ListInstance): pass	# Создаем ПодКласс из Двух СуперКлассов
... 
>>> X=Klass(10)				# Создам Инстанс - требует аргумент по логике СуперКласса
>>> X
<__main__.Klass object at 0x7fccca9a1450>

>>> str(X)		# Вот Работает Метод чтения структуры Инстанса в виде строки - плохо читается
'<Instance of Klass , address 140517549151312 :\n \tname _ListInstance__attrnames=<bound method Klass.__attrnames of <__main__.Klass object at 0x7fccca9a1450>>\n\tname __class__=<>\n\tname __delattr__=<>\n\tname __dict__=<>\n\tname __doc__=<>\n\tname __format__=<>\n\tname __getattribute__=<>\n\tname __hash__=<>\n\tname __init__=<>\n\tname __module__=<>\n\tname __new__=<>\n\tname __reduce__=<>\n\tname __reduce_ex__=<>\n\tname __repr__=<>\n\tname __setattr__=<>\n\tname __sizeof__=<>\n\tname __str__=<>\n\tname __subclasshook__=<>\n\tname __weakref__=<>\n\tname base=10\n\tname double=<bound method Klass.double of <__main__.Klass object at 0x7fccca9a1450>>\n\tname triple=<bound method Klass.triple of <__main__.Klass object at 0x7fccca9a1450>>\n>'

>>> print X			# Вот хорошо работает метод чтения Структуры Инстанса
<Instance of Klass , address 140517549151312 :
 	name _ListInstance__attrnames=<bound method Klass.__attrnames of <__main__.Klass object at 0x7fccca9a1450>>
	name __delattr__=<>
	name __dict__=<>
	name __doc__=<>
	name __format__=<>
	name __getattribute__=<>
	name __hash__=<>
	name __init__=<>
	name __module__=<>
	name __new__=<>
	name __reduce__=<>
	name __reduce_ex__=<>
	name __repr__=<>
	name __setattr__=<>
	name __sizeof__=<>
	name __str__=<>
	name __subclasshook__=<>
	name __weakref__=<>
	name base=10
	name double=<bound method Klass.double of <__main__.Klass object at 0x7fccca9a1450>>
	name triple=<bound method Klass.triple of <__main__.Klass object at 0x7fccca9a1450>>


""" Функция Фабрика Классов"""

def factory(aClass, *args, **kwargs):		# Кортеж с переменным числом аргументов
	return aClass(*args, **kwargs)		# Вызов aClass (или apply, только в 2.6)

class Spam:
	def doit(self, message):
		print(message)

class Person:
	def __init__(self, name, job):
		self.name = name
		self.job = job

object1 = factory(Spam) 			# Создать объект Spam
object2 = factory(Person, “Guido”, “guru”) 	# Создать объект Person



""" Классы Нового Стиля """
# В Питоне3 есть отличия от Питона2

class(object)

# Питон3
>>> c = C()
>>> d = D()
>>> type(c) == type(d)
False						# 3.0: сравниваются классы экземпляров
>>> type(c), type(d)
(<class ‘__main__.C’>, <class ‘__main__.D’>)	# тип Инстанса - его Класс

>>> c.__class__, d.__class__
(<class ‘__main__.C’>, <class ‘__main__.D’>)	# вывод представления об Классе Инстанса

>>> c1, c2 = C(), C()
>>> type(c1) == type(c2)
True


# Питон2
>>> c = C()
>>> d = D()

>>> type(c) == type(d) 				# 2.6: все экземпляры имеют один и тот же тип
True
>>> c.__class__ == d.__class__ 			# Следует явно сравнивать классы
False

>>> type(c), type(d)
(<type ‘instance’>, <type ‘instance’>)		# Тип Инстанса - Интсанс

>>> c.__class__, d.__class__			# вывод представления об Классе Инстанса
(<class __main__.C at 0x024585A0>, <class __main__.D at 0x024588D0>)


# чаще используем метод isinstance(instance, class)


>>> type(type)
<class ‘type’>

>>> type(object)
<class ‘type’>
 				# Все классы – это типы, и наоборот
>>> isinstance(type, object)	# Чиклическая взаимосвязь - венец объектной модели
True
>>> isinstance(object, type)
True

>>> type is object
False


""" Слоты Инстансов  __slots__  """
# только имена, перечисленные в списке __slots__, смогут использоваться как атрибуты Инстанса.

>>> class Slots(object):		# Создан класс с логикой для Инстанса по атрибутам 
...     __slots__=['age', 'name', 'job']	# Только такие Атрубуты может принимать Инстанс
... 
>>> X=Slots()				# Создан Инстанс

>>> X.age=40				# Присвоен Атрибут и его значение Инстансу (есть в slots)
>>> X.age
40

>>> X.ape=1000				# Атрибут присове быть не может (имени нет в __slots__)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Slots' object has no attribute 'ape'

# встроенные функции getattr, setattr и dir, способные отыскивать атрибуты в обоих хранилищах, __dict__ и __slots__.


# Пример синтатксиса:
 
>>> class C(object):
...     __slots__=['a', 'b']		# задали класс со слотами (имена которые можно задавать)
... 
>>> X=C()				# создали Инстанс
>>> X.a=10				# Создали 2 атрибута - согласованно со слотами
>>> X.b=20

>>> X.c=30				# данный Атрибут Не принят так как нету в слотах
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'C' object has no attribute 'c'

>>> X.__dict__				# В классе где есть Слоты обычно Дикта нету
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'C' object has no attribute '__dict__'

>>> X.__slots__
['a', 'b']				# Имена атрибутов в Слоте в виде множества

>>> getattr(X, 'a')
10
>>> getattr(X, 'b')
20					# Получение Значения имени
	
>>> setattr(X, 'c', 30)			# Нельзя установить Атрибут, имени которого нету в Слоте
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'C' object has no attribute 'c'

>>> setattr(X, 'b', 30)			# Можно переопределить значение атрибута методом setattr()
>>> X.b
30

>>> dir(X)				# dir Инстанса в виде Множества
['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', 'a', 'b']
>>> 'a' in dir(X)			# Проверка имени Атрибута на вхождение в Множество
True

>>> '__class__' in dir(X)		# Проверка имени Встроенного Атрибут на вхождение в Множество
True


# Но вот Фокус для добавления __dict__  и новых атрубутов в __dict__
>>> class D:
... 	__slots__ = [‘a’, ‘b’, ‘__dict__’] 	# Добавить __dict__ в слоты
... 	c = 3 					# Атрибуты класса действуют как обычно
... 	def __init__(self): self.d = 4 		# Имя d будет добавлено в __dict__,
...						# а не в __slots__
>>> X = D()
>>>X.d
4
# Однако возможность добавлять новые атрибуты все-таки существует – для этого необходимо включить 
#имя __dict__ в список __slots__, разрешив тем самым создать словарь с пространством имен. В этом 
#случае действовать будут оба механизма хранения имен, однако обобщенные инструменты, такие как 
#getattr, будут воспринимать их, как единое множество атрибутов




""" Свойства Класса  property() """

# концепция - свойства присваимаются Именам Атрибутов Инстанса

# Старый стиль - задаем атрибут при генерации Инстанса
>>> class classic:
...     def __getattr__(self, name):
...         if name == 'age':
...             return 40
...         else: raise AttributeError
... 
>>> X=classic()
>>> X.age
40

# Новый стиль - 
>>> class ClassProp(object):
...     def getage(self):
...         return 40
...     age=property(getage, None, None, None)	# все методы для атрибута заданы в виде аргументов
						# функции property // свойтсва (атрибута)
						# методы по порядку (get,set,del,docs)
				# (откуда берется// куда передается // как удалятеся // доки)
... 
>>> X=ClassProp()
>>> X.age
40


# еще раз о Логике:
>>> class ClassProp(object):			# создаем Класс в новом стиле
...     def getatri(self):			# произвольная Функция получения значения Атрибута
...         return 40
...     def setatri(self, value):		# произвольная Функция присвоения значения Атрибута 
...         print('set age:  ', value)
...         self._age=value
...     age=property(getatri, setatri, None, None)	# Атрибут и его параметры как ссылки на 
							# Функции (то есть их логику)
... 
>>> X=ClassProp()			# создание Инстанса Класса
>>> X.age				# Вызов Аргумента Инстанса // внутри property
40

>>> X.age=42
('set age:  ', 42)			# перебитие значения Аргумента // внутри  property 
>>> X._age
42

>>> X.job='yurii'			# создание атрибута Инстанса // без  property
>>> X.job
'yurii'

>>> X
<__main__.ClassProp object at 0x7ff0ade27550>
>>> dir(X)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_age', 'age', 'getatri', 'job', 'setatri']


""" МетаКлассы это подклассы от type - но создают Классы """


"""  Статические Методы и их Альтернативы (различия в Питон2 и Питон3)"""
#  Пример:
class Spam(object):
	numInstance=0			# Счетает количество инитов Инстансев Класса
	def __init__(self):
		Spam.numInstance = Spam.numInstance + 1		# Вызов метода как КлассюМетод
	def printNumInstance():		# Раз функция в Классе то в Питоне2 привязана к Инстансу
		print ("Number of instance created:  ", Spam.numInstance)

# Метод Класс.Метод (без Селфа и селфа) в Питоне3 работат как вызов прямо из Класса - Статтический метод в обход Инстанса - то есть работает как простая функция. В Питоне2 - вообще не работает.


#  Альтернатива №1 - глобальная функция модуля вне Класса:
#  Файл myfile.py
class Spam(object):
	numInstance=0
	def __init__(self):
		Spam.numInstance = Spam.numInstance + 1

def printNumInstance():			# Глобальная функция обрабатывает переменную Класса
 	print ("Number of instance created:  ", Spam.numInstance)

#  Выполнение:
>>> reload(myfile)
<module 'myfile' from 'myfile.py'>

>>> myfile.Spam()
<myfile.Spam object at 0x7ff0ade27950
>
>>> myfile.printNumInstance()			# Прямой вызом метода пуьем Модуль.ГлобФункция
('Number of instance created:  ', 1)

>>> myfile.printNumInstance
<function printNumInstance at 0x7ff0ade28500>

# Но есть одна пробленма - Глобальные функции Класса не смогут быть адаптированы в ПодКлассач и не будут видны в СуперКлассе


# Альтернативный методы // метод Инстанса // Статический метод // Метод Класса
# файл myfile.py
class Metods(object):
	def insmet(self, x):		# Создаем произвольный метод для Инстанса
		print(self, x)

	def statmet(x):			# Создаем произвольный Стат метод // + staticmethod(statmet) 
		print x
		
	def classmet(cls, x):		# Создаем произвольный Метод класса // classmethod(classmet)
		print (cls, x)

	statmet = staticmethod(statmet)		# Методы переопределены прямо в классе на Статметод
	classmet = classmethod(classmet)	# ... на Метод Класса


# выполнение:
>>> reload(myfile)
<module 'myfile' from 'myfile.py'>

>>> dir(myfile)
['Metods', 'Spam', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'printNumInstance']


# Выполнение метода Инстанса
>>> obj=myfile.Metods()				# Создание Инстанса

>>> obj.insmet(3)				# Через Инстанс вызов метода Инстанса
(<myfile.Metods object at 0x7ff0ade27990>, 3)

>>> myfile.Metods.insmet(obj, 4)		# Вызов вручную метода Инстанса через класс с 
						# указанием на Инстанс как параметр
(<myfile.Metods object at 0x7ff0ade27990>, 4)


# Выполнение Статического (переназначенного ) метода - то есть привязан к объекту(Класс или Инстанс)
>>> myfile.Metods.statmet(5)			# Возможен вызов через имя Класса
5
>>> obj.statmet(6)				# Возможен вызов через Имя Инстанса
6



# Выполнение Метода класса
>>> myfile.Metods.classmet(7)		# При выполнение вызывается сам Класс
(<class 'myfile.Metods'>, 7)
>>> obj.classmet(10)
(<class 'myfile.Metods'>, 10)


""" Использование Статического Метода """
# Видит сквозь всю цепочку Класса и инстансев

# файл myfile
class Spam:
	numInstances = 0		 # Переменная Счетчика  
	def __init__(self):
		Spam.numInstances += 1   # Прирощение переменной Счетчика при создании Инстанса
	def printNumInstances():	 # Будущий стат метод принта Переменной Счетчика
		print(“Number of instances:”, Spam.numInstances)
	
	printNumInstances = staticmethod(printNumInstances)	# Создание Статист Метода

>>> a = myfile.Spam()
>>> b = myfile.Spam()
>>> c = myfile.Spam()		# Создание Инстансев // Счетчик считает(3)

>>> myfile.Spam.printNumInstances()	# вызов Статик метода через имя Класса 
Number of instances: 3
>>> a.printNumInstances()		# вызов Статик метода через имя Инстанса
Number of instances: 3

>>> dir(Spam)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'numInstances', 'printNumInstances']
>>> Spam.printNumInstances()
('Number of instaces:  ', 3)
>>> 
>>> 
>>> class Other(Spam): pass		# Создаем Класс-наследник от Спама(СуперКласс)
... 
>>> c=Other()
>>> dir(c)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'numInstances', 'printNumInstances']
>>> c.printNumInstances()
('Number of instaces:  ', 4)		# Cчетчик СупКласса все также Считает, то есть вызывется 
					# статик.Метод Суперкласса
>>> class Insh(Sub): pass		# Создаем Клас-Наследник от ПодКласса (Суб)
... 
>>> z=Insh()
>>> dir(z)
['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'numInstances', 'printNumInstances']
>>> z.printNumInstances()
Extra Shtuka ...
('Number of instaces:  ', 5)		# Cчетчик СупКласса все также Считает, то есть вызывется 
					# статик.Метод Суперкласса


""" Использование Метода Класса """

# Видит только в пределах ближайшего уровня ПодКласса(Класса)

class Spam():
	numInstance = 0				# В Классе создаем счетчик
	
	def __init__(self):
		Spam.numInstance += 1		# Счетчик считает Инстансы
	
	def printNumInstance(cls):		# задаем Метод класса
		print("Number of Instance: ", cls.numInstance, cls)

	printNumInstance = classmethod(printNumInstance)	# инициируем Метод Класса


class Sub(Spam):
	def printNumInstance(cls):		# В подКлассе переопределяем Метод подКласса
		print("Extra stuff ...", cls)
		Spam.printNumInstance()		# Явно вызывает метод Класса

	printNumInstance = classmethod(printNumInstance)	# инициируем метд подКласса


class Other(Spam): pass			# Создаем пустой подКласс - все от Класса

""" всякий раз, когда будет вызываться метод класса, интерпретатор будет переда-
вать ему самый близкий класс, даже для подклассов, не имеющих собственной
реализации метода класса """

if __name__ == '__main__':
	x,y = Sub(), Spam ()		# Создали 2 Инстанса - один от подКласса, другой от Класса

	print("--"*10)
	x.printNumInstance()		# вызвали метод через имя Инстанса ПодКласса

	print("--"*10)			
	Sub.printNumInstance()		# вызвали метод через имя ПодКласса (то же самое)

	print("--"*10)			
	y.printNumInstance()		# вызвали метод через имя Инстанса Класса
	
	print("--"*10)
	z=Other()			# Создали еще один Инстанс (ушло + в счетчик)
	z.printNumInstance()		# вызвали метод через имя Инстанса Класса
	print("--"*10)
	

# Выполнение:
>>> 
>>> 
>>> 
>>> exec(open("myfile.py").read())
--------------------
('Extra stuff ...', <class __main__.Sub at 0x7faf738cf390>)	# вызвали метод через имя Инстанса ПодКласса
('Number of Instance: ', 2, <class __main__.Spam at 0x7faf738cf1f0>)
--------------------
('Extra stuff ...', <class __main__.Sub at 0x7faf738cf390>)	# вызвали метод через имя ПодКласса (то же самое)	
('Number of Instance: ', 2, <class __main__.Spam at 0x7faf738cf1f0>)
--------------------
('Number of Instance: ', 2, <class __main__.Spam at 0x7faf738cf1f0>)	# вызвали метод через имя Инстанса Класса
--------------------
('Number of Instance: ', 3, <class __main__.Other at 0x7faf738cf3f8>)	# вызвали метод через имя Инстанса Класса
--------------------



"""  Декораторы """
""" Декораторы функций обеспечивают способ определения специальных режимов работы функций, обертывая их дополнительным слоем логики, реализованной в виде других функций """
# в принципе декораторы - это аналог статических методов относительно классов/функций

# Язык Python предоставляет несколько встроенных декораторов функций для выполнения таких действий, как создание статических методов, но программисты также имеют возможность создавать свои собственные декораторы

# пользовательские декораторы функций часто оформляются как классы, в которых сохраняется оригинальная функция наряду с другими данными, такими как информация о состоянии.

# появилось похожее расширение, доступное в Python 2.6 и 3.0: декораторы классов, непосредственно связанные с моделью классов, и метаклассы, играющие похожую роль.

class C:
	@staticmethod		# Синтаксис декорирования
	def meth():
		...




""" Исключения - 4 конструкции """

# 1) try / except --

# 2) try / finelly --

# 3) raise --

# 4) assert --

# 5) with / as --


# Пример 1 : Моя попытка описать логику  try // except
>>> def foo(obj, index):		
...     return obj[index]
... 
>>> x='spam'
>>> foo(x, 3)
'm'
>>> foo(x, 4)			# Если в коде создается ошибка то по умолчанию программа 
				# прекращает выполнение (это не всегда приемлимо)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in foo
IndexError: string index out of range

>>> def foo1():
...     try:			# логика проверки выполнения функции и перехват исключения
...         foo(x,4)
...     except IndexError:	# Обработка исключения (если ошибка) логикой
...         print ('got exception')
...     print ('continuing')	# работа программы продолжается
... 
# результат
>>> foo1()
got exception
continuing

"""Если что-то вдруг неправильно идет в блоке try, то выполнение программы тут же перескакивает в блок except, в котором находится обезболивающее средство против полученной ошибки. И программа выполняется далее. Если в try все ок - то программа также выполняется вся далее"""


# Пример2: возбуждение исключения принудительно - raise
	
>>> raise IndexError			# Метод вызова исключения по имени + завершение программы 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError

>>> try:
...     raise IndexError		# Принудительный вызов исключения
... except IndexError:			# Перехват и обработка исключения по имени + программа 
					# продолжается
...     print ('got exception')
... 
# выполение:
got exception


# Близкий к raise методу - assert - объявление ошибки, в основном для тестов
>>> assert False, 'Its a exception sos'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: Its a exception sos	# объявили строку ошибки принудительно

>>> assert ""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError


""" модуль Exception """	- встроенный тип
>>> Exception
<type 'exceptions.Exception'>
>>> Exception.__class__
<type 'type'>



# пример 3: конструкция  try//finnaly  - блок который выполняется обязательно при выходе из try
# похоже на try//except (попытка//отлов исключения) за исключением что в любом случае. даже если Ошибка. блок finnaly выполняется, когда нельзя зависить от резульата try. Ну и программа продолжится

# try//except - попытка/ при ошибке обработка исключения // блок не выполнен // программа продолжена
#try//finnaly - попытка / при ошибке обработка исключения по умолчанию // болок try не выполнен // блок finnaly выполнен (до обработки исключения) // программа продолжена.

""" На практике комбинацию try/except удобно использовать для перехвата и  восстановления после исключений, а комбинацию try/finally – в случаях, когда необходимо гарантировать выполнение заключительных действий независимо от того, возникло исключение в блоке try или нет. Например, комбинацию try/except можно было бы использовать для перехвата ошибок, возникающих в импортированной библиотеке, созданной сторонним разработчиком, а  комбинацию try/finally  – чтобы гарантировать закрытие файлов и  соединений с  сервером. """

>>> def fetcher(obj, index):		# функция принимает Объект и выдает значение Элемента по 
					# индексу
...     return obj[index]
... 
>>> x='spam'				# создана Переменная
>>> fetcher(x,3)			# переменная как объект передана Функции
'm'					# рузультат

>>> fetcher(x,5)			# Автоматическая активация исключения-ошибки
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in fetcher
IndexError: string index out of range


# суть  try:
>>> def after():
...     try:
...         fetcher(x,4)		# задан Ошибочный параметр
...     finally:			# блок который выполняется при выходе из инструкции
...         print('after fetch')
...     print ('after try?')
... 
>>> after()
after fetch				# Выполнение: сначана блок finnaly
Traceback (most recent call last):	# Затем выполнение Исключения по умолчанию 
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in after
  File "<stdin>", line 2, in fetcher
IndexError: string index out of range

>>> 
>>> 
>>> def after():
...     try:
...         fetcher(x,3)		# задан Верный параметр
...     finally:
...         print('after fetch')
...     print ('after try?')
... 
>>> after()
after fetch				# Выполнение: сначана блок finnaly
after try?				# затем выполнение Корректного блока

# можно смешивать try // except // finally - что логично, можо управлять логикой после ошибки и добавлять выполнение finaly


# Приемлимая конструкция проверки кода
if__name__ == ‘__main__’:
	try:
		doStuff() 	# Здесь нас интересуют возможные результаты,
	except:			# поэтому это единственное место, где нужна проверка
		badEnding()
	else:
		goodEnding

#  with//as - ??


""" Инструкция try/except/else """
try:
	<statements>	# Сначала выполняются эти действия
except <name1>:
	<statements>	# Запускается, если в блоке try возникло исключение name1
except (name2, name3):
	<statements>	# Запускается, если возникло любое из этих исключений
except <name4> as <data>:
	<statements>	# Запускается в случае исключения name4
			# и получает экземпляр исключения
except:
	<statements>	# Запускается для всех (остальных) возникших исключений
else:
	<statements>	# Запускается, если в блоке try не возникло никаких исключений


# except (name1, name2) as value: -- Перехватывает любое из перечисленных исключений и получает соответствующий экземпляр

""" если при выполнении функции action возникает исключение, интерпретатор возвращается к  инструкции try и  пытается отыскать первое предложение except, в  котором указано возникшее исключение. Поиск среди предложений except ведется сверху вниз, слева направо, и  выполняются инструкции в первом найденном совпадении. Если совпадений не будет найдено, исключение продолжит распространение выше этой инструкции try.  """

# полезная конструкция - перехватывает все исключения, но не приведет к завершению программы (то есть исключает какие то левые не связанные с кодом исключения, например выход из питона)
try:
	action()
except Exception:	# Перехватит все исключения, кроме завершения программы
...



""" Предложение try/else """
# логика действия: else явно срабатывает и явно указывает на то сто Исключения (except) не было
try:			
	...выполняемый код...
except IndexError:
	...обработка исключения...
else:
	...исключение не было возбуждено...
# Удобная подстраховка, что каких либо Исключения по умолчанию не возникнет, 
# Все что не except - все  else 



# порядок логики -- try -> except -> else -> finally


# пример файл   myfile.py:
sep = '-' * 32 + '\n'
print(sep + '1) EXCEPTION RAISED AND CAUGHT')
try:
	x = 'spam'[99]
except IndexError:
	print('except run')
finally:
	print('finally run')
print('after run')

print(sep + '2) NO EXCEPTION RAISED')
try:
	x = 'spam'[3]
except IndexError:
	print('except run')
finally:
	print('finally run')
print('after run')

print(sep + '3) NO EXCEPTION RAISED, WITH ELSE')
try:
	x = 'spam'[3]
except IndexError:
	print('except run')
else:
	print('else run')
finally:
	print('finally run')
print('after run')

print(sep + '4) EXCEPTION RAISED BUT NOT CAUGHT')
try:
	x = 1 / 0
except IndexError:
	print('except run')
finally:
	print('finally run')
print('after run')


# выполнение:
--------------------------------
1) EXCEPTION RAISED AND CAUGHT
except run
finally run
after run
--------------------------------
2) NO EXCEPTION RAISED
finally run
after run
--------------------------------
3) NO EXCEPTION RAISED, WITH ELSE
else run
finally run
after run
--------------------------------
4) EXCEPTION RAISED BUT NOT CAUGHT
finally run
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "myfile.py", line 35, in <module>
    x = 1 / 0
ZeroDivisionError: integer division or modulo by zero


""" raise - ручной вызов исключения """

>>> raise RuntimeError		# Вызов Класса Исключения - см.Дерево Исключений
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError

>>> x= Warning()		# Создание Инстанса Исключения
>>> raise x			# Вызов Инстанса Исключения
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Warning


try:
    except IndexError as X: # Переменной X будет присвоен Инстанс Исключения


""" Конструкция whith // as  - близка по идеологии к try // finally"""
# обе конструкции могут сохранять и закрывать вызванные модули явно
# 1)
with open(r’C:\misc\data’) as myfile:	# Дословно с объектом таким то под Инстансем сделать логику
					# также по умолчанию сохранить все переменные и закроет файл 
	for line in myfile:
		print(line)
		...остальной программный код...

#2)
myfile = open(r’C:\misc\data’)
try:					# Пробуем делать Логику (без исключений)
	for line in myfile:
		print(line)
	...остальной программный код...
finally:
	myfile.close()			# в итоге не забываем сохранить файл и закрыть.


""" После того как инструкция with начнет выполнение, механизм управления контекстом гарантирует, что объект файла, на который ссылается переменная myfile, будет закрыт автоматически, даже если в цикле for во время обработки файла произойдет исключение. """


with A() as a, B() as b:
...инструкции...		# перспективная конструкция в новых версиях Питона

# равна конструкции
with A() as a:
	with B() as b:
		...инструкции...



""" Классы Исключений - Создание """


class General(Exception): pass			# Наследование от СуперКласса "Исключения"
class Specific1(General): pass			# 2 ПодКласса
class Specific2(General): pass			# Фактически созданы Произвольные Класса Исключений


def raiser0(): raise General()			# Вызов ПодКласса с Исключениями
def raiser1(): raise Specific1()
def raiser2(): raise Specific2()

for func in (raiser0, raiser1, raiser2):	# генератор списка из элементов функций
	try:
		func()
	except General as X:			# X – возбужденный экземпляр
		print('caught:', X.__class__) 	# То же, что и sys.exc_info()[0]

# результат:
>>> import myfile
('caught:', <class 'myfile.General'>)
('caught:', <class 'myfile.Specific1'>)
('caught:', <class 'myfile.Specific2'>)

""" В Python  3.0 все знакомые исключения, с  которыми нам уже приходилось встре­чаться (например, SyntaxError), в действительности являются обычными классами, доступными в виде встроенных имен в модуле builtins (в Python 2.6 этот модуль называется __builtin__) и в виде атрибутов модуля exceptions, входящего в  состав стандартной библиотеки. """

#BaseException - Корневой суперкласс исключений. Этот класс не предназначен для непо средственного наследования пользовательскими классами (для этого следует использовать класс Exception)

""" Exception -- Корневой суперкласс всех прикладных исключений. Это прямой потомок суперкласса BaseException и суперкласс для всех других встроенных исключений, кроме классов, связанных с событиями завершения программы (SystemExit, KeyboardInterrupt и GeneratorExit). Почти все пользовательские классы исключений должны наследовать этот класс, а не BaseException. При со-
блюдении этого соглашения предложения except инструкции try, в которых указано исключение Exception, будут перехватывать все исключения, кроме событий завершения программы, которые обычно обрабатывать не требуется. В результате использование имени Exception в инструкции try обеспечивает более точную избирательность, чем пустое предложение except.  """


ArithmeticError -- Суперкласс всех арифметических ошибок (и подкласс класса Exception).
 
OverflowError -- Подкласс класса ArithmeticError, идентифицирующий конкретную арифметическую ошибку.

# Иерархия типов Исключений: 
# The class hierarchy for built-in exceptions is:
BaseException
 +-- SystemExit			# исключение выхода их интерпретатора python
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception			# Ветка исключений без выхода из программы (Exception можно 	
				# использовать без влезания вглубь)
      +-- StopIteration
      +-- StandardError
      |    +-- BufferError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |         +-- UnicodeError
      |              +-- UnicodeDecodeError
      |              +-- UnicodeEncodeError
      |              +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
	   +-- ImportWarning
	   +-- UnicodeWarning
	   +-- BytesWarning


# Самый универсальный способ Обработки Исключений - Без выхода из Программы по итогу
try:
	action()
except Exception:			# СуперКласс всех исключений без выхода из программы
	...обработать все прикладные исключения...
else:
	...обработать ситуацию отсутствия исключений...


# элемент args исключений  -- сохраняет элементы передаваемые Конструктору 
""" Если, наследуя встроенные классы исключений, вы не переопределяете конструктор суперкласса, любые аргументы, передаваемые конструктору, будут сохраняться в атрибуте args экземпляра и автоматически включаться в текст сообщения при выводе экземпляра (если конструктор вызывался без аргументов, будут выведены пустой кортеж и стандартная строка сообщения). """
>>> I = IndexError(‘spam’)
>>> I.args
(‘spam’,)

# В собранных пользователем Классах исключений таклой эже принцип заполнения агрумента args значениями входных параметров. Суперклассы встроенных исключений реализуют конструктор по умолчанию, который автоматически сохраняет аргументы в экземпляре, в виде кортежа, в атрибуте с именем args.

# пользовательский Класс Исключений
>>> class E(Exception): pass		# Создали пользовательский Класс исключений (полное наслед-е)
... 
>>> try:
...     raise E('spam', 'ham', 'ege')	# оживили Исключение передав входящие аргументы
... except E as X:			# увидели  и отработали Исключение Инстансем (он сохраняет
					# аргументы) 
...     print (X, X.args)		# вывелим аргументы Инстанса-Исключения на экран
... 
(E('spam', 'ham', 'ege'), ('spam', 'ham', 'ege'))


# тиким образом лучше переназначить строку вывода сообщения при работе Исключения
>>> class MyBad(Exception):
... 	def __str__(self):
... 		return ‘Always look on the bright side of life...’


# пример:
>>> class FormatError(Exception):
... 	def __init__(self, line, file):
... 		self.line = line
... 		self.file = file
...
>>> def parser():
... 	raise FormatError(42, file=’spam.txt’) 		# Если обнаружена ошибка
..
>>> try:
... 	parser()
... 	except FormatError as X:
... 		print(‘Error at’, X.file, X.line)
...
Error at spam.txt 42


"""  Вложенные обработчики исключений  // try(try) и т.д.  """
# код:
# общий принцип // выполняется вся цепочка try пока не сработал excect

def action2():
	print(2+[])			# Явная ошибка

def action1():
	try:
		action2()
	except TypeError:
		print('yyy')		# Возникает перехват Исключения
	finally:			# безусловно выполняется
		print('zzz')

try:					# Этот try уже не выполнятеся, так как в предыдущем 
					# сработал  excect 
	action1()		
except TypeError:
	print('xxx')

# выполнение:
>>> reload(myfile)
yyy
zzz
<module 'myfile' from 'myfile.py'>


""" Сигналы и Предупреждения(Warning) как разновидность Исключений (не Ошибки) """

# sys.exit() - Вызывает Исключение SystemExit, которое закрывает программу - это Сигнал

# Ctrl+C - Вызывает Исключение  KeyboardInterrupt, которое завершает сценарий - это Сиграл

# Проектирование Сигнала об неудаче:
class Failure(Exception): pass
def searcher():
	if ...успех...:
		return ...найденный_элемент...
	else: 	
		raise Failure()
try:
	item = searcher()
except Failure:
	...сообщение о неудаче...
else:
	...обработка найденного элемента...



""" Закрытие файлов и соединений с сервером  """
# вариант 1:
myfile = open(r’C:\misc\script’, ‘w’)	# создание Инстанса из открытого файла
try:
	...обработать myfile...
finally:
	myfile.close()			# Сохранение и Закрытия файла

#вариант 2:
with open(r’C:\misc\script’, ‘w’) as myfile:	# Через Инстанс работа с файлом, 
						# его Открытие, изменение, Закрытие
	...обработать myfile...


""" Тестинг Кода через пустой excect (Исключения) """

# пустое предложение except перехватывает любые необработанные исключения, возникшие в ходе
# выполнения программы. Чтобы получить доступ непосредственно к  самому исклю­чению, вызовите
# встроенную функцию sys.exc_info из модуля sys – она возвращает кортеж, в котором первые два
# элемента содержат имя исключения и  экземпляр класса возбужденного исключения:

try:
	...запуск программы...
except:		# Сюда попадут все необработанные исключения
	import sys
	print(‘so:’, sys.exc_info()[0], sys.exc_info()[1])

# Этот прием часто используется во время разработки, так как он позво­ляет сохранить программу
# активной даже после ошибки  – с  его помощью можно производить дополнительные проверки без
# необходимости перезапус­кать программу.

# модуль sys.exc_info() - содержит информацию о последнем возбужденном исключении - 3 парметра (тип, значение, трассировочная информация) sys.exc_info()[0:2]


# лучше чаше назначать except + имя Класса Исключения , тогда меньше пропустим критических ошибок!!!



""" Заключение по основам языка
Поздравляю! Этим разделом заканчивается ваше изучение основ язы­ка про-
граммирования Python. Если вы забрались так далеко, что чи­таете эти строки,
можете смело считать себя Официальным Програм­мистом на языке Python
(и можете не стесняться упоминать о знании этого языка в своих резюме). Вы
уже видели почти все, что можно уви­деть в самом языке, и получили знания
более глубокие, чем имели многие практикующие программисты на язы-
ке Python в  начале своего пути. Вы изучили встроенные типы, инструкции
и  исключения, а  так­же инструменты, которые используются для создания
крупных эле­ментов программ (функции, модули и  классы). Кроме того, вы
иссле­довали ряд важных проблем, связанных с  проектированием, ООП, ар­
хитектуру программы и многое другое.  """



"""  Набор инструментальных средств языка Python  """

#  Внешние инструменты       NumPy, SWIG, Jython, IronPython, Django и др.

# PyDoc - дает документирование для объектов Python методом help()

# PyChecker и  PyLint - сторонние пакети для широкого тестирования кода проекта на Python

# PyUnit (он же unittest) - комплекс классов для настройки тестов и ожидаемых результатов

# doctest - стандартная библиотека Python для тестирования кода

# Интегрированные Среды Разработки - PyCharm, Sublime Text,  Eclipse, Komodo, NetBeans, Wing

# Профилировщики/Оптимизаторы - стандартная библиотека profile, 
	import profile
	profile.run('code')

# Отладчики - стандартный модуль   pdb - отладчик исходного текста
	pdb.run(“main()”)
	python -m pdb main.py args...
# современные среды разработки позволяют делать отладку п принципу //подсветил код/правая кнопка/отладка//



""" Строки    Юникод   Символы ASCII  """

# поиск по шаблону

# сериализация объектов
 
# упаковка двоичных данных

# синтаксический анализ разметки XML
 
# кодировки ASCII  Latin-1  UTF-8   – рассматриваются как Юникод
# модуль который содержит инфу о поддерживаемых стандартах кодировки символов
>>> import encodings
>>> help(encodings)

# узнать кодировку по-умолчанию  (лучше utf-8)
>>> import sys
>>> sys.getdefaultencoding()
'ascii'
>>> sys.platform
'linux2'


""" Объявление кодировки по умолчанию в файлах  """
# -*- coding: latin-1 -*-

# -*- coding: utf-8 -*-		- объявление первой строкой в модуле


""" 
•Для представления текстовых данных использовать тип str.
•Для представления двоичных данных использовать тип bytes.
•Для представления двоичных данных с  возможностью непосредственного изменения использовать тип bytearray.  
"""


"""   Текстовые Файлы  """


>>> file=open('temp', 'w')		# Создали Файл (в папке поумолчанию), записали в него строку
>>> size=file.write('abc\n')		# Режим записи в файл    //open('temp', 'w').write('abc\n')
>>> file.close()			# режим сохранения буфера в файл при закрытии

>>> file=open('temp')			# Открытие и чтение Строк Файла
>>> text=file.read()			# чтение файла в переменную    // open('temp', 'r').read()
>>> text
'abc\n'					# вызов отражате форматированный вид
>>> print text
abc					# Принт отражает Строку


""" Чтение Юникода  """

# -*- coding: utf-8 -*-
from __future__ import unicode_literals		# заготовочка Юникод


""" Выборка подстрок по шаблону  из Строк кода  (модуль re)"""
C:\misc> c:\python26\python
>>> import re
>>> S = ‘Bugger all down here on earth!’ 	# Простой текст и двоичные данные
>>> U = u’Bugger all down here on earth!’ 	# Текст Юникода

>>> re.match(‘(.*) down (.*) on (.*)’, S).groups()
(‘Bugger all’, ‘here’, ‘earth!’)
>>> re.match(‘(.*) down (.*) on (.*)’, U).groups()
(u’Bugger all’, u’here’, u’earth!’)


"""  XML  Разметка //  Парсеры """

XML  – это язык разметки, основанный на тегах, используемый для пред-
ставления информации в  структурированном виде. Часто применяется для
оформления документов и данных, доставляемых через Веб. 
Некоторую долю информации можно извлечь из текста с помощью простых строковых ме-
тодов или модуля re, однако для извлечения информации из многоуровневых
конструкций и из атрибутов тегов требуется выполнять более точный и более
полный синтаксический анализ разметки.
Вследствие того, что формат XML получил чрезвычайно широкое распростра-
нение, в  состав Python был включен целый пакет инструментов для синтак-
сического анализа разметки XML, поддерживающих модели парсинга SAX
и  DOM, а  также пакет, известный под названием ElementTree  – интерфейс
на языке Python, позволяющий анализировать и  конструировать документы
XML. 
Помимо простого синтаксического анализа среди свободного программ-
ного обеспечения можно найти поддержку дополнительных инструментов
XML, таких как XPath, Xquery, XSLT, и многих других.

# пример работы с xml файлом

с  подобной работой прекрасно справляется
модуль (re), с которым мы познакомились выше. Его метод match отыскивает со-
впадения с начала строки, метод (search) заглядывает вперед в поисках совпаде-
ний, а метод (findall), используемый здесь, отыскивает в строке все совпадения
с шаблоном (и возвращает результат в виде списка совпавших подстрок, соот-
ветствующих группам в круглых скобках, или кортежей для множественных
групп)

# сам файл mybooks.xml
<books>
    <date>2009</date>
    <title>Learning Python</title>
    <title>Programming Python</title>
    <title>Python Pocket Reference</title>
    <publisher>O’Reilly Media</publisher>
</books>

# выполнениев консоли :
>>> import re				# импорт модуля re  // модуль регулярных выражений

>>> dir(re)				# структура модуля re
['DEBUG', 'DOTALL', 'I', 'IGNORECASE', 'L', 'LOCALE', 'M', 'MULTILINE', 'S', 'Scanner', 'T', 'TEMPLATE', 'U', 'UNICODE', 'VERBOSE', 'X', '_MAXCACHE', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__version__', '_alphanum', '_cache', '_cache_repl', '_compile', '_compile_repl', '_expand', '_locale', '_pattern_type', '_pickle', '_subx', 'compile', 'copy_reg', 'error', 'escape', 'findall', 'finditer', 'match', 'purge', 'search', 'split', 'sre_compile', 'sre_parse', 'sub', 'subn', 'sys', 'template']


>>> text=open('mybooks.xml', 'r').read()	# открытие и чтение файла xml в переменную

>>> fond=re.findall('<title>(.*)</title>', text)	# логика поиска по регулярному выражению 
							# - данные идут в переменную 

>>> for title in fond: print title			# генерирование выражений из объектов 
							# переменной  fond  
... 
Learning Python
Programming Python
Python Pocket Reference


>>> dir(xml)			# модуль под xml
['_MINIMUM_XMLPLUS_VERSION', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__']
>>> xml.__path__
['/home/ryndin/data/work/buildouts/python/parts/opt/lib/python2.7/xml']


>>> xml.__all__			# все парсеры для работы с xml 
['dom', 'parsers', 'sax', 'etree']
"""
DESCRIPTION
    This package contains four sub-packages:
    
    dom -- The W3C Document Object Model.  This supports DOM Level 1 +
           Namespaces.
    
    parsers -- Python wrappers for XML parsers (currently only supports Expat).
    
    sax -- The Simple API for XML, developed by XML-Dev, led by David
           Megginson and ported to Python by Lars Marius Garshol.  This
           supports the SAX 2 API.
    
    etree -- The ElementTree XML library.  This is a subset of the full
           ElementTree XML release.

PACKAGE CONTENTS
    dom (package)
    etree (package)
    parsers (package)
    sax (package)
"""


# также Обработку модулей xml  выполняют парсеры: 1) парсер DOM, 2) парсер SAX 3) парсер etree- 
# они в стандартной библиотеке python (модуль xml)

Парсер DOM преобразует документ XML в  дерево
объектов и  предоставляет интерфейс для навигации по дереву, извлечения
атрибутов и значений тегов – интерфейс имеет формальную спецификацию, не
зависящую от языка Python

В качестве третьего варианта можно было бы использовать парсер SAX, также
входящий в стандартную библиотеку. В модели SAX в процессе анализа произ-
водятся вызовы методов класса, которым передается дополнительная инфор-
мация, позволяющая определить, в каком месте документа находится парсер,
и выбрать необходимые данные

Наконец, система ElementTree, доступная в  виде пакета etree в  стандартной
библиотеке, часто позволяет добиться того же эффекта, что и  парсеры XML
DOM, но за счет меньшего объема программного кода. Этот характерный для
Python способ позволяет анализировать и  конструировать документы XML.
После анализа документа система ElementTree обеспечивает доступ к  компо-
нентам документа:

# пример etree - файл  etreeparse.py
from xml.etree.ElementTree import parse
tree = parse(‘mybooks.xml’)
for E in tree.findall(‘title’):
	print(E.text)


# Пример Парсинга
>>> from xml.dom.minidom import parse, Node
>>> xmltree = parse(‘mybooks.xml’)
>>> for node in xmltree.getElementsByTagName(‘title’):
... 	for node2 in node.childNodes:
... 		if node2.nodeType == Node.TEXT_NODE:
... 			node2.data
...
‘Learning Python’
‘Programming Python’
‘Python Pocket Reference’


""" Чудеса обращения к атрибутам  """

Будут представлены:
• Методы __getattr__ и __setattr__, которые вызываются при обращении к не-
существующим атрибутам и  при присваивании значений любым атрибу-
там.
• Метод __getattribute__, который вызывается при обращении к любым атри-
бутам в классах нового стиля в Python 2.6 и во всех классах в Python 3.0.
• Встроенная функция property, которая позволяет определить для отдель-
ных атрибутов методы чтения и записи, – такие атрибуты часто называют
свойствами.
• Протокол дескрипторов, который позволяет организовать доступ к отдель-
ным атрибутам с помощью экземпляров классов с произвольными метода-
ми чтения и записи.

# логика функции property
attribute = property(fget, fset, fdel, doc) - по умолчанию None
# вызываются функции которые будут делать get set del и  doc для атрибута
# функция fget - возвращает значение атрибута
# функция fset - для установления значения атрибута 
# функция fdel - для удаления значения атрибута
# находится в области видимости Класса и наследуетс Инстансами

# пример property файл myfile.py
# Представлены 2 класса по логике абсолютно эдентичные
# во втором классе вся логика через Декоратор (обертку) где Проперти есть Декоратор для функции 
# (name) Инстанса, Которая заходят в Декоратор как параметр и в итоге идут в переменную Name

#   //  @decorator
#	def func(args): ... 		- оформление Декоратора

#	def func(args): ...
#	func = decorator(func)		- скрытый смысл Декоратора // Как property для функции


class Person(object):
	def __init__(self, name):		# При создании Инстанса принимает имя
		self._name = name		# Сохраняет с искажением имя переменной

	def getName(self):			# Логика Возвращения атрибута по Вызову 
		print('fetch ...')
		return self._name

	def setName(self, value):		# Логика Переназначения значения атрибута
		print('change ...')
		self._name = value

	def delName(self):			# логика Удаления значения атрибцта
		print('remove ...')
		del self._name

	name = property(getName, setName, delName, "name property docs")			


class Persona(object):				# То же самое но с использованием Декораторов
	def __init__(self, name):
		self._name = name
	
	@property				# фактически Инициация Декоратора для Функции
	def name(self):
		'name property docs'
		print('fetch...')
		return self._name

	@name.setter				# Применение Методов Декоратора для Функции 
	def name(self, value):
		print('change...')
		self._name = value

	@name.deleter				# методы Декоратора getter, setter, deleter
	def name(self):
		print('remove...')
		del self._name



if __name__ == '__main__':
	bob=Person('Bob Smith')			# Создания Инстанса с назначением Имени
	print(bob.name)				# вызов атрибута Инстанса  getName
	print('-'*20)

	bob.name='Robert Smith'			# переназначения атрибута, setName
	print(bob.name)
	del bob.name				# удаление атрибута,  delName
	print('-'*20)

	sue=Person('Sue Jones')
	print(sue.name)
	print('-'*20)
	print Person.name.__doc__		# Или help(Person.name)
	print('-'*20)


	bob = Persona('Bob Smith')
	print(bob.name)
	bob.name = 'Robert Smith'
	print(bob.name)
	del bob.name
	print('-'*20)
	sue = Persona('Sue Jones')
	print(sue.name)
	print(Persona.name.__doc__)

# property атрибута Класса наследуют как Инстанс Класса так и все его ПодКлассы их Инстансы


""" Дескрипторы Атрибутов  """ (скрытая логика поведения атрибутов)

class Person(object):
	def __init__(self, name):
	self._name = name
	
	class Name(object): 		# Вложенный класс атрибута   name
	“name descriptor docs”
	def __get__(self, instance, owner):
		print(‘fetch...’)
		return instance._name
	def __set__(self, instance, value):
		print(‘change...’)
		instance._name = value
	def __delete__(self, instance):
		print(‘remove...’)
		del instance._name
	name = Name()			# атрибут name  полностью наследует встроенный Класс


""" Вычесляемые Атрибуты - Логика """

class DescSquare:			# Сам Класс задает только логику дял Атрибува 
	def __init__(self, start): 		# Каждый дескриптор имеет свои данные
		self.value = start
	def __get__(self, instance, owner): 	# Операция получения значения
		return self.value ** 2
	def __set__(self, instance, value): 	# Операция присваивания
		self.value = value
#
#
if __name__ == '__main__':	# выполнение кода с консоли
	#
	class Client1(object):		# ПодКласс определяет первоначальное значение атрибута Инстанса
		X=DesckSquare(4)
	#	
	class Client2(object):
		X=DesckSquare(33)
	#
	c1=Client1()		# Создание Инстанса Подкласса (запускается вся логика) (__init__)
	c2=Client2()
	print(c1.X)		# возвращает 4 - значение артибута Инстанса Подкласса (__get__)
	
	c1.X=5			# Переопределение значения атрибута Инстанса (__set__)
	print(c1.X)
	print(c2.X)

# Результат:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
16
25
1089



""" Дескрипторы - Данные в них и вне их, Доступность и Переопределение  """

# пример файл myfile.py
# Дескриптор использует собственный атрибут
class DescState(object):					
	
	def __init__(self, value):
		self.value = value
	
	def __get__(self, instance, cls):	# Операция получения значения
		print('DescState get')
		return self.value * 10
	
	def __set__(self, instance, value):	# Операция присваивания (переопределения)
		print('DescState set')
		self.value = value

# Клиентский класс
class CalcAttrs(object):
	X = DescState(2)
	Y = 3
	def __init__(self):
		self.Z = 4

if __name__ == '__main__':
	obj = CalcAttrs()		# Создание Инстанса клиентского класса
	print('-'*20)
	print(obj.X, obj.Y, obj.Z) 	#  x-вычисляетс ядесктиптером, y и z - даны Клиенским классом
	print('-'*20)
	
	obj.X = 5
	obj.Y = 6
	obj.Z = 7
	print(obj.X, obj.Y, obj.Z)


# выполнение:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
--------------------
DescState get			# Сработал одни метод __get__
(20, 3, 4)
--------------------
DescState set
DescState get			# Сработало 2 метода: __get__   и __set__
(50, 6, 7)



"""  Методы __getattr__ и __getattribute__  """
Эти два метода входят в состав множества методов управления доступом к атрибутам,
в число которых также входят методы __setattr__ и __delattr__


def __getattr__(self, name): 		# Обращение к неопределенному атрибуту [obj.name]
 
def __getattribute__(self, name): 	# Обращение к любому атрибуту [obj.name]

def __setattr__(self, name, value): 	# Присваивание любому атрибуту [obj.name=value]

def __delattr__(self, name): 		# Удаление любого атрибута [del obj.name]


class Catcher:
	def __getattr__(self, name):		# Перехват запроса атрибута (по имени)
		print(‘Get:’, name)
	def __setattr__(self, name, value):	# Перехват переопределения атрибута (имя+значение)
		print(‘Set:’, name, value)

# Делегирование выполнения операции: 
class Wrapper(object):
	def __init__(self, obj):
		self.wrapped = obj			# Сохранить объект
	def __getattr__(self, attrname):
		print(‘Trace:’, attrname) 		# Сообщить о попытке чтения
		return getattr(self.wrapped, attrname)	# Делегирование Операции


"""  Декораторы - подробнее """
# @ - это синтаксис декоратора

# property - встроенная функция, но может стать Декоратором

""" Декораторы Функций  """
# конструкция - вторая функция принимает разультат первой функции (добавляет логику первой функции)
# и возвращает результат втророй функции под именем первой функции. 
# Обертка логики первой Функции. Все что віполняется посли блока def первой функции.

Происходит трансформация:

@decorator			# Так задается Декоратор
def foo(arg):			# функция
	....
foo(x)				# инициация функции

# трансформация фактически:
def foo(arg):			# Так интерпретируется и выполняется Декоратор
	....
foo=decorator(foo)
# декораторы могут использоваться для регистрации функций в приклад-
# ном интерфейсе, для присоединения атрибутов к функциям и тому подобного


""" Декоратор Класса """
@decorator		# декоратор Класса
class C():
	...

x=C(99)			# созадине Инстанса - Декоратор класса срабатывает при создании Инстанса
# трансформация фактически:
class C():
	...
C=decorator(C)		

x=C(99)			# фактически происходит decorator(C)(99)


"""  Вложенность Декораторов  """
# декораторы Функций
@A
@B
@C
def f(...):
...
равноценна следующей:
def f(...):
...
f = A(B(C(f)))


# декораторы Классов
@spam
@eggs
class C:
...
X = C()
эквивалентен следующему:
class C:
...
C = spam(eggs(C))
X = C()

# пример вложенных декораторов:
>>> def d1(F): return lambda: 'A'+F()		# задана логика функции-декоратора
... 
>>> def d2(F): return lambda: 'S'+F()
... 
>>> def d3(F): return lambda: 'D'+F()
... 

>>> @d1				# задана логика Головной функции и прилеплен Декоратор
... @d2
... @d3
... def foo():
...     return 'spam'
... 

>>> print foo()			# Вызовы функции			
ASDspam
>>> foo()
'ASDspam'


# Пример Работы Обертки и Счетчика вызовов:
class Tracer(object):			# Класс-Декоратор с логикой для Ф-ции
	def __init__(self, func): 	# Декарировании Функции // счетчик //+выход функции
		self.calls = 0
		self.func = func
	
	def __call__(self, *args, **kwargs): 	# Логика при вызове Функции(+значения)
		self.calls += 1			#  весли счетчик (сохранять атрибут)
		print('call {0} to {1}'.format(self.calls, self.func.__name__))  # печатать
		self.func(*args, **kwargs)	# передавать аргументы

@Tracer
def spam(a, b, c):			# Логика самой фкункции - всего лишь сложение аргументов
	print(a + b + c)

# выполнение:
>>> from myfile import spam
>>> spam(1,2,3)				# Вызов 1. выдал строку по логике
call 1 to spam
6
>>> spam('a', 's', 'd')			# Вызов 2, Выдал строку по логике
call 2 to spam
asd
>>> spam()				# Вызов 3, вызов посчитал но про функцию выдал ошибку
call 3 to spam
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "myfile.py", line 11, in __call__
    self.func(*args)
TypeError: spam() takes exactly 3 arguments (0 given)
>>> spam
<myfile.Tracer object at 0x7fa7f79a2790>
>>> spam.calls				# атрибут о количестве вызов Обертки
3


# Декоратор дополнен приемом аргументов в ввиде Словарей (**kwargs)
# Файл добавлен тестовым моделем:
if __name__ == '__main__':
	print('-'*20)
	spam(1,2,3)
	spam(a=4, b=5, c=6)

	print('-'*20)
	eggs(2,16)
	eggs(4, y=4)

# в итоге выполнение Файла:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
--------------------
call 1 to spam			# вызовы считатает аргументы как Словари и Единичные принимает
6
call 2 to spam		
15
--------------------
call 1 to eggs
65536
call 2 to eggs
256

""" Замечание:  Общая суть Декораторов понятна, но пока углубляться дальше не буду. 
Затем как будет время, пройду Декраторы полностью  страницы 1087-1160 учебника Лутца"""



""" МетаКлассы """
# редоставляют возможность добавлять дополнительный программный код, который будет выполняться в конце инструкции class, хотя и иначе, чем декораторы.
# имеют отношение к объектно-реляционные отображения (object/relational mappers, ORM)

""" В отличие от декораторов классов, которые обычно добавляют логику, вызываемую на этапе создания экземпляров (Инстансов) классов, метаклассы выполняются на этапе создания классов – они представляют собой обработчики, которые используются для управления классами, а не их экземплярами. """

# Суть:
def extra(self, arg): ...		# Просто глобвльная функция с логикой

class Extras(type):			# Класс для Инстанса устанавливает логику глоб.функции
	def __init__(Class, classname, superclasses, attributedict):
		if required():
		Class.extra = extra

class Client1 (metaclass=Extras): ... 	# Создание Независимого Класса назначаем за счет МетаКласса
					# это не наследование (и не для Инстансев)

# Важно!! Логика МетаКласса выпонятеся в Классе только в конце всей логики внутри class 

# Метаклассы – подклассы класса type  !!! (прородителя всего)

# логика создания любого класса - ниже, то есть после инструкции class проделывается вся логика, описанная после class, а уже в конце выполняется следующее:
class = type(classname, superclasses, attributedict)  - создается объект класса


type.__new__(typeclass, classname, superclasses, attributedict)  --  создается новый Объект
type.__init__(class, classname, superclasses, attributedict) -- Инициируется новый Объект
# таким образом type инициирует создание Класса как своего объекта, такова скрытая логика

"""  Создание МетаКласса  """

------------------------
# По умолчанию все Классы создаются от объекта type. Задача МетаКласса - встать на место type!!!
------------------------

class Spam(metaclass=Meta):
# В версии 3.0 и выше

class Spam(Eggs, metaclass=Meta): # Допускается указывать суперклассы

class spam(object):
	__metaclass__ = Meta 		# Только в версии 2.6


# в итоге происходит логика:
class = Meta(classname, superclasses, attributedict)
Meta.__new__(Meta, classname, superclasses, attributedict)
Meta.__init__(class, classname, superclasses, attributedict)

Обычно метаклассы переопределяют методы __new__ и  __init__ класса type, настраивая процедуру созда
ния и инициализации, но они также могут переопределять метод __call__, когда требуется перехватить вызов процедуры создания класса в конце инструкции class.

Хотя это и необычно, но они также могут быть простыми функциями, которые возвращают произвольные объекты вместо подклассов класса type.

Так как классы являются экземплярами метаклассов, поведение, определяемое метаклассом, применяется к классу, но не к экземплярам этого класса. Экземпляры приобретают поведение от своих классов и суперклассов, но не от метаклассов.


"""  МетаКлассы - Экземпляры и наследование  """
# Метаклассы наследуют класс type.
# Объявления метаклассов наследуются подклассами
# Атрибуты метакласса не наследуются экземплярами классов.

# пример myfile.py
class MetaOne(type):			# МетаКласс наследуется от type
	def __new__(meta, classname, supers, classdict):	# Логика для создания Класса Супер
		print('In MetaOne.new:  ', classname)
		return type.__new__(meta, classname, supers, classdict)
	def toast(self):		# Функция внитри МетаКласса
		print('toast')

class Super():
	__metaclass__=MetaOne		# Класс супер создается не от type а от МетаКласса
	def spam(self):
		print('spam')

class C(Super):				# Подкласс наследуется от СуперКласса
	def eggs(self):
		print('eggs')

if __name__ == '__main__':
	X=C()				# создание Инстанса ПодКласса
	X.eggs()			# вызов метода ПодКласса через Инстанс - Тру
	X.spam()			# вызов метода СуперКласса через Инстанс - Тру
	X.toast()			# вызов метода МетаКласса через Инстанс - Ошибка

# выполнение:
ryndin@ryndin-pk:~/data/work/virtualenvs/studentsdb/src/studentsdb$ python myfile.py
('In MetaOne.new:  ', 'Super')
('In MetaOne.new:  ', 'C')
eggs
spam
Traceback (most recent call last):
  File "myfile.py", line 24, in <module>
    X.toast()
AttributeError: 'C' object has no attribute 'toast'



""" Логика Создания Нового Класса из МетаКласса"""
class MetaOne(type):			# МетаКласс наследуется от type
	def __new__(meta, classname, supers, classdict):	# Логика для создания Класса Супер
		print('In MetaOne.new:  ', classname)
		return type.__new__(meta, classname, supers, classdict)


class UpperAttrMetaclass(type): 
    def __new__(cls, name, bases, dct):		# негласное соглашение отображения атрибутов
	
	return type.__new__(cls, name, bases, uppercase_attr)


# Альтернативная логика создания Класса из МетаКласса (через метод ruper() ) 
class UpperAttrMetaclass(type): 

    def __new__(cls, name, bases, dct):

        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)


# рашать нам как отображать имена атрибутов - но из наваний суть понята
def __new__(meta, classname, supers, classdict)  
// или
def __new__(cls, name, bases, dct)


# Признаки Объектов (применительно к Классам)
Этот объект (класс) сам может создавать объекты (экземпляры), поэтому он и является классом.
Тем не менее, это объект, а потому:
    его можно присвоить переменной,
    его можно скопировать,
    можно добавить к нему атрибут,
    его можно передать функции в качестве аргумента,




    Профиль
    3 Публикации
    216 Комментарии
    31 Избранное
    12 Подписчики

14 июня 2012 в 20:09
Метаклассы в Python перевод
Python*
Как сказал один из пользователей StackOverflow, «using SO is like doing lookups with a hashtable instead of a linked list». Мы снова обращаемся к этому замечательному ресурсу, на котором попадаются чрезвычайно подробные и понятные ответы на самые различные вопросы.

В этот раз мы обсудим, что такое метаклассы, как, где и зачем их использовать, а также почему обычно этого делать не стоит.

Классы как объекты

Перед тем, как изучать метаклассы, надо хорошо разобраться с классами, а классы в Питоне — вещь весьма специфическая (основаны на идеях из языка Smalltalk).

В большинстве языков класс это просто кусок кода, описывающий, как создать объект. В целом это верно и для Питона:

  >>> class ObjectCreator(object):
  ...       pass
  ... 

  >>> my_object = ObjectCreator()
  >>> print my_object
  <__main__.ObjectCreator object at 0x8974f2c>


Но в Питоне класс это нечто большее — классы также являются объектами.

Как только используется ключевое слово class, Питон исполняет команду и создаёт объект. Инструкция

  >>> class ObjectCreator(object):
  ...       pass
  ...


создаст в памяти объект с именем ObjectCreator.

Этот объект (класс) сам может создавать объекты (экземпляры), поэтому он и является классом.

Тем не менее, это объект, а потому:

    его можно присвоить переменной,
    его можно скопировать,
    можно добавить к нему атрибут,
    его можно передать функции в качестве аргумента,



Динамическое создание классов

Так как классы являются объектами, их можно создавать на ходу, как и любой объект.

Например, можно создать класс в функции, используя ключевое слово class:

  >>> def choose_class(name):
  ...     if name == 'foo':
  ...         class Foo(object):
  ...             pass
  ...         return Foo # возвращает класс, а не экземпляр
  ...     else:
  ...         class Bar(object):
  ...             pass
  ...         return Bar
  ...     
  >>> MyClass = choose_class('foo') 
  >>> print MyClass # функция возвращает класс, а не экземпляр
  <class '__main__.Foo'>
  >>> print MyClass() # можно создать экземпляр этого класса
  <__main__.Foo object at 0x89c6d4c>


Однако это не очень-то динамично, поскольку по-прежнему нужно самому писать весь класс целиком.

Поскольку классы являются объектами, они должны генерироваться чем-нибудь.

Когда используется ключевое слово class, Питон создаёт этот объект автоматически. Но как и большинство вещей в Питоне, есть способ сделать это вручную.

Помните функцию type? Старая-добрая функция, которая позволяет определить тип объекта:

>>> print type(1)
<type 'int'>
>>> print type("1")
<type 'str'>
>>> print type(ObjectCreator)
<type 'type'>
>>> print type(ObjectCreator())
<class '__main__.ObjectCreator'>


На самом деле, у функции type есть совершенно иное применение: она также может создавать классы на ходу. type принимает на вход описание класса и созвращает класс.

(Я знаю, это по-дурацки, что одна и та же функция может использоваться для двух совершенно разных вещей в зависимости от передаваемых аргументов. Так сделано для обратной совместимости)

type работает следующим образом:

  type(<имя класса>, 
       <кортеж родительских классов>, # для наследования, может быть пустым
       <словарь, содержащий атрибуты и их значения>)


Например,

>>> class MyShinyClass(object):
...       pass


может быть создан вручную следующим образом:

  >>> MyShinyClass = type('MyShinyClass', (), {}) # возвращает объект-класс
  >>> print MyShinyClass
  <class '__main__.MyShinyClass'>
  >>> print MyShinyClass() # создаёт экземпляр класса
  <__main__.MyShinyClass object at 0x8997cec>


Возможно, вы заметили, что мы используем «MyShinyClass» и как имя класса, и как имя для переменной, содержащей ссылку на класс. Они могут быть различны, но зачем усложнять?

type принимает словарь, определяющий атрибуты класса:

>>> class Foo(object):
...       bar = True


можно переписать как

  >>> Foo = type('Foo', (), {'bar':True})


и использовать как обычный класс

  >>> print Foo
  <class '__main__.Foo'>
  >>> print Foo.bar
  True
  >>> f = Foo()
  >>> print f
  <__main__.Foo object at 0x8a9b84c>
  >>> print f.bar
  True


Конечно, можно от него наследовать:

  >>>   class FooChild(Foo):
  ...         pass


превратится в

  >>> FooChild = type('FooChild', (Foo,), {})
  >>> print FooChild
  <class '__main__.FooChild'>
  >>> print FooChild.bar # bar is inherited from Foo
  True


В какой-то момент вам захочется добавить методов вашему классу. Для этого просто определите функцию с нужной сигнатурой и присвойте её в качестве атрибута:

>>> def echo_bar(self):
...       print self.bar
... 
>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
>>> hasattr(Foo, 'echo_bar')
>>> hasattr(FooChild, 'echo_bar')
True
>>> my_foo = FooChild()
>>> my_foo.echo_bar()
True


Уже понятно, к чему я клоню: в Питоне классы являются объектами и можно создавать классы на ходу.

Это именно то, что Питон делает, когда используется ключевое слово class, и делает он это с помощью метаклассов.

Что такое метакласс (наконец)

Метакласс это «штука», которая создаёт классы.

Мы создаём класс для того, чтобы создавать объекты, так? А классы являются объектами. Метакласс это то, что создаёт эти самые объекты. Они являются классами классов, можно представить это себе следующим образом:

  MyClass = MetaClass()
  MyObject = MyClass()


Мы уже видели, что type позволяет делать что-то в таком духе:

  MyClass = type('MyClass', (), {})


Это потому что функция type на самом деле является метаклассом. type это метакласс, который Питон внутренне использует для создания всех классов.

Естественный вопрос: с чего это он его имя пишется в нижнем регистре, а не Type?

Я полагаю, это просто для соответствия str, классу для создания объектов-строк, и int, классу для создания объектов-целых чисел. type это просто класс для создания объектов-классов.

Это легко проверить с помощью атрибута __class__:

В питоне всё (вообще всё!) является объектами. В том числе числа, строки, функции и классы — они все являются объектами и все были созданы из класса:

  >>> age = 35
  >>> age.__class__
  <type 'int'>
  >>> name = 'bob'
  >>> name.__class__
  <type 'str'>
  >>> def foo(): pass
  >>> foo.__class__
  <type 'function'>
  >>> class Bar(object): pass
  >>> b = Bar()
  >>> b.__class__
  <class '__main__.Bar'>


А какой же __class__ у каждого __class__?

  >>> a.__class__.__class__
  <type 'type'>
  >>> age.__class__.__class__
  <type 'type'>
  >>> foo.__class__.__class__
  <type 'type'>
  >>> b.__class__.__class__
  <type 'type'>


Итак, метакласс это просто штука, создающая объекты-классы.

Если хотите, можно называть его «фабрикой классов»

type это встроенный метакласс, который использует Питон, но вы, конечно, можете создать свой.

Атрибут __metaclass__

При написании класса можно добавить атрибут __metaclass__:

class Foo(object):
  __metaclass__ = something...
  [...]


В таком случае Питон будет использовать указанный метакласс при создании класса Foo.

Осторожно, тут есть тонкость!

Хоть вы и пишете class Foo(object), объект-класс пока ещё не создаётся в памяти.

Питон будет искать __metaclass__ в определении класса. Если он его найдёт, то использует для создания класса Foo. Если же нет, то будет использовать type.

То есть когда вы пишете

class Foo(Bar):
  pass


Питон делает следующее:

Есть ли у класса Foo атрибут __metaclass__?

Если да, создаёт в памяти объект-класс с именем Foo, используя то, что указано в __metaclass__.

Если Питон не находит __metaclass__, он ищет __metaclass__ в родительском классе Bar и попробует сделать то же самое.

Если же __metaclass__ не находится ни в одном из родителей, Питон будет искать __metaclass__ на уровне модуля.

И если он не может найти вообще ни одного __metaclass__, он использует type для создания объекта-класса.

Теперь важный вопрос: что можно положить в __metaclass__?

Ответ: что-нибудь, что может создавать классы.

А что создаёт классы? type или любой его подкласс, а также всё, что использует их.

Пользовательские метаклассы

Основная цель метаклассов — автоматически изменять класс в момент создания.

Обычно это делает для API, когда хочется создавать классы в соответсвии с текущим контекстом.

Представим глупый пример: вы решили, что у всех классов в вашем модуле имена атрибутов должны быть записать в верхнем регистре. Есть несколько способов это сделать, но один из них — задать __metaclass__ на уровне модуля.

В таком случае все классы этого модуля будут создаваться с использованием указанного меакласса, а нам остаётся только заставить метакласса переводить имена всех атрибутов в верхний регистр.

К счастью, __metaclass__ может быть любым вызываемым объектом, не обязательно формальным классом (я знаю, что-то со словом «класс» в названии не обязано быть классом, что за ерунда? Однако это полезно).

Так что мы начнём с простого примера, используя функцию.

# метаклассу автоматически придёт на вход те же аргументы,
# которые обычно используются в `type`
def upper_attr(future_class_name, future_class_parents, future_class_attr):
  """
    Возвращает объект-класс, имена атрибутов которого
    переведены в верхний регистр
  """

  # берём любой атрибут, не начинающийся с '__'
  attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
  # переводим их в верхний регистр
  uppercase_attr = dict((name.upper(), value) for name, value in attrs)

  # создаём класс с помощью `type`
  return type(future_class_name, future_class_parents, uppercase_attr)

__metaclass__ = upper_attr # это сработает для всех классов в модуле

class Foo(object): 
  # или можно определить __metaclass__ здесь, чтобы сработало только для этого класса
  bar = 'bip'

print hasattr(Foo, 'bar')
# Out: False
print hasattr(Foo, 'BAR')
# Out: True

f = Foo()
print f.BAR
# Out: 'bip'


А теперь то же самое, только используя настояший класс:

# помним, что `type` это на само деле класс, как `str` и `int`,
# так что от него можно наследовать
class UpperAttrMetaclass(type): 
    # Метод __new__ вызывается перед __init__
    # Этот метод создаёт обхект и возвращает его,
    # в то время как __init__ просто инициализирует объект, переданный в качестве аргумента.
    # Обычно вы не используете __new__, если только не хотите проконтролировать,
    # как объект создаётся
    # В данном случае созданный объект это класс, и мы хотим его настроить,
    # поэтому мы перегружаем __new__.
    # Можно также сделать что-нибудь в __init__, если хочется.
    # В некоторых более продвинутых случаях также перегружается __call__,
    # но этого мы сейчас не увидим.
    def __new__(upperattr_metaclass, future_class_name, 
                future_class_parents, future_class_attr):

        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return type(future_class_name, future_class_parents, uppercase_attr)


Но это не совсем ООП. Мы напрямую вызываем type и не перегружаем вызов __new__ родителя. Давайте сделаем это:

class UpperAttrMetaclass(type): 

    def __new__(upperattr_metaclass, future_class_name, 
                future_class_parents, future_class_attr):

        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        # используем метод type.__new__
        # базовое ООП, никакой магии
        return type.__new__(upperattr_metaclass, future_class_name, 
                            future_class_parents, uppercase_attr)


Вы, возможно, заметили дополнительный аргумент upperattr_metaclass. Ничего особого в нём нет: метод всегда получает первым аргументом текущий экземпляр. Точно так же, как вы используете self в обычным методах.

Конечно, имена, которые я тут использовал, такие длинные для ясности, но как и self, есть соглашение об именовании всех этих аргументов. Так что реальный метакласс выгляит как-нибудь так:

class UpperAttrMetaclass(type): 

    def __new__(cls, name, bases, dct):

        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return type.__new__(cls, name, bases, uppercase_attr)


Можно сделать даже лучше, использовав super</super>, который вызовет наследование (поскольку, конечно, можно создать метакласс, унаследованный от метакласса, унаследованного от <code>type):

class UpperAttrMetaclass(type): 

    def __new__(cls, name, bases, dct):

        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)


Вот и всё. О метаклассах больше ничего и не сказать.

Причина сложности кода, использующего метаклассы, не в самих метаклассах. Она в том, что обычно метаклассы используются для всяких изощрённых вещей, основанных на интроспекции, манипуляцией наследованием, переменными вроде __dict__ и тому подобном.

Действительно, метаклассы особенно полезны для всякой «чёрной магии», а, следовательно, сложных штук. Но сами по себе они просты:

    перехватить создание класса
    изменить класс
    вернуть модифицированный


""" Зачем использовать метаклассы вместо функций?

Поскольку __metaclass__ принимает любой вызываемый объект, с чего бы вдруг использовать класс, если это очевидно сложнее?

Тому есть несколько причин:

    Назначение яснее. Когда вы видите UpperAttrMetaclass(type), вы сразу знаете, что дальше будет.
    Можно использовать ООП. Метаклассы могту наследоваться от метаклассов, перегружая родитальские методы.
    Лучше структурированный код. Вы не будете использовать метаклассы для таких простых вещей, как в примере выше. Обычно это что-то сложное. Возможность создать несколько методов и сгруппировать их в одном классе очень полезна, чтобы сделать код более удобным для чтения.
    Можно использовать __new__, __init__ и __call__. Конечно, обычно можно всё сделать в __new__, но некоторым комфортнее использовать __init__
    Они называются метаклассами, чёрт возьми! Это должно что-то значить!  """




""" Основное применение метаклассов это создание API. Типичный пример — Django ORM.

Она позволяет написать что-то в таком духе:

  class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()


Однако если вы выполните следующий код:

  guy = Person(name='bob', age='35')
  print guy.age


вы получите не IntegerField, а int, причём значение может быть получено прямо из базы данных.

Это возможно, потому что models.Model определяет __metaclass__, который сотворит некую магию и превратит класс Person, который мы только что определили простым выражением в сложную привязку к базе данных.

Django делает что-то сложное выглядящим простым, выставляя наружу простое API и используя метаклассы, воссоздающие код из API и незаметно делающие всю работу.  """




